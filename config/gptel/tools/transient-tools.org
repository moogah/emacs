#+title: GPTEL Transient Tools
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle transient-tools.el
#+auto_tangle: y

* Introduction

Demonstration of async gptel tools that use transient menus for user interaction.

This module implements a minimal proof-of-concept showing how to:
1. Accept async callback from gptel tool system
2. Open a transient menu (which switches buffer/window context)
3. Capture user selection from transient suffix commands
4. Invoke the callback with the result to continue the FSM

** Architecture Notes

Key challenge: Transient menus open in a new buffer (*transient*) with focus switched away
from the gptel buffer. The async callback must remain accessible when the user makes a
selection in the transient context.

Solution: Use transient's :scope mechanism to pass callback as a plist. The scope is
accessible to suffix commands via (transient-scope) and is automatically isolated per
transient invocation. This supports multiple concurrent gptel sessions without interference.

Benefits of :scope approach:
- No global state - each transient has its own isolated scope
- Automatic cleanup when transient exits
- Supports multiple concurrent sessions
- Extensible - can pass additional metadata in the plist

Future enhancements:
- Add C-g cleanup via transient-exit-hook
- Support dynamic options passed from LLM
- Pass additional metadata (session-id, buffer) in scope plist

* Basic Configuration

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src

* Selection Handler

Centralized function to invoke callback from transient scope.

The scope is a plist containing at minimum:
- :callback - The function to call with the user's selection

Future scope fields could include:
- :session-id - Track which gptel session initiated the request
- :buffer - The originating buffer

#+begin_src emacs-lisp
(defun jf/gptel-transient-choice--handle-selection (choice)
  "Handle user selection from transient menu.
CHOICE is the string value to return to the LLM.
Retrieves callback from transient scope and invokes it."
  (let* ((scope (transient-scope))
         (callback (plist-get scope :callback)))
    (when callback
      (funcall callback choice))))
#+end_src

* Transient Suffix Commands

Each option in the menu is a suffix command that calls the selection handler.

#+begin_src emacs-lisp
(transient-define-suffix jf/gptel-transient-choice--select-option-a ()
  "Select option A."
  :transient nil  ; Exit menu after execution
  (interactive)
  (jf/gptel-transient-choice--handle-selection "Option A"))

(transient-define-suffix jf/gptel-transient-choice--select-option-b ()
  "Select option B."
  :transient nil
  (interactive)
  (jf/gptel-transient-choice--handle-selection "Option B"))

(transient-define-suffix jf/gptel-transient-choice--cancel ()
  "Cancel the selection."
  :transient nil
  (interactive)
  (jf/gptel-transient-choice--handle-selection "Cancelled"))
#+end_src

* Transient Menu Definition

The main transient prefix that displays the menu.

#+begin_src emacs-lisp
(transient-define-prefix jf/gptel-transient-choice-menu ()
  "Simple choice menu for gptel tool demonstration."
  ["Choose an option"
   ("a" "Option A" jf/gptel-transient-choice--select-option-a)
   ("b" "Option B" jf/gptel-transient-choice--select-option-b)
   ("q" "Cancel" jf/gptel-transient-choice--cancel)])
#+end_src

* Async Tool Function

The function registered with gptel-make-tool. Takes callback as first parameter
per async tool contract.

#+begin_src emacs-lisp
(defun jf/gptel-transient-choice-tool (callback)
  "Async tool that presents a transient menu for user selection.
CALLBACK is called with the user's choice when they select an option.

This is an async tool - it returns immediately after opening the menu.
The callback will be invoked later when the user makes a selection."
  ;; Pass callback via transient scope (supports multiple concurrent invocations)
  (transient-setup 'jf/gptel-transient-choice-menu nil nil
                   :scope (list :callback callback)))
#+end_src

* Tool Registration

Register the tool with gptel's tool system.

#+begin_src emacs-lisp
(gptel-make-tool
 :name "transient_choice"
 :function #'jf/gptel-transient-choice-tool
 :description "Present a simple menu to the user with two options (A or B). This is an interactive tool that requires user input. Returns the user's selection as a string: 'Option A', 'Option B', or 'Cancelled' if they quit."
 :args nil  ; No arguments for this minimal example
 :category "demo"
 :async t
 :confirm nil)
#+end_src

* Implementation Guide: Async Tools with Transient

This section documents the implementation pattern for async gptel tools that use
transient menus. Understanding these concepts is crucial for building robust
interactive tools.

** Understanding Gptel's Async Tool Pattern

*** The Async Tool Contract

Async tools in gptel follow a specific contract:

1. **Function signature**: Tool function takes =callback= as the FIRST parameter,
   followed by any tool-specific arguments from the LLM.

   #+begin_example
   (defun my-async-tool (callback arg1 arg2)
     ;; callback must be first parameter
     ...)
   #+end_example

2. **Registration**: Tool must be registered with =:async t=

   #+begin_example
   (gptel-make-tool
    :name "my_tool"
    :function #'my-async-tool
    :async t  ; Required for async tools
    ...)
   #+end_example

3. **Return behavior**: Function returns immediately (non-blocking)

4. **Callback invocation**: Tool must call callback exactly once with the result
   when the async operation completes

   #+begin_example
   (funcall callback result-string)
   #+end_example

*** The FSM and Timing

Gptel uses a Finite State Machine (FSM) to coordinate tool execution:

- **INIT** → **WAIT** (waiting for API response)
- **WAIT** → **TYPE** (LLM decides to call tool)
- **TYPE** → **TOOL** (tool executes)
- **TOOL** → **WAIT** (tool callback invoked, result sent back to API)
- Loop continues until conversation completes

For async tools:
- Tool function returns immediately (FSM doesn't wait)
- FSM remains in suspended state until callback is invoked
- Callback invocation resumes the FSM and sends result to LLM

**Critical timing requirement**: Callback MUST be called eventually, or FSM hangs forever.

** The Context Switching Challenge

*** Why Transient Menus Are Problematic

When a transient menu opens:

1. New buffer created: =*transient*=
2. New window displayed (side window)
3. **Focus switches** from gptel buffer to transient buffer
4. User interacts in the transient context
5. Suffix commands execute in transient buffer, not gptel buffer

This creates a challenge: The callback was passed to the tool in the gptel buffer's
context, but the user's selection happens in a completely different buffer context.

*** Failed Approach: Global Variables

Initial approach using global variable:

#+begin_example
(defvar my-callback nil)  ; Global state

(defun my-tool (callback)
  (setq my-callback callback)  ; Store globally
  (my-transient-menu))

(transient-define-suffix my-suffix ()
  (funcall my-callback "result"))  ; Access global
#+end_example

**Problems**:
- Only supports ONE active tool call at a time
- Multiple concurrent gptel sessions interfere with each other
- Second tool call overwrites first callback
- No automatic cleanup on transient exit

** The Scope Solution

*** How Transient Scope Works

Transient provides a =:scope= mechanism specifically for passing data to suffix commands:

1. **Setting scope**: Pass via =transient-setup= call

   #+begin_example
   (transient-setup 'my-menu nil nil :scope data)
   #+end_example

2. **Accessing scope**: Call =(transient-scope)= in suffix commands

   #+begin_example
   (transient-define-suffix my-suffix ()
     (interactive)
     (let ((scope (transient-scope)))
       ;; scope contains the data passed to transient-setup
       ...))
   #+end_example

3. **Isolation**: Each transient invocation has its own isolated scope

4. **Lifetime**: Scope exists for the duration of the transient session

*** Using Plist for Structured Scope

Best practice: Use a plist for scope data instead of raw values:

#+begin_example
;; Good: Structured, extensible
(transient-setup 'my-menu nil nil
                :scope (list :callback callback
                            :session-id id
                            :buffer (current-buffer)))

;; Acceptable: Simple but less extensible
(transient-setup 'my-menu nil nil :scope callback)
#+end_example

Benefits of plist:
- Self-documenting (=:callback= key makes intent clear)
- Extensible (can add fields without breaking existing code)
- Type-safe (can validate plist structure)
- Multiple values (can pass callback AND metadata)

*** Complete Pattern

The full implementation pattern:

#+begin_example
;; 1. Define handler that accesses scope
(defun my-tool--handle-selection (choice)
  (let* ((scope (transient-scope))
         (callback (plist-get scope :callback)))
    (when callback
      (funcall callback choice))))

;; 2. Define suffixes that call handler
(transient-define-suffix my-tool--suffix-a ()
  :transient nil  ; Exit after execution
  (interactive)
  (my-tool--handle-selection "Option A"))

;; 3. Define transient menu
(transient-define-prefix my-tool-menu ()
  ["Choose an option"
   ("a" "Option A" my-tool--suffix-a)])

;; 4. Async tool function passes callback via scope
(defun my-tool (callback)
  (transient-setup 'my-tool-menu nil nil
                   :scope (list :callback callback)))

;; 5. Register with :async t
(gptel-make-tool
 :name "my_tool"
 :function #'my-tool
 :async t
 ...)
#+end_example

** Best Practices

*** Always Use :scope for Callback Storage

- ✅ Supports multiple concurrent sessions
- ✅ No global state
- ✅ Automatic cleanup
- ✅ Leverages transient's design

*** Use Plist for Extensibility

#+begin_example
;; Today: Just callback
:scope (list :callback callback)

;; Tomorrow: Add session tracking without breaking anything
:scope (list :callback callback
            :session-id (gptel-session-id)
            :buffer (current-buffer))
#+end_example

*** Set :transient nil on Suffixes

Suffixes that invoke the callback should exit the menu:

#+begin_example
(transient-define-suffix my-suffix ()
  :transient nil  ; Exit after calling callback
  (interactive)
  (my-handle-selection "result"))
#+end_example

This ensures:
- Menu closes after selection
- User returns to gptel buffer
- Transient state is cleaned up

*** Validate Callback Exists

Always check callback is present before invoking:

#+begin_example
(let* ((scope (transient-scope))
       (callback (plist-get scope :callback)))
  (when callback  ; Guard against nil
    (funcall callback result)))
#+end_example

*** Call Callback Exactly Once

- ✅ One callback invocation per tool call
- ❌ Never call callback multiple times (FSM breaks)
- ❌ Never skip calling callback (FSM hangs)

** Common Pitfalls

*** Forgetting :async t

If you forget =:async t= in registration:
- Gptel expects tool to return result synchronously
- Tool returns nil (before callback is invoked)
- FSM sends nil to LLM
- Your actual callback invocation later does nothing

**Solution**: Always set =:async t= for async tools.

*** Calling Callback Multiple Times

#+begin_example
;; BAD: Callback called multiple times
(transient-define-suffix my-suffix ()
  (interactive)
  (funcall callback "first")
  (funcall callback "second"))  ; FSM error!
#+end_example

**Solution**: Design suffixes to call callback exactly once, then exit.

*** Global Variable for Concurrent Sessions

#+begin_example
;; BAD: Only supports one active call
(defvar my-callback nil)
(setq my-callback callback)  ; Overwrites previous!
#+end_example

**Solution**: Use =:scope= for per-invocation isolation.

*** Not Handling C-g

If user presses =C-g= to cancel:
- Transient exits without calling callback
- FSM hangs waiting for callback
- Gptel buffer becomes unresponsive

**Solution**: Add cleanup via =transient-exit-hook= (future enhancement):

#+begin_example
(defun my-tool--cleanup ()
  (let* ((scope (transient-scope))
         (callback (plist-get scope :callback)))
    (when callback
      (funcall callback "Cancelled by user"))))

(add-hook 'transient-exit-hook #'my-tool--cleanup)
#+end_example

*** Buffer Context Assumptions

Don't assume you're in the gptel buffer when suffix executes:

#+begin_example
;; BAD: May not be in gptel buffer
(transient-define-suffix my-suffix ()
  (interactive)
  (insert "text")  ; Inserts in *transient* buffer!
  ...)
#+end_example

**Solution**: Pass buffer in scope if you need to access it:

#+begin_example
;; Tool function
(transient-setup 'my-menu nil nil
                :scope (list :callback callback
                            :buffer (current-buffer)))

;; Suffix
(transient-define-suffix my-suffix ()
  (interactive)
  (let* ((scope (transient-scope))
         (buffer (plist-get scope :buffer)))
    (with-current-buffer buffer
      (insert "text"))))  ; Now inserts in correct buffer
#+end_example

** Performance Considerations

*** Transient Startup Time

Opening a transient menu is fast (<10ms), but not instant. For simple yes/no
questions, consider if transient is the right UI:

- ✅ Complex choices with multiple options
- ✅ Choices that benefit from visual menu
- ✅ Choices where user needs to see options
- ❌ Simple yes/no (use =y-or-n-p= in callback)
- ❌ Text input (use =read-string= in callback)

*** Memory Cleanup

Scope is automatically garbage collected when transient exits. No manual cleanup
needed for scope data.

If your tool allocates large resources (buffers, temp files), clean them up in
the callback or via =transient-exit-hook=.

** Testing Concurrent Sessions

To verify your implementation supports concurrent sessions:

1. Open two gptel buffers (different sessions)
2. In buffer 1: Ask LLM to call your tool
3. In buffer 2: Ask LLM to call your tool (before responding to #2)
4. Verify two transient menus are open simultaneously
5. Respond to menu in buffer 2
6. Respond to menu in buffer 1
7. Verify each callback went to the correct session

If callbacks get mixed up, you're using global state incorrectly.

* Known Limitations

** No C-g Cleanup

If the user cancels the transient with C-g without selecting an option, the callback
is never called and the FSM may hang. This can be fixed by adding a cleanup function
via transient-exit-hook (enhancement for production use).

** Static Options

Menu options are hardcoded. Future iterations should accept options as arguments
from the LLM to make this a practical tool.

* Testing

To test this tool:

1. Enable tools in gptel:
   #+begin_example
   (setq gptel-use-tools t)
   (setq gptel-tools '("transient_choice"))
   #+end_example

2. Ask the LLM to use it:
   #+begin_example
   "Please use the transient_choice tool to ask me which option I prefer."
   #+end_example

3. Expected behavior:
   - LLM calls the tool
   - Transient menu opens with options
   - User presses 'a', 'b', or 'q'
   - Menu closes
   - Result is sent to LLM
   - LLM responds incorporating the choice

* V2: Dynamic Question System

** Introduction to V2

V2 extends the proof-of-concept to accept structured questions from the LLM via JSON,
dynamically build transient menus, and return structured answers.

Key enhancements:
- JSON input format for questions (LLM provides structured data)
- Schema validation with clear error messages
- Dynamic suffix generation based on question data
- Support for multiple question types (choice, text)
- Structured JSON output format for answers
- Proper error handling (invalid JSON, cancellation, etc.)

** Phase 1: JSON Validation

*** Validation Function

This function performs three tiers of validation:
1. JSON parsing (syntax validation)
2. Schema validation (structure and types)
3. Semantic validation (constraints and uniqueness)

Returns (success-p . error-message-or-data).

#+begin_src emacs-lisp
(defun jf/gptel-validate-questions-json (json-string)
  "Validate JSON string for question format.
Returns cons cell: (success-p . error-message-or-data)
On success: (t . parsed-plist)
On failure: (nil . \"Error: description\")"
  (condition-case err
      ;; Tier 1: JSON parsing
      (let ((data (json-parse-string json-string :object-type 'plist :array-type 'list)))
        ;; Tier 2: Schema validation
        (let ((schema-result (jf/gptel-validate-questions-schema data)))
          (if (car schema-result)
              ;; Tier 3: Semantic validation
              (let ((semantic-result (jf/gptel-validate-questions-semantics data)))
                (if (car semantic-result)
                    (cons t data)  ; All validation passed
                  semantic-result))
            schema-result)))
    (json-parse-error
     (cons nil (format "Invalid JSON syntax: %s at position %d"
                       (error-message-string err)
                       (if (> (length err) 2) (nth 2 err) 0))))
    (error
     (cons nil (format "Validation error: %s" (error-message-string err))))))
#+end_src

*** Schema Validator

Validates the structure and types of the JSON data.

#+begin_src emacs-lisp
(defun jf/gptel-validate-questions-schema (data)
  "Validate schema structure and types.
Returns (success-p . error-message)."
  (cond
   ;; Check root structure
   ((not (plistp data))
    (cons nil "Root must be an object"))

   ;; Check questions field exists
   ((not (plist-member data :questions))
    (cons nil "Missing required field: questions"))

   ;; Check questions is an array
   ((not (listp (plist-get data :questions)))
    (cons nil "Field 'questions' must be an array"))

   ;; Check questions count (1-4)
   ((let ((count (length (plist-get data :questions))))
      (or (< count 1) (> count 4)))
    (cons nil (format "Must have 1-4 questions, got %d"
                      (length (plist-get data :questions)))))

   ;; Validate each question
   (t
    (let ((questions (plist-get data :questions))
          (idx 0))
      (catch 'validation-error
        (dolist (q questions)
          (let ((result (jf/gptel-validate-question-schema q idx)))
            (unless (car result)
              (throw 'validation-error result)))
          (setq idx (1+ idx)))
        (cons t "Schema valid"))))))
#+end_src

*** Question Validator

Validates individual question objects.

#+begin_src emacs-lisp
(defun jf/gptel-validate-question-schema (question idx)
  "Validate a single question's schema.
QUESTION is the question plist, IDX is its index in the array.
Returns (success-p . error-message)."
  (let ((prefix (format "Question[%d]: " idx)))
    (cond
     ;; Check question is object
     ((not (plistp question))
      (cons nil (concat prefix "Must be an object")))

     ;; Check required fields
     ((not (plist-member question :id))
      (cons nil (concat prefix "Missing required field: id")))
     ((not (plist-member question :header))
      (cons nil (concat prefix "Missing required field: header")))
     ((not (plist-member question :question))
      (cons nil (concat prefix "Missing required field: question")))
     ((not (plist-member question :type))
      (cons nil (concat prefix "Missing required field: type")))

     ;; Check field types
     ((not (stringp (plist-get question :id)))
      (cons nil (concat prefix "Field 'id' must be a string")))
     ((not (stringp (plist-get question :header)))
      (cons nil (concat prefix "Field 'header' must be a string")))
     ((not (stringp (plist-get question :question)))
      (cons nil (concat prefix "Field 'question' must be a string")))
     ((not (stringp (plist-get question :type)))
      (cons nil (concat prefix "Field 'type' must be a string")))

     ;; Check type value
     ((not (member (plist-get question :type) '("choice" "text")))
      (cons nil (concat prefix (format "Field 'type' must be 'choice' or 'text', got '%s'"
                                       (plist-get question :type)))))

     ;; Validate choice-specific fields
     ((string= (plist-get question :type) "choice")
      (jf/gptel-validate-choice-question question prefix))

     ;; Validate text-specific fields
     ((string= (plist-get question :type) "text")
      (jf/gptel-validate-text-question question prefix))

     (t (cons t "Valid")))))
#+end_src

*** Choice Question Validator

#+begin_src emacs-lisp
(defun jf/gptel-validate-choice-question (question prefix)
  "Validate choice question specific fields.
Returns (success-p . error-message)."
  (cond
   ;; Check options field exists
   ((not (plist-member question :options))
    (cons nil (concat prefix "Choice question missing required field: options")))

   ;; Check options is array
   ((not (listp (plist-get question :options)))
    (cons nil (concat prefix "Field 'options' must be an array")))

   ;; Check options count (2-4)
   ((let ((count (length (plist-get question :options))))
      (or (< count 2) (> count 4)))
    (cons nil (concat prefix (format "Choice question must have 2-4 options, got %d"
                                     (length (plist-get question :options))))))

   ;; Validate each option
   (t
    (let ((options (plist-get question :options))
          (opt-idx 0))
      (catch 'option-error
        (dolist (opt options)
          (let ((result (jf/gptel-validate-option-schema opt prefix opt-idx)))
            (unless (car result)
              (throw 'option-error result)))
          (setq opt-idx (1+ opt-idx)))
        (cons t "Valid"))))))
#+end_src

*** Option Validator

#+begin_src emacs-lisp
(defun jf/gptel-validate-option-schema (option prefix idx)
  "Validate a single option's schema.
Returns (success-p . error-message)."
  (let ((opt-prefix (concat prefix (format "Option[%d]: " idx))))
    (cond
     ;; Check option is object
     ((not (plistp option))
      (cons nil (concat opt-prefix "Must be an object")))

     ;; Check required fields
     ((not (plist-member option :key))
      (cons nil (concat opt-prefix "Missing required field: key")))
     ((not (plist-member option :label))
      (cons nil (concat opt-prefix "Missing required field: label")))
     ((not (plist-member option :description))
      (cons nil (concat opt-prefix "Missing required field: description")))

     ;; Check field types
     ((not (stringp (plist-get option :key)))
      (cons nil (concat opt-prefix "Field 'key' must be a string")))
     ((not (stringp (plist-get option :label)))
      (cons nil (concat opt-prefix "Field 'label' must be a string")))
     ((not (stringp (plist-get option :description)))
      (cons nil (concat opt-prefix "Field 'description' must be a string")))

     (t (cons t "Valid")))))
#+end_src

*** Text Question Validator

#+begin_src emacs-lisp
(defun jf/gptel-validate-text-question (question prefix)
  "Validate text question specific fields.
Returns (success-p . error-message)."
  (cond
   ;; Check prompt field (optional but must be string if present)
   ((and (plist-member question :prompt)
         (not (stringp (plist-get question :prompt))))
    (cons nil (concat prefix "Field 'prompt' must be a string if present")))

   ;; Check default field (optional but must be string if present)
   ((and (plist-member question :default)
         (not (stringp (plist-get question :default))))
    (cons nil (concat prefix "Field 'default' must be a string if present")))

   (t (cons t "Valid"))))
#+end_src

*** Semantic Validator

Validates semantic constraints (uniqueness, lengths, etc.).

#+begin_src emacs-lisp
(defun jf/gptel-validate-questions-semantics (data)
  "Validate semantic constraints.
Returns (success-p . error-message)."
  (let ((questions (plist-get data :questions))
        (seen-ids '()))
    (catch 'semantic-error
      ;; Check for duplicate question IDs
      (let ((idx 0))
        (dolist (q questions)
          (let ((id (plist-get q :id)))
            (when (member id seen-ids)
              (throw 'semantic-error
                     (cons nil (format "Question[%d]: Duplicate question ID '%s'" idx id))))
            (push id seen-ids))

          ;; Check header length (max 12 chars)
          (let ((header (plist-get q :header)))
            (when (> (length header) 12)
              (throw 'semantic-error
                     (cons nil (format "Question[%d]: Header too long (max 12 chars): '%s'"
                                       idx header)))))

          ;; Validate choice question keys
          (when (string= (plist-get q :type) "choice")
            (let ((result (jf/gptel-validate-choice-keys q idx)))
              (unless (car result)
                (throw 'semantic-error result))))

          (setq idx (1+ idx))))

      (cons t "Semantics valid"))))
#+end_src

*** Choice Keys Validator

Validates option keys are single chars and unique within question.

#+begin_src emacs-lisp
(defun jf/gptel-validate-choice-keys (question idx)
  "Validate option keys in a choice question.
Returns (success-p . error-message)."
  (let ((options (plist-get question :options))
        (seen-keys '())
        (opt-idx 0)
        (prefix (format "Question[%d]: " idx)))
    (catch 'key-error
      (dolist (opt options)
        (let ((key (plist-get opt :key)))
          ;; Check key is single character
          (unless (= (length key) 1)
            (throw 'key-error
                   (cons nil (concat prefix
                                     (format "Option[%d]: Key must be single character, got '%s'"
                                             opt-idx key)))))

          ;; Check for duplicate keys
          (when (member key seen-keys)
            (throw 'key-error
                   (cons nil (concat prefix
                                     (format "Option[%d]: Duplicate key '%s'"
                                             opt-idx key)))))

          (push key seen-keys))
        (setq opt-idx (1+ opt-idx)))

      (cons t "Keys valid"))))
#+end_src

** Testing Phase 1

Test cases to validate the JSON validator works correctly.

*** Valid JSON Test Cases

#+begin_example
;; Test 1: Valid single choice question
{
  "questions": [{
    "id": "q1",
    "header": "Auth",
    "question": "Which auth method?",
    "type": "choice",
    "options": [
      {"key": "a", "label": "OAuth", "description": "OAuth 2.0"},
      {"key": "b", "label": "JWT", "description": "JSON Web Tokens"}
    ]
  }]
}

;; Test 2: Valid text question
{
  "questions": [{
    "id": "q1",
    "header": "Library",
    "question": "Preferred library?",
    "type": "text",
    "prompt": "Library name: ",
    "default": "react"
  }]
}

;; Test 3: Multiple questions
{
  "questions": [
    {
      "id": "q1",
      "header": "Auth",
      "question": "Auth method?",
      "type": "choice",
      "options": [
        {"key": "a", "label": "OAuth", "description": "OAuth 2.0"},
        {"key": "b", "label": "JWT", "description": "JSON Web Tokens"}
      ]
    },
    {
      "id": "q2",
      "header": "Database",
      "question": "Database type?",
      "type": "choice",
      "options": [
        {"key": "a", "label": "PostgreSQL", "description": "Relational"},
        {"key": "b", "label": "MongoDB", "description": "Document"}
      ]
    }
  ]
}
#+end_example

*** Invalid JSON Test Cases

#+begin_example
;; Test 4: Invalid JSON syntax
{questions: []}  ; Missing quotes

;; Test 5: Missing required field
{"questions": [{"id": "q1", "type": "choice"}]}  ; Missing header, question, options

;; Test 6: Wrong type for field
{"questions": [{"id": 123, "header": "Test", "question": "Q?", "type": "choice"}]}  ; id is number

;; Test 7: Too many questions
{"questions": [{...}, {...}, {...}, {...}, {...}]}  ; 5 questions (max is 4)

;; Test 8: Too few options
{"questions": [{"id": "q1", "header": "Test", "question": "Q?", "type": "choice",
                "options": [{"key": "a", "label": "A", "description": "Desc"}]}]}  ; 1 option (min is 2)

;; Test 9: Duplicate question IDs
{"questions": [
  {"id": "q1", "header": "Test1", "question": "Q1?", "type": "text"},
  {"id": "q1", "header": "Test2", "question": "Q2?", "type": "text"}
]}

;; Test 10: Duplicate option keys
{"questions": [{"id": "q1", "header": "Test", "question": "Q?", "type": "choice",
                "options": [
                  {"key": "a", "label": "A", "description": "First"},
                  {"key": "a", "label": "B", "description": "Second"}
                ]}]}

;; Test 11: Multi-character key
{"questions": [{"id": "q1", "header": "Test", "question": "Q?", "type": "choice",
                "options": [
                  {"key": "ab", "label": "A", "description": "Desc"},
                  {"key": "c", "label": "C", "description": "Desc"}
                ]}]}

;; Test 12: Header too long
{"questions": [{"id": "q1", "header": "ThisHeaderIsTooLong", "question": "Q?", "type": "text"}]}
#+end_example

** Phase 2: Single Choice Question (MVP)

Goal: Get one question working end-to-end with dynamic menu generation.

*** State Management

Buffer-local variable to track user answers during the question flow.

#+begin_src emacs-lisp
(defvar-local jf/gptel-ask--answers nil
  "Alist of answers during question flow.
Each entry is (question-id question-text answer key).")

(defun jf/gptel-ask--record-answer (question-id question-text answer key)
  "Record user's answer for QUESTION-ID.
QUESTION-TEXT is the full question, ANSWER is the user's response,
KEY is the option key (for choice questions, nil for text)."
  (setq jf/gptel-ask--answers
        (cons (list question-id question-text answer key)
              (assoc-delete-all question-id jf/gptel-ask--answers))))

(defun jf/gptel-ask--all-answered-p (questions)
  "Check if all QUESTIONS have been answered."
  (= (length jf/gptel-ask--answers)
     (length questions)))

(defun jf/gptel-ask--clear-answers ()
  "Clear all recorded answers."
  (setq jf/gptel-ask--answers nil))

(defun jf/gptel-ask--current-question-index (questions)
  "Get index of current unanswered question.
Returns 0-based index, or nil if all answered."
  (let ((answered-ids (mapcar #'car jf/gptel-ask--answers)))
    (cl-position-if
     (lambda (q)
       (not (member (plist-get q :id) answered-ids)))
     questions)))
#+end_src

*** Suffix Generation

Build transient suffix specifications from question data.

#+begin_src emacs-lisp
(defun jf/gptel-ask--build-suffixes (questions callback)
  "Build suffix list for current unanswered question in QUESTIONS.
CALLBACK is the async callback to invoke when complete.
Phase 3: Finds current unanswered question and builds suffixes for it."
  (let* ((current-idx (jf/gptel-ask--current-question-index questions))
         (question (when current-idx (nth current-idx questions))))
    (if question
        (if (string= (plist-get question :type) "choice")
            (jf/gptel-ask--build-choice-suffixes question callback)
          (error "Text questions not yet implemented (Phase 4)"))
      ;; No unanswered questions - shouldn't happen
      (error "No unanswered questions found"))))

(defun jf/gptel-ask--build-choice-suffixes (question callback)
  "Build suffix specs for a choice QUESTION.
Returns list of transient suffix specifications."
  (let ((options (plist-get question :options))
        (question-id (plist-get question :id))
        (question-text (plist-get question :question)))
    (mapcar
     (lambda (option)
       (let ((key (plist-get option :key))
             (label (plist-get option :label))
             (description (plist-get option :description)))
         ;; Build suffix spec: (key label command :description desc)
         (list key
               label
               (jf/gptel-ask--make-choice-handler
                question-id question-text option callback)
               :description description)))
     options)))
#+end_src

*** Handler Functions

Create suffix command closures that record answers and invoke callbacks.

#+begin_src emacs-lisp
(defun jf/gptel-ask--make-choice-handler (question-id question-text option callback)
  "Create suffix command for a choice option.
QUESTION-ID identifies the question, QUESTION-TEXT is the full question,
OPTION is the option plist, CALLBACK is the async callback."
  (lambda ()
    (interactive)
    (let ((answer (plist-get option :label))
          (key (plist-get option :key)))
      ;; Record answer
      (jf/gptel-ask--record-answer question-id question-text answer key)

      ;; Check if more questions remain
      (let* ((scope (transient-scope))
             (questions (plist-get scope :questions)))
        (if (jf/gptel-ask--all-answered-p questions)
            ;; All answered - finish and invoke callback
            (jf/gptel-ask--finish questions callback)
          ;; More questions remain - re-setup transient for next question
          ;; Pass same scope to preserve questions and callback
          (transient-setup 'jf/gptel-ask-menu nil nil :scope scope))))))
#+end_src

*** Result Building

Build JSON result from collected answers and invoke callback.

#+begin_src emacs-lisp
(defun jf/gptel-ask--finish (questions callback)
  "Build result JSON and invoke CALLBACK.
QUESTIONS is the list of question plists."
  (let ((result (jf/gptel-ask--build-result-json questions jf/gptel-ask--answers)))
    ;; Clean up
    (jf/gptel-ask--clear-answers)
    ;; Exit transient
    (transient-quit-one)
    ;; Invoke callback with JSON result
    (funcall callback result)))

(defun jf/gptel-ask--build-result-json (questions answers)
  "Build JSON result from ANSWERS.
QUESTIONS is the list of question plists for context.
Returns JSON string."
  (let ((answer-list
         (mapcar
          (lambda (q)
            (let* ((q-id (plist-get q :id))
                   (answer-data (assoc q-id answers))
                   (q-text (nth 1 answer-data))
                   (answer (nth 2 answer-data))
                   (key (nth 3 answer-data)))
              (if key
                  ;; Choice question (has key)
                  (list :id q-id
                        :question q-text
                        :answer answer
                        :key key)
                ;; Text question (no key)
                (list :id q-id
                      :question q-text
                      :answer answer))))
          questions)))
    (json-serialize
     (list :status "completed"
           :answers (vconcat answer-list)))))
#+end_src

*** Dynamic Transient Menu

The main transient prefix with dynamic suffix generation.

#+begin_src emacs-lisp
(transient-define-prefix jf/gptel-ask-menu ()
  "Dynamic question menu for gptel tool."
  [:description
   (lambda ()
     (let* ((scope (transient-scope))
            (questions (plist-get scope :questions))
            (current-idx (jf/gptel-ask--current-question-index questions))
            (question (when current-idx (nth current-idx questions)))
            (total (length questions))
            (progress (1+ current-idx)))
       ;; Format: "Question 1/3: What is your choice?"
       (format "Question %d/%d: %s"
               progress total (plist-get question :question))))
   [:class transient-column
    :setup-children
    (lambda (_)
      (let* ((scope (transient-scope))
             (questions (plist-get scope :questions))
             (callback (plist-get scope :callback)))
        (transient-parse-suffixes
         'jf/gptel-ask-menu
         (jf/gptel-ask--build-suffixes questions callback))))]])
#+end_src

*** Async Tool Function

The tool function that validates JSON and opens the transient menu.

#+begin_src emacs-lisp
(defun jf/gptel-ask-user-questions (callback questions-json)
  "Async tool to ask user structured questions via transient menu.
CALLBACK is the async callback (called with JSON result).
QUESTIONS-JSON is the JSON string describing the questions."
  ;; Validate JSON
  (let ((validation (jf/gptel-validate-questions-json questions-json)))
    (if (car validation)
        ;; Validation passed - open menu
        (let ((data (cdr validation))
              (questions (plist-get (cdr validation) :questions)))
          ;; Clear any previous answers
          (jf/gptel-ask--clear-answers)
          ;; Open transient with questions and callback in scope
          (transient-setup 'jf/gptel-ask-menu nil nil
                           :scope (list :questions questions
                                        :callback callback)))
      ;; Validation failed - return error
      (funcall callback (cdr validation)))))
#+end_src

*** Tool Registration

Register the new dynamic question tool with gptel.

#+begin_src emacs-lisp
(gptel-make-tool
 :name "ask_user_questions"
 :function #'jf/gptel-ask-user-questions
 :description "Ask the user structured questions via an interactive menu.

This tool presents questions to the user through a visual menu interface.
The user can select from predefined options or provide text input.

Input: JSON string with the following structure:
{
  \"questions\": [
    {
      \"id\": \"unique_id\",
      \"header\": \"Short Label\",
      \"question\": \"Full question text?\",
      \"type\": \"choice\" | \"text\",
      \"options\": [{\"key\": \"a\", \"label\": \"Option A\", \"description\": \"What this means\"}],
      \"prompt\": \"Text prompt: \" (for text type),
      \"default\": \"default value\" (for text type)
    }
  ]
}

Returns: JSON string with answers:
{
  \"status\": \"completed\" | \"cancelled\",
  \"answers\": [
    {\"id\": \"q1\", \"question\": \"...\", \"answer\": \"...\", \"key\": \"a\"}
  ]
}

Constraints:
- 1-4 questions max (fully supported)
- 2-4 options per choice question
- Single character keys
- Headers max 12 characters

Implementation status:
- Phase 3: Multiple choice questions (sequential) - COMPLETE
- Phase 4: Text input questions - COMING SOON
- Phase 5: Error handling (C-g cancellation) - COMING SOON"
 :args (list '(:name "questions_json"
               :type string
               :description "JSON string containing the questions to ask"))
 :category "interaction"
 :async t
 :confirm nil)
#+end_src

** Phase 3: Multiple Choice Questions (Sequential)

Goal: Support 2-4 questions presented sequentially.

Phase 3 extends Phase 2 by:
- Finding current unanswered question dynamically
- Re-displaying transient after each answer (except last)
- Showing progress indicator ("Question 2/3")
- Only invoking callback when all questions answered

Key changes from Phase 2:
1. Added `jf/gptel-ask--current-question-index` to track progress
2. Modified handler to re-setup transient instead of exiting (unless all answered)
3. Updated description to show "Question N/M: question text"
4. Suffix generation now finds current question instead of using first

*** Testing Phase 3

Test JSON with multiple questions:

#+begin_example
{
  "questions": [
    {
      "id": "q1",
      "header": "Auth",
      "question": "Authentication method?",
      "type": "choice",
      "options": [
        {"key": "a", "label": "OAuth", "description": "OAuth 2.0"},
        {"key": "b", "label": "JWT", "description": "JSON Web Tokens"}
      ]
    },
    {
      "id": "q2",
      "header": "Database",
      "question": "Database type?",
      "type": "choice",
      "options": [
        {"key": "a", "label": "PostgreSQL", "description": "Relational"},
        {"key": "b", "label": "MongoDB", "description": "Document store"}
      ]
    }
  ]
}
#+end_example

Expected behavior:
1. First question displays: "Question 1/2: Authentication method?"
2. User selects an option (e.g., 'a' for OAuth)
3. Second question displays: "Question 2/2: Database type?"
4. User selects an option (e.g., 'a' for PostgreSQL)
5. Menu closes, result JSON returned with both answers
6. LLM receives: `{"status":"completed","answers":[{...},{...}]}`

* Provide Statement

#+begin_src emacs-lisp
(provide 'transient-tools)
;;; transient-tools.el ends here
#+end_src
