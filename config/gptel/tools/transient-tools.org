#+title: GPTEL Transient Tools
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle transient-tools.el
#+auto_tangle: y

* Introduction

This module implements an async gptel tool that allows LLMs to ask users structured
questions through dynamically-generated transient menus.

Key features:
- LLM provides questions in JSON format
- Tool validates JSON and builds transient menu dynamically
- User interacts with visual menu (choice selections or text input)
- Structured answers returned to LLM in JSON format
- Support for 1-4 questions presented sequentially
- C-g cancellation handling

* Architecture: Integrating Transient Menus with Gptel's Async Tool System

This section documents the patterns for building async gptel tools that use transient
menus for user interaction. These patterns are valuable for anyone building similar tools.

** Understanding Gptel's Async Tool Pattern

*** The Async Tool Contract

Async tools in gptel follow a specific contract:

1. **Function signature**: Tool function takes =callback= as the FIRST parameter,
   followed by any tool-specific arguments from the LLM.

   #+begin_example
   (defun my-async-tool (callback arg1 arg2)
     ;; callback must be first parameter
     ...)
   #+end_example

2. **Registration**: Tool must be registered with =:async t=

   #+begin_example
   (gptel-make-tool
    :name "my_tool"
    :function #'my-async-tool
    :async t  ; Required for async tools
    ...)
   #+end_example

3. **Return behavior**: Function returns immediately (non-blocking)

4. **Callback invocation**: Tool must call callback exactly once with the result
   when the async operation completes

   #+begin_example
   (funcall callback result-string)
   #+end_example

*** The FSM and Timing

Gptel uses a Finite State Machine (FSM) to coordinate tool execution:

- **INIT** → **WAIT** (waiting for API response)
- **WAIT** → **TYPE** (LLM decides to call tool)
- **TYPE** → **TOOL** (tool executes)
- **TOOL** → **WAIT** (tool callback invoked, result sent back to API)
- Loop continues until conversation completes

For async tools:
- Tool function returns immediately (FSM doesn't wait)
- FSM remains in suspended state until callback is invoked
- Callback invocation resumes the FSM and sends result to LLM

**Critical timing requirement**: Callback MUST be called eventually, or FSM hangs forever.

** The Context Switching Challenge

*** Why Transient Menus Are Problematic

When a transient menu opens:

1. New buffer created: =*transient*=
2. New window displayed (side window)
3. **Focus switches** from gptel buffer to transient buffer
4. User interacts in the transient context
5. Suffix commands execute in transient buffer, not gptel buffer

This creates a challenge: The callback was passed to the tool in the gptel buffer's
context, but the user's selection happens in a completely different buffer context.

** The Scope Solution

*** How Transient Scope Works

Transient provides a =:scope= mechanism specifically for passing data to suffix commands:

1. **Setting scope**: Pass via =transient-setup= call

   #+begin_example
   (transient-setup 'my-menu nil nil :scope data)
   #+end_example

2. **Accessing scope**: Call =(transient-scope)= in suffix commands

   #+begin_example
   (transient-define-suffix my-suffix ()
     (interactive)
     (let ((scope (transient-scope)))
       ;; scope contains the data passed to transient-setup
       ...))
   #+end_example

3. **Isolation**: Each transient invocation has its own isolated scope

4. **Lifetime**: Scope exists for the duration of the transient session

*** Using Plist for Structured Scope

Best practice: Use a plist for scope data instead of raw values:

#+begin_example
;; Good: Structured, extensible
(transient-setup 'my-menu nil nil
                :scope (list :callback callback
                            :session-id id
                            :buffer (current-buffer)))

;; Acceptable: Simple but less extensible
(transient-setup 'my-menu nil nil :scope callback)
#+end_example

Benefits of plist:
- Self-documenting (=:callback= key makes intent clear)
- Extensible (can add fields without breaking existing code)
- Type-safe (can validate plist structure)
- Multiple values (can pass callback AND metadata)

*** Complete Pattern

The full implementation pattern:

#+begin_example
;; 1. Define handler that accesses scope
(defun my-tool--handle-selection (choice)
  (let* ((scope (transient-scope))
         (callback (plist-get scope :callback)))
    (when callback
      (funcall callback choice))))

;; 2. Define suffixes that call handler
(transient-define-suffix my-tool--suffix-a ()
  :transient nil  ; Exit after execution
  (interactive)
  (my-tool--handle-selection "Option A"))

;; 3. Define transient menu
(transient-define-prefix my-tool-menu ()
  ["Choose an option"
   ("a" "Option A" my-tool--suffix-a)])

;; 4. Async tool function passes callback via scope
(defun my-tool (callback)
  (transient-setup 'my-tool-menu nil nil
                   :scope (list :callback callback)))

;; 5. Register with :async t
(gptel-make-tool
 :name "my_tool"
 :function #'my-tool
 :async t
 ...)
#+end_example

** Best Practices

*** Always Use :scope for Callback Storage

- ✅ Supports multiple concurrent sessions
- ✅ No global state
- ✅ Automatic cleanup
- ✅ Leverages transient's design

*** Use Plist for Extensibility

#+begin_example
;; Today: Just callback
:scope (list :callback callback)

;; Tomorrow: Add session tracking without breaking anything
:scope (list :callback callback
            :session-id (gptel-session-id)
            :buffer (current-buffer))
#+end_example

*** Set :transient nil on Suffixes

Suffixes that invoke the callback should exit the menu:

#+begin_example
(transient-define-suffix my-suffix ()
  :transient nil  ; Exit after calling callback
  (interactive)
  (my-handle-selection "result"))
#+end_example

This ensures:
- Menu closes after selection
- User returns to gptel buffer
- Transient state is cleaned up

*** Validate Callback Exists

Always check callback is present before invoking:

#+begin_example
(let* ((scope (transient-scope))
       (callback (plist-get scope :callback)))
  (when callback  ; Guard against nil
    (funcall callback result)))
#+end_example

*** Call Callback Exactly Once

- ✅ One callback invocation per tool call
- ❌ Never call callback multiple times (FSM breaks)
- ❌ Never skip calling callback (FSM hangs)

** Common Pitfalls

*** Forgetting :async t

If you forget =:async t= in registration:
- Gptel expects tool to return result synchronously
- Tool returns nil (before callback is invoked)
- FSM sends nil to LLM
- Your actual callback invocation later does nothing

**Solution**: Always set =:async t= for async tools.

*** Calling Callback Multiple Times

#+begin_example
;; BAD: Callback called multiple times
(transient-define-suffix my-suffix ()
  (interactive)
  (funcall callback "first")
  (funcall callback "second"))  ; FSM error!
#+end_example

**Solution**: Design suffixes to call callback exactly once, then exit.

*** Not Handling C-g

If user presses =C-g= to cancel:
- Transient exits without calling callback
- FSM hangs waiting for callback
- Gptel buffer becomes unresponsive

**Solution**: Add cleanup via =transient-exit-hook= (see implementation below).

*** Buffer Context Assumptions

Don't assume you're in the gptel buffer when suffix executes:

#+begin_example
;; BAD: May not be in gptel buffer
(transient-define-suffix my-suffix ()
  (interactive)
  (insert "text")  ; Inserts in *transient* buffer!
  ...)
#+end_example

**Solution**: Pass buffer in scope if you need to access it:

#+begin_example
;; Tool function
(transient-setup 'my-menu nil nil
                :scope (list :callback callback
                            :buffer (current-buffer)))

;; Suffix
(transient-define-suffix my-suffix ()
  (interactive)
  (let* ((scope (transient-scope))
         (buffer (plist-get scope :buffer)))
    (with-current-buffer buffer
      (insert "text"))))  ; Now inserts in correct buffer
#+end_example

* Implementation

** Basic Configuration

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src

** JSON Validation

Three-tier validation: JSON parsing, schema validation, semantic validation.

#+begin_src emacs-lisp
(defun jf/gptel-validate-questions-json (json-string)
  "Validate JSON string for question format.
Returns cons cell: (success-p . error-message-or-data)
On success: (t . parsed-plist)
On failure: (nil . \"Error: description\")"
  (condition-case err
      ;; Tier 1: JSON parsing
      (let ((data (json-parse-string json-string :object-type 'plist :array-type 'list)))
        ;; Tier 2: Schema validation
        (let ((schema-result (jf/gptel-validate-questions-schema data)))
          (if (car schema-result)
              ;; Tier 3: Semantic validation
              (let ((semantic-result (jf/gptel-validate-questions-semantics data)))
                (if (car semantic-result)
                    (cons t data)  ; All validation passed
                  semantic-result))
            schema-result)))
    (json-parse-error
     (cons nil (format "Invalid JSON syntax: %s at position %d"
                       (error-message-string err)
                       (if (> (length err) 2) (nth 2 err) 0))))
    (error
     (cons nil (format "Validation error: %s" (error-message-string err))))))

(defun jf/gptel-validate-questions-schema (data)
  "Validate schema structure and types.
Returns (success-p . error-message)."
  (cond
   ;; Check root structure
   ((not (plistp data))
    (cons nil "Root must be an object"))

   ;; Check questions field exists
   ((not (plist-member data :questions))
    (cons nil "Missing required field: questions"))

   ;; Check questions is an array
   ((not (listp (plist-get data :questions)))
    (cons nil "Field 'questions' must be an array"))

   ;; Check questions count (1-4)
   ((let ((count (length (plist-get data :questions))))
      (or (< count 1) (> count 4)))
    (cons nil (format "Must have 1-4 questions, got %d"
                      (length (plist-get data :questions)))))

   ;; Validate each question
   (t
    (let ((questions (plist-get data :questions))
          (idx 0))
      (catch 'validation-error
        (dolist (q questions)
          (let ((result (jf/gptel-validate-question-schema q idx)))
            (unless (car result)
              (throw 'validation-error result)))
          (setq idx (1+ idx)))
        (cons t "Schema valid"))))))

(defun jf/gptel-validate-question-schema (question idx)
  "Validate a single question's schema.
QUESTION is the question plist, IDX is its index in the array.
Returns (success-p . error-message)."
  (let ((prefix (format "Question[%d]: " idx)))
    (cond
     ;; Check question is object
     ((not (plistp question))
      (cons nil (concat prefix "Must be an object")))

     ;; Check required fields
     ((not (plist-member question :id))
      (cons nil (concat prefix "Missing required field: id")))
     ((not (plist-member question :header))
      (cons nil (concat prefix "Missing required field: header")))
     ((not (plist-member question :question))
      (cons nil (concat prefix "Missing required field: question")))
     ((not (plist-member question :type))
      (cons nil (concat prefix "Missing required field: type")))

     ;; Check field types
     ((not (stringp (plist-get question :id)))
      (cons nil (concat prefix "Field 'id' must be a string")))
     ((not (stringp (plist-get question :header)))
      (cons nil (concat prefix "Field 'header' must be a string")))
     ((not (stringp (plist-get question :question)))
      (cons nil (concat prefix "Field 'question' must be a string")))
     ((not (stringp (plist-get question :type)))
      (cons nil (concat prefix "Field 'type' must be a string")))

     ;; Check type value
     ((not (member (plist-get question :type) '("choice" "text")))
      (cons nil (concat prefix (format "Field 'type' must be 'choice' or 'text', got '%s'"
                                       (plist-get question :type)))))

     ;; Validate choice-specific fields
     ((string= (plist-get question :type) "choice")
      (jf/gptel-validate-choice-question question prefix))

     ;; Validate text-specific fields
     ((string= (plist-get question :type) "text")
      (jf/gptel-validate-text-question question prefix))

     (t (cons t "Valid")))))

(defun jf/gptel-validate-choice-question (question prefix)
  "Validate choice question specific fields.
Returns (success-p . error-message)."
  (cond
   ;; Check options field exists
   ((not (plist-member question :options))
    (cons nil (concat prefix "Choice question missing required field: options")))

   ;; Check options is array
   ((not (listp (plist-get question :options)))
    (cons nil (concat prefix "Field 'options' must be an array")))

   ;; Check options count (2-4)
   ((let ((count (length (plist-get question :options))))
      (or (< count 2) (> count 4)))
    (cons nil (concat prefix (format "Choice question must have 2-4 options, got %d"
                                     (length (plist-get question :options))))))

   ;; Validate each option
   (t
    (let ((options (plist-get question :options))
          (opt-idx 0))
      (catch 'option-error
        (dolist (opt options)
          (let ((result (jf/gptel-validate-option-schema opt prefix opt-idx)))
            (unless (car result)
              (throw 'option-error result)))
          (setq opt-idx (1+ opt-idx)))
        (cons t "Valid"))))))

(defun jf/gptel-validate-option-schema (option prefix idx)
  "Validate a single option's schema.
Returns (success-p . error-message)."
  (let ((opt-prefix (concat prefix (format "Option[%d]: " idx))))
    (cond
     ;; Check option is object
     ((not (plistp option))
      (cons nil (concat opt-prefix "Must be an object")))

     ;; Check required fields
     ((not (plist-member option :key))
      (cons nil (concat opt-prefix "Missing required field: key")))
     ((not (plist-member option :label))
      (cons nil (concat opt-prefix "Missing required field: label")))
     ((not (plist-member option :description))
      (cons nil (concat opt-prefix "Missing required field: description")))

     ;; Check field types
     ((not (stringp (plist-get option :key)))
      (cons nil (concat opt-prefix "Field 'key' must be a string")))
     ((not (stringp (plist-get option :label)))
      (cons nil (concat opt-prefix "Field 'label' must be a string")))
     ((not (stringp (plist-get option :description)))
      (cons nil (concat opt-prefix "Field 'description' must be a string")))

     (t (cons t "Valid")))))

(defun jf/gptel-validate-text-question (question prefix)
  "Validate text question specific fields.
Returns (success-p . error-message)."
  (cond
   ;; Check prompt field (optional but must be string if present)
   ((and (plist-member question :prompt)
         (not (stringp (plist-get question :prompt))))
    (cons nil (concat prefix "Field 'prompt' must be a string if present")))

   ;; Check default field (optional but must be string if present)
   ((and (plist-member question :default)
         (not (stringp (plist-get question :default))))
    (cons nil (concat prefix "Field 'default' must be a string if present")))

   (t (cons t "Valid"))))

(defun jf/gptel-validate-questions-semantics (data)
  "Validate semantic constraints.
Returns (success-p . error-message)."
  (let ((questions (plist-get data :questions))
        (seen-ids '()))
    (catch 'semantic-error
      ;; Check for duplicate question IDs
      (let ((idx 0))
        (dolist (q questions)
          (let ((id (plist-get q :id)))
            (when (member id seen-ids)
              (throw 'semantic-error
                     (cons nil (format "Question[%d]: Duplicate question ID '%s'" idx id))))
            (push id seen-ids))

          ;; Check header length (max 12 chars)
          (let ((header (plist-get q :header)))
            (when (> (length header) 12)
              (throw 'semantic-error
                     (cons nil (format "Question[%d]: Header too long (max 12 chars): '%s'"
                                       idx header)))))

          ;; Validate choice question keys
          (when (string= (plist-get q :type) "choice")
            (let ((result (jf/gptel-validate-choice-keys q idx)))
              (unless (car result)
                (throw 'semantic-error result))))

          (setq idx (1+ idx))))

      (cons t "Semantics valid"))))

(defun jf/gptel-validate-choice-keys (question idx)
  "Validate option keys in a choice question.
Returns (success-p . error-message)."
  (let ((options (plist-get question :options))
        (seen-keys '())
        (opt-idx 0)
        (prefix (format "Question[%d]: " idx)))
    (catch 'key-error
      (dolist (opt options)
        (let ((key (plist-get opt :key)))
          ;; Check key is single character
          (unless (= (length key) 1)
            (throw 'key-error
                   (cons nil (concat prefix
                                     (format "Option[%d]: Key must be single character, got '%s'"
                                             opt-idx key)))))

          ;; Check for duplicate keys
          (when (member key seen-keys)
            (throw 'key-error
                   (cons nil (concat prefix
                                     (format "Option[%d]: Duplicate key '%s'"
                                             opt-idx key)))))

          (push key seen-keys))
        (setq opt-idx (1+ opt-idx)))

      (cons t "Keys valid"))))
#+end_src

** State Management

Buffer-local variables to track answers during question flow.

#+begin_src emacs-lisp
(defvar-local jf/gptel-ask--answers nil
  "Alist of answers during question flow.
Each entry is (question-id question-text answer key).")

(defun jf/gptel-ask--record-answer (question-id question-text answer key)
  "Record user's answer for QUESTION-ID.
QUESTION-TEXT is the full question, ANSWER is the user's response,
KEY is the option key (for choice questions, nil for text)."
  (setq jf/gptel-ask--answers
        (cons (list question-id question-text answer key)
              (assoc-delete-all question-id jf/gptel-ask--answers))))

(defun jf/gptel-ask--all-answered-p (questions)
  "Check if all QUESTIONS have been answered."
  (= (length jf/gptel-ask--answers)
     (length questions)))

(defun jf/gptel-ask--clear-answers ()
  "Clear all recorded answers."
  (setq jf/gptel-ask--answers nil))

(defun jf/gptel-ask--current-question-index (questions)
  "Get index of current unanswered question.
Returns 0-based index, or nil if all answered."
  (let ((answered-ids (mapcar #'car jf/gptel-ask--answers)))
    (cl-position-if
     (lambda (q)
       (not (member (plist-get q :id) answered-ids)))
     questions)))
#+end_src

** Suffix Generation

Build transient suffix specifications dynamically from question data.

#+begin_src emacs-lisp
(defun jf/gptel-ask--build-suffixes (questions callback)
  "Build suffix list for current unanswered question in QUESTIONS.
CALLBACK is the async callback to invoke when complete."
  (let* ((current-idx (jf/gptel-ask--current-question-index questions))
         (question (when current-idx (nth current-idx questions))))
    (if question
        (cond
         ((string= (plist-get question :type) "choice")
          (jf/gptel-ask--build-choice-suffixes question callback))
         ((string= (plist-get question :type) "text")
          (jf/gptel-ask--build-text-suffix question callback))
         (t
          (error "Unknown question type: %s" (plist-get question :type))))
      ;; No unanswered questions - shouldn't happen
      (error "No unanswered questions found"))))

(defun jf/gptel-ask--build-choice-suffixes (question callback)
  "Build suffix specs for a choice QUESTION.
Returns list of transient suffix specifications."
  (let ((options (plist-get question :options))
        (question-id (plist-get question :id))
        (question-text (plist-get question :question)))
    (mapcar
     (lambda (option)
       (let ((key (plist-get option :key))
             (label (plist-get option :label))
             (description (plist-get option :description)))
         ;; Build suffix spec: (key label command :description desc)
         (list key
               label
               (jf/gptel-ask--make-choice-handler
                question-id question-text option callback)
               :description description)))
     options)))

(defun jf/gptel-ask--build-text-suffix (question callback)
  "Build suffix spec for a text input QUESTION.
Returns single-item list with suffix specification."
  (let ((header (plist-get question :header))
        (question-id (plist-get question :id))
        (question-text (plist-get question :question)))
    ;; Return single suffix with RET key binding
    (list
     (list "RET"
           (format "Enter %s" header)
           (jf/gptel-ask--make-text-handler
            question-id question-text question callback)
           :description "Press RET to enter text"))))
#+end_src

** Handler Functions

Create suffix command closures that record answers and manage question flow.

#+begin_src emacs-lisp
(defun jf/gptel-ask--make-choice-handler (question-id question-text option callback)
  "Create suffix command for a choice option.
QUESTION-ID identifies the question, QUESTION-TEXT is the full question,
OPTION is the option plist, CALLBACK is the async callback."
  (lambda ()
    (interactive)
    (let ((answer (plist-get option :label))
          (key (plist-get option :key)))
      ;; Record answer
      (jf/gptel-ask--record-answer question-id question-text answer key)

      ;; Check if more questions remain
      (let* ((scope (transient-scope))
             (questions (plist-get scope :questions)))
        (if (jf/gptel-ask--all-answered-p questions)
            ;; All answered - finish and invoke callback
            (jf/gptel-ask--finish questions callback)
          ;; More questions remain - set transitioning flag
          (setq jf/gptel-ask--transitioning t)
          ;; Re-setup transient for next question
          (transient-setup 'jf/gptel-ask-menu nil nil :scope scope)
          ;; Clear transitioning flag after a brief delay to allow exit hook to run
          (run-at-time 0.05 nil (lambda () (setq jf/gptel-ask--transitioning nil))))))))

(defun jf/gptel-ask--make-text-handler (question-id question-text question callback)
  "Create suffix command for a text input question.
QUESTION-ID identifies the question, QUESTION-TEXT is the full question,
QUESTION is the full question plist (for prompt and default),
CALLBACK is the async callback."
  (lambda ()
    (interactive)
    (let* ((prompt (or (plist-get question :prompt)
                       (format "%s: " (plist-get question :header))))
           (default (plist-get question :default))
           (answer (read-string prompt default)))
      ;; Record answer (no key for text input)
      (jf/gptel-ask--record-answer question-id question-text answer nil)

      ;; Check if more questions remain
      (let* ((scope (transient-scope))
             (questions (plist-get scope :questions)))
        (if (jf/gptel-ask--all-answered-p questions)
            ;; All answered - finish and invoke callback
            (jf/gptel-ask--finish questions callback)
          ;; More questions remain - set transitioning flag
          (setq jf/gptel-ask--transitioning t)
          ;; Re-setup transient for next question
          (transient-setup 'jf/gptel-ask-menu nil nil :scope scope)
          ;; Clear transitioning flag after a brief delay
          (run-at-time 0.05 nil (lambda () (setq jf/gptel-ask--transitioning nil))))))))
#+end_src

** Result Building

Build JSON result from collected answers and invoke callback.

#+begin_src emacs-lisp
(defun jf/gptel-ask--finish (questions callback)
  "Build result JSON and invoke CALLBACK.
QUESTIONS is the list of question plists."
  (let ((result (jf/gptel-ask--build-result-json questions jf/gptel-ask--answers)))
    ;; Clear active callback and transitioning flag (prevents exit hook from triggering)
    (setq jf/gptel-ask--active-callback nil)
    (setq jf/gptel-ask--transitioning nil)
    ;; Clean up
    (jf/gptel-ask--clear-answers)
    ;; Exit transient
    (transient-quit-one)
    ;; Invoke callback with JSON result
    (funcall callback result)))

(defun jf/gptel-ask--build-result-json (questions answers)
  "Build JSON result from ANSWERS.
QUESTIONS is the list of question plists for context.
Returns JSON string."
  (let ((answer-list
         (mapcar
          (lambda (q)
            (let* ((q-id (plist-get q :id))
                   (answer-data (assoc q-id answers))
                   (q-text (nth 1 answer-data))
                   (answer (nth 2 answer-data))
                   (key (nth 3 answer-data)))
              (if key
                  ;; Choice question (has key)
                  (list :id q-id
                        :question q-text
                        :answer answer
                        :key key)
                ;; Text question (no key)
                (list :id q-id
                      :question q-text
                      :answer answer))))
          questions)))
    (json-serialize
     (list :status "completed"
           :answers (vconcat answer-list)))))
#+end_src

** Dynamic Transient Menu

The main transient prefix with dynamic suffix generation.

#+begin_src emacs-lisp
(transient-define-prefix jf/gptel-ask-menu ()
  "Dynamic question menu for gptel tool."
  [:description
   (lambda ()
     (let* ((scope (transient-scope))
            (questions (plist-get scope :questions))
            (current-idx (jf/gptel-ask--current-question-index questions))
            (question (when current-idx (nth current-idx questions)))
            (total (length questions))
            (progress (1+ current-idx)))
       ;; Format: "Question 1/3: What is your choice?"
       (format "Question %d/%d: %s"
               progress total (plist-get question :question))))
   [:class transient-column
    :setup-children
    (lambda (_)
      (let* ((scope (transient-scope))
             (questions (plist-get scope :questions))
             (callback (plist-get scope :callback)))
        (transient-parse-suffixes
         'jf/gptel-ask-menu
         (jf/gptel-ask--build-suffixes questions callback))))]])
#+end_src

** Cancellation Handling

Track active question flows and handle C-g cancellation.

**IMPORTANT:** These are global variables, which means concurrent sessions are not
fully supported. If two gptel buffers call this tool simultaneously, the second
call will overwrite the first's callback. The :scope mechanism provides per-session
isolation for questions and answers, but cancellation tracking is global.

Future enhancement: Use buffer-local variables or a session registry to support
concurrent sessions properly.

#+begin_src emacs-lisp
(defvar jf/gptel-ask--active-callback nil
  "Global callback for currently active question flow.
Set when question flow starts, cleared when completed or cancelled.
WARNING: Global variable - only one active question flow supported at a time.")

(defvar jf/gptel-ask--transitioning nil
  "Global flag - non-nil when transitioning between questions.
Used to prevent exit hook from firing during normal transitions.
WARNING: Global variable - concurrent sessions not supported.")

(defun jf/gptel-ask--handle-exit ()
  "Handle transient exit - call callback with cancellation if incomplete.
This runs on transient-exit-hook to catch C-g cancellations."
  (when (and jf/gptel-ask--active-callback
             (not jf/gptel-ask--transitioning))
    ;; Transient exited but callback still active AND not transitioning - user cancelled
    (funcall jf/gptel-ask--active-callback
             (json-serialize (list :status "cancelled" :answers [])))
    (setq jf/gptel-ask--active-callback nil)
    (jf/gptel-ask--clear-answers)))

;; Register exit handler
(add-hook 'transient-exit-hook #'jf/gptel-ask--handle-exit)
#+end_src

** Async Tool Function

The tool function that validates JSON and opens the transient menu.

#+begin_src emacs-lisp
(defun jf/gptel-ask-user-questions (callback questions-json)
  "Async tool to ask user structured questions via transient menu.
CALLBACK is the async callback (called with JSON result).
QUESTIONS-JSON is the JSON string describing the questions."
  ;; Validate JSON
  (let ((validation (jf/gptel-validate-questions-json questions-json)))
    (if (car validation)
        ;; Validation passed - open menu
        (let ((data (cdr validation))
              (questions (plist-get (cdr validation) :questions)))
          ;; Clear any previous answers and state
          (jf/gptel-ask--clear-answers)
          (setq jf/gptel-ask--transitioning nil)
          ;; Set active callback for cancellation handling
          (setq jf/gptel-ask--active-callback callback)
          ;; Open transient with questions and callback in scope
          (transient-setup 'jf/gptel-ask-menu nil nil
                           :scope (list :questions questions
                                        :callback callback)))
      ;; Validation failed - return error immediately
      (funcall callback (cdr validation)))))
#+end_src

** Tool Registration

Register the tool with gptel's tool system.

#+begin_src emacs-lisp
(gptel-make-tool
 :name "ask_user_questions"
 :function #'jf/gptel-ask-user-questions
 :description "Ask the user structured questions via an interactive menu.

This tool presents questions to the user through a visual menu interface.
The user can select from predefined options or provide text input.

Input: JSON string with the following structure:
{
  \"questions\": [
    {
      \"id\": \"unique_id\",
      \"header\": \"Short Label\",
      \"question\": \"Full question text?\",
      \"type\": \"choice\" | \"text\",
      \"options\": [{\"key\": \"a\", \"label\": \"Option A\", \"description\": \"What this means\"}],
      \"prompt\": \"Text prompt: \" (for text type),
      \"default\": \"default value\" (for text type)
    }
  ]
}

Returns: JSON string with answers:
{
  \"status\": \"completed\" | \"cancelled\",
  \"answers\": [
    {\"id\": \"q1\", \"question\": \"...\", \"answer\": \"...\", \"key\": \"a\"}
  ]
}

Constraints:
- 1-4 questions max (fully supported)
- 2-4 options per choice question
- Single character keys
- Headers max 12 characters"
 :args (list '(:name "questions_json"
               :type string
               :description "JSON string containing the questions to ask"))
 :category "interaction"
 :async t
 :confirm nil)
#+end_src

* Usage Guide

** JSON Schema Reference

*** Input Format

#+begin_src json
{
  "questions": [
    {
      "id": "unique_id",           // Required: Unique identifier
      "header": "Short",            // Required: Max 12 chars, shown as tag
      "question": "Full question?", // Required: Full question text
      "type": "choice",             // Required: "choice" or "text"

      // For choice questions only:
      "options": [
        {
          "key": "a",               // Required: Single character
          "label": "Option A",      // Required: 1-5 words
          "description": "Details"  // Required: What this option means
        }
      ],

      // For text questions only:
      "prompt": "Enter value: ",    // Optional: Custom prompt (default: "Header: ")
      "default": "default value"    // Optional: Pre-filled value
    }
  ]
}
#+end_src

**Constraints:**
- 1-4 questions per call
- 2-4 options per choice question
- Option keys must be single characters and unique within question
- Question IDs must be unique

*** Output Format

#+begin_src json
{
  "status": "completed",  // or "cancelled" if user pressed C-g
  "answers": [
    {
      "id": "q1",
      "question": "Full question text?",
      "answer": "Option A",  // or user's text input
      "key": "a"             // Only present for choice questions
    }
  ]
}
#+end_src

** Example LLM Prompts

*** Single Choice Question

"Please ask me to choose between OAuth 2.0, JWT, or session-based authentication."

*** Multiple Questions

"I'm setting up a new project. Please ask me:
1. Which framework to use (React, Vue, or Angular)
2. Which database to use (PostgreSQL, MySQL, or MongoDB)
3. What the project name should be (text input)"

*** Mixed Question Types

"Help me configure my development environment. Ask me to choose my preferred
editor (VSCode, Emacs, Vim) and then ask for my preferred color theme name."

** Common Patterns

*** Decision Making
Presenting 2-4 mutually exclusive options for user selection.

*** Configuration Collection
Gathering multiple related settings in sequence (framework, database, hosting, etc.).

### User Preference Collection
Learning user preferences for customization or personalization.

*** Project Setup
Collecting project metadata (name, description, author, license).

** Known Limitations

⚠️ **Concurrent Sessions:** Cancellation tracking uses global variables. If two gptel
buffers call this tool simultaneously, the second call may interfere with the first's
cancellation handling. Questions, answers, and callbacks are properly isolated via
:scope, but C-g detection is not. Avoid concurrent use until fixed.

* Provide Statement

#+begin_src emacs-lisp
(provide 'transient-tools)
;;; transient-tools.el ends here
#+end_src
