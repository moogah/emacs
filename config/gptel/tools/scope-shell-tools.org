#+title: GPTEL Scope Manager - Shell and Meta Tools
#+author: Jeff Farr
#+property: header-args:elisp :tangle scope-shell-tools.el :comments both

* Overview

This module provides scope-aware shell execution and meta tools for v3.0 preset-based permission management:

1. *Shell tool*: =run_bash_command= - Execute shell commands with category-based scope validation
2. *Meta tool*: =request_scope_expansion= - LLM requests user approval via transient menu (v3.0 async)

** Shell Command Scoping (v3.0)

The =run_bash_command= tool uses preset.md bash_tools configuration with command categorization by operational impact:

*** Command Categories

Commands are grouped by *operational impact* rather than technical function:

1. *read_only* - Commands that only read data
   - Examples: =ls=, =grep=, =find=, =cat=, =git log=, =git diff=
   - Can execute in any readable directory (paths.read or paths.write)
   - No risk of data modification

2. *safe_write* - Commands that create or modify safely
   - Examples: =mkdir=, =touch=, =echo=, =git add=, =git commit=
   - Require write-enabled directory (paths.write)
   - Create new content but don't destroy existing data

3. *dangerous* - Commands requiring explicit approval
   - Empty by default
   - User must approve via scope expansion for each addition
   - For commands with potential for unintended consequences

4. *deny* - Commands never allowed
   - Examples: =rm=, =mv=, =sudo=, =dd=
   - Destructive operations that should never be automated
   - Rejected immediately without scope expansion option

*** Path Scope Binding

Each category binds to path scope requirements:

| Category    | Requires paths.read | Requires paths.write | Notes                           |
|-------------|---------------------|----------------------|---------------------------------|
| read_only   | ✓ (or write)        |                      | Write scope includes read       |
| safe_write  |                     | ✓                    | More restrictive                |
| dangerous   | ✓                   | ✓                    | Plus explicit approval          |
| deny        | ✗                   | ✗                    | Never allowed                   |

*Key insight:* Write paths imply read access. If a directory is in =paths.write=, read_only commands can execute there. This matches the intuition that "write permission includes read permission."

*** Shell Composition

The system supports standard shell composition features:

- *Pipes*: =grep pattern file.txt | head -10=
- *Redirects*: =ls -la > listing.txt=
- *Command substitution*: =echo $(pwd)=

*Validation strategy:* Only the *base command* (first command before pipes/redirects) is categorized and validated. If =grep= is in =read_only= and the directory is in =paths.read=, then =grep | head | tail= is allowed.

*Rationale:* Validating the base command provides the primary security boundary. If =grep= is safe in a scoped directory, composing it with =head= doesn't increase risk. Parsing complex pipelines is error-prone and provides marginal security benefit.

*** Security Features

1. *Timeouts* - Commands automatically terminate after 30 seconds
   - Prevents runaway processes (e.g., =find /= or infinite loops)
   - LLM receives timeout error and can retry with more specific filters

2. *Output Truncation* - Command output limited to prevent context overflow
   - Long output truncated with notice suggesting filters
   - LLM learns to use =head=, =grep=, =tail= to narrow results

3. *Absolute Path Warnings* - Warning when command arguments contain absolute paths
   - Example: =grep pattern /other/project= triggers warning
   - Absolute paths in arguments bypass directory scope validation
   - Warning suggests using relative paths

4. *Explicit Directory Required* - Every command must specify working directory
   - No implicit fallbacks or context inference
   - Forces clear intent about where commands execute

** Scope Expansion (v3.0)

The =request_scope_expansion= tool shows interactive transient menu with 3 choices:
- *Deny* - Reject the expansion request
- *Add to scope* - Permanently add patterns to preset.md
- *Allow once* - Temporarily allow for current turn only

Uses async tool pattern with callback for FSM coordination.
UI implemented in scope-expansion.org.

*** Error Messages and Scope Expansion Flow

When validation fails, the system provides structured errors guiding the LLM to request scope expansion:

*Command not allowed:*
#+begin_example json
{
  "success": false,
  "error": "command_not_allowed",
  "tool": "run_bash_command",
  "command": "tree",
  "message": "Command 'tree' is not in allowed command lists. Use request_scope_expansion to ask user for approval."
}
#+end_example

*Directory not in scope:*
#+begin_example json
{
  "success": false,
  "error": "directory_not_in_scope",
  "directory": "/Users/jefffarr/other-project",
  "required_scope": "read",
  "allowed_patterns": ["/Users/jefffarr/emacs/**", "/Users/jefffarr/projects/**"],
  "message": "Directory not in read scope. Use request_scope_expansion to request access."
}
#+end_example

The LLM can then call =request_scope_expansion= to request user approval:
#+begin_example
request_scope_expansion(
  tool_name="run_bash_command",
  patterns=["tree"],
  justification="Need to visualize directory structure for debugging."
)
#+end_example

User sees transient menu with options to deny, add to scope, or allow once.

* File Header

#+begin_src elisp
;;; scope-shell-tools.el --- GPTEL Scope Shell and Meta Tools -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;;; Commentary:

;; Scope-aware shell execution and meta tools for v3.0 preset-based permission management.

;;; Code:
#+end_src

* Dependencies

#+begin_src elisp
(require 'cl-lib)
(require 'jf-gptel-scope-core)
(require 'jf-gptel-scope-expansion)  ; For jf/gptel-scope--prompt-expansion
#+end_src

* Bash Command Helper Functions

** Parse Command

Extract base command from complex shell strings with pipes, redirects, and command substitution.

#+begin_src elisp
(defun jf/gptel-bash--parse-command (cmd-string)
  "Extract base command from CMD-STRING.
Handles pipes, redirects, command substitution.
Examples:
  'grep foo | head' → 'grep'
  'ls -la > output.txt' → 'ls'
  'echo $(date)' → 'echo'"
  (let* ((trimmed (string-trim cmd-string))
         ;; Split on shell metacharacters
         (parts (split-string trimmed "[ |><;&]+" t))
         (base (car parts)))
    base))
#+end_src

** Categorize Command

Categorize command using bash_tools configuration section.

#+begin_src elisp
(defun jf/gptel-bash--categorize-command (command config)
  "Categorize COMMAND using CONFIG bash_tools section.
Returns: 'denied, 'read_only, 'safe_write, 'dangerous, or 'unknown."
  (let ((deny-list (plist-get config :deny))
        (read-only (plist-get (plist-get config :read_only) :commands))
        (safe-write (plist-get (plist-get config :safe_write) :commands))
        (dangerous (plist-get (plist-get config :dangerous) :commands)))
    (cond
     ((member command deny-list) 'denied)
     ((member command read-only) 'read_only)
     ((member command safe-write) 'safe_write)
     ((member command dangerous) 'dangerous)
     (t 'unknown))))
#+end_src

** Validate Directory for Category

Validate directory matches category's path scope requirement.

#+begin_src elisp
(defun jf/gptel-bash--validate-directory-for-category (directory category config)
  "Validate DIRECTORY matches CATEGORY's path scope requirement.
- read_only: must match paths.read OR paths.write
- safe_write: must match paths.write
- dangerous: always requires expansion (return error)

Returns (:allowed t) or (:allowed nil :reason ... :allowed-patterns ...)."
  (let ((read-paths (plist-get (plist-get config :paths) :read))
        (write-paths (plist-get (plist-get config :paths) :write))
        (deny-paths (plist-get (plist-get config :paths) :deny)))

    ;; Check deny first (deny takes precedence)
    (when (jf/gptel-scope--path-matches-any-pattern-p directory deny-paths)
      (cl-return-from jf/gptel-bash--validate-directory-for-category
        (list :allowed nil
              :reason (format "Directory %s matches deny pattern" directory))))

    (pcase category
      ('read_only
       ;; Read-only commands allowed in read OR write paths
       (if (or (jf/gptel-scope--path-matches-any-pattern-p directory read-paths)
               (jf/gptel-scope--path-matches-any-pattern-p directory write-paths))
           (list :allowed t)
         (list :allowed nil
               :reason (format "Directory %s not in read scope" directory)
               :required_scope "read"
               :allowed-patterns (append read-paths write-paths))))

      ('safe_write
       ;; Write commands require write paths
       (if (jf/gptel-scope--path-matches-any-pattern-p directory write-paths)
           (list :allowed t)
         (list :allowed nil
               :reason (format "Directory %s not in write scope" directory)
               :required_scope "write"
               :allowed-patterns write-paths)))

      ('dangerous
       ;; Dangerous commands always require explicit expansion
       (list :allowed nil
             :reason "Dangerous command requires explicit approval"
             :message "Use request_scope_expansion to request approval")))))
#+end_src

** Check Absolute Paths

Check if command contains absolute paths that bypass directory scoping.

#+begin_src elisp
(defun jf/gptel-bash--check-absolute-paths (command)
  "Check if COMMAND contains absolute paths.
Returns warning string if found, nil otherwise."
  (when (string-match "/[[:alnum:]_/-]+" command)
    "Warning: Command contains absolute path arguments. Directory scope may not protect these paths."))
#+end_src

** Execute Command

Execute command in directory with timeout and output truncation.

#+begin_src elisp
(defun jf/gptel-bash--execute-command (command directory)
  "Execute COMMAND in DIRECTORY with timeout and output truncation.
Returns (:success t :output ...) or (:success nil :error ...)."
  (let* ((default-directory (file-truename (expand-file-name directory)))
         (output nil)
         (exit-code nil)
         (max-output-chars 10000))

    (condition-case err
        (with-timeout (30)  ; 30-second timeout
          (setq output
                (with-temp-buffer
                  (setq exit-code
                        (call-process shell-file-name nil t nil
                                      shell-command-switch command))
                  (buffer-string))))
      (error
       (cl-return-from jf/gptel-bash--execute-command
         (list :success nil
               :error (format "Command timed out or failed: %s" err)))))

    ;; Truncate output if too long
    (when (> (length output) max-output-chars)
      (setq output
            (concat (substring output 0 max-output-chars)
                    (format "\n\n[Output truncated at %d chars. Use more specific filters like 'head', 'grep', or 'tail' to narrow results.]"
                            max-output-chars))))

    ;; Check for warnings
    (let ((path-warning (jf/gptel-bash--check-absolute-paths command)))
      (when path-warning
        (setq output (concat path-warning "\n\n" output))))

    (if (zerop exit-code)
        (list :success t :output output)
      (list :success nil :error output :exit_code exit-code))))
#+end_src

* Run Bash Command Tool (Scope-Aware, v3.0)

Execute bash commands in specified directory with category-based scope validation.

** Tool Signature

Function: =run_bash_command(command, directory)=

*Parameters:*
- =command= (string, required): Shell command to execute, including any arguments, pipes, or redirects
- =directory= (string, required): Absolute path to working directory where command executes

*Returns:*
- =success= (boolean): Whether command executed successfully
- =stdout= (string): Command output (truncated if too long)
- =stderr= (string): Command error output
- =exit_code= (integer): Process exit code
- =error= (string): Error type if validation failed

** Common Usage Patterns

*Codebase exploration (read_only):*
#+begin_example
run_bash_command("ls -la", "/Users/jefffarr/projects/myapp")
run_bash_command("find . -name '*.py' -type f", "/Users/jefffarr/projects/myapp")
run_bash_command("grep -rn 'TODO' src/", "/Users/jefffarr/projects/myapp")
run_bash_command("git log --oneline -10", "/Users/jefffarr/projects/myapp")
#+end_example

*File creation (safe_write):*
#+begin_example
run_bash_command("mkdir -p scratch/experiment", "/Users/jefffarr/emacs")
run_bash_command("touch notes.txt", "/tmp")
run_bash_command("echo 'content' > file.txt", "/tmp")
#+end_example

*Git operations:*
#+begin_example
run_bash_command("git status", "/Users/jefffarr/emacs")          # read_only
run_bash_command("git add config/file.el", "/Users/jefffarr/emacs")  # safe_write
run_bash_command("git commit -m 'message'", "/Users/jefffarr/emacs") # safe_write
#+end_example

*Shell composition:*
#+begin_example
run_bash_command("grep pattern . | head -20", "/Users/jefffarr/projects/myapp")
run_bash_command("find . -name '*.org' | wc -l", "/Users/jefffarr/emacs")
run_bash_command("ls -la > listing.txt", "/tmp")
#+end_example

** Troubleshooting

*** Command denied unexpectedly

*Symptom:* Command should be allowed but gets "command_not_allowed" error

*Check:*
1. Is base command in any category list? (not full command with arguments)
2. Spelling matches exactly? (case-sensitive)
3. Git commands use full form? (=git log= not just =git=)

*** Directory scope error

*Symptom:* "directory_not_in_scope" error

*Check:*
1. Does directory match paths.read or paths.write pattern?
2. Is directory in paths.deny?
3. For safe_write commands, is directory in paths.write (not just paths.read)?
4. Are glob patterns correct? (=**= for recursive, =*= for single level)

*** Timeout errors

*Symptom:* Command killed after 30 seconds

*Solution:*
- Use more specific filters: =grep -r pattern . --include='*.el'=
- Limit scope: =find . -maxdepth 3 -name '*.org'=
- Use =head= to limit output: =git log | head -50=

*** Truncated output

*Symptom:* Output ends with truncation notice

*Solution:*
- Add filters: =grep=, =head=, =tail= to narrow results
- Use more specific patterns: =find . -name 'exact-name.txt'=
- Process in chunks: Multiple commands with different filters

** Tool Implementation

#+begin_src elisp
(gptel-make-scoped-tool
 "run_bash_command"
 "Execute shell command in specified directory with scope validation.

Commands are categorized:
- read_only: ls, grep, find, cat, head, tail, wc, file, git log, git show, git diff
- safe_write: mkdir, touch, echo, git add, git commit
- dangerous: (empty by default, requires explicit approval)

Directory must be in scope for command category:
- read_only commands: directory must match paths.read OR paths.write
- safe_write commands: directory must match paths.write

Shell composition allowed (pipes, redirects, command substitution), but only base command is validated.

Security features:
- 30-second timeout
- Output truncation at 10,000 chars
- Warnings for absolute paths in arguments
- Deny list blocks dangerous commands (rm, mv, chmod, sudo)

Examples:
  run_bash_command('ls -la', '/Users/jefffarr/emacs')
  run_bash_command('grep -r TODO . | head -20', '/Users/jefffarr/projects/myapp')
  run_bash_command('git log --oneline -10', '/Users/jefffarr/emacs')
  run_bash_command('mkdir scratch', '/tmp')"

 (list '(:name "command"
         :type string
         :description "Shell command to execute (pipes and redirects allowed)")
       '(:name "directory"
         :type string
         :description "Working directory (must be in scope for command category)"))

 "bash"

 ;; Tool body - executed only if validation passes
 (jf/gptel-bash--execute-command command directory))
#+end_src

* Request Scope Expansion Tool (Meta Tool, v3.0 Async)

LLM uses this tool to explicitly request user approval for expanding scope using transient menu.

#+begin_src elisp
(gptel-make-tool
 :name "request_scope_expansion"
 :async t  ; MUST be async for transient menu
 :description "Request user approval to expand scope with new patterns.

Displays interactive menu with 3 options:
1. Deny - Reject the expansion request
2. Add to scope - Permanently add patterns to preset.md
3. Allow once - Temporarily allow for current turn only

The user will see:
- Which tool needs access
- What patterns/resources you want to add
- Your justification for why access is needed

Returns:
- success: true if approved (add-to-scope or allow-once)
- success: false if denied
- allowed_once: true if temporary permission granted
- patterns_added: list of patterns if permanently added"
 :args (list '(:name "tool_name"
               :type string
               :description "Tool name (e.g., 'read_file', 'write_file_in_scope', 'run_approved_command')")
             '(:name "patterns"
               :type array
               :items (:type string)
               :description "Patterns to add (e.g., [\"/tmp/**\"] for files, [\"npm\"] for shell)")
             '(:name "justification"
               :type string
               :description "Explain why this access is needed. Be specific."))
 :category "scope"
 :function
 (lambda (callback tool_name patterns justification)  ; callback first!
   ;; Convert patterns from vector to list
   (when (vectorp patterns)
     (setq patterns (append patterns nil)))

   ;; Build violation info for transient menu
   (let* ((violation-info
           (list :tool tool_name
                 :resource (car patterns)  ; First pattern as resource
                 :reason justification
                 :validation-type (jf/gptel-scope--infer-validation-type tool_name)
                 :patterns patterns)))

     ;; Show transient menu - pass callback, patterns, tool_name directly in scope
     (jf/gptel-scope--prompt-expansion violation-info callback patterns tool_name))))
#+end_src

* Helper: Infer Validation Type

Helper to infer validation type from tool name using tool categories.

#+begin_src elisp
(defun jf/gptel-scope--infer-validation-type (tool-name)
  "Infer validation type from TOOL-NAME using tool categories."
  (let ((category (cdr (assoc tool-name jf/gptel-scope--tool-categories))))
    (plist-get category :validation)))
#+end_src

* Obsolete: inspect_scope_plan Tool (Removed in v3.0)

In v3.0, preset.md is a readable markdown file with YAML frontmatter.
LLM can use read_file("preset.md") to inspect scope configuration directly.
No dedicated inspection tool needed.

* Provide Feature

#+begin_src elisp
(provide 'jf-gptel-scope-shell-tools)
;;; scope-shell-tools.el ends here
#+end_src
