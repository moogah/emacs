#+title: GPTEL Ggtags Tools
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle ggtags-tools.el
#+auto_tangle: y

* Introduction
Tools for semantic code navigation using ggtags (GNU Global frontend).

These tools enable LLM agents to navigate code semantically - finding definitions,
references, and understanding code structure - much faster and more accurately than
text-based search (grep).

Ggtags provides:
- Go-to-definition navigation
- Find all references/usages
- Symbol search across entire codebase
- Tag database management

These tools complement projectile tools by providing semantic code understanding
rather than file-based operations.

All 7 ggtags tools are scope-aware and require permission via session scope plans
before accessing project directories:
- check_ggtags_project
- find_definition
- find_references
- find_symbol
- create_ggtags_project
- update_ggtags_project
- explain_ggtags_indexing

Permission is validated based on the directory (project root) path against
glob patterns defined in ~/.gptel/sessions/SESSION_ID/scope-plan.yml.

* Basic Configuration
#+begin_src emacs-lisp
;;; ggtags-tools.el --- GPTEL tools for semantic code navigation with ggtags -*- lexical-binding: t; -*-
(require 'ggtags)
(require 'jf-gptel-scope-core)
#+end_src

* Helper Functions
#+begin_src emacs-lisp
(defvar gptel-ggtags-result-limit 40000
  "Maximum character count for tool results to prevent context overflow.")

(defun gptel-ggtags--result-limit (result)
  "Limit RESULT to gptel-ggtags-result-limit characters.
If exceeded, return a warning message instead."
  (if (>= (length (format "%s" result)) gptel-ggtags-result-limit)
      (format "Results over %s characters. Use limit parameter to narrow results or increase limit."
              gptel-ggtags-result-limit)
    result))
#+end_src

* Project Status Tools

** check_ggtags_project
Check if ggtags project exists and report status.

#+begin_src emacs-lisp
(gptel-make-scoped-tool
 "check_ggtags_project"
 "SCOPE-AWARE: Requires directory to match allowed patterns.

Check if a ggtags project exists and report status.

CRITICAL: Use this tool FIRST before any ggtags navigation operations.

Returns:
- Whether GTAGS database exists
- Project root location
- Last update time (age in days)
- Status assessment (current/stale)
- Recommended next actions

If no tags exist, guides you to create_ggtags_project.
If tags are old, suggests update_ggtags_project.

Typical workflow:
1. check_ggtags_project(directory) - Verify tags available
2. If no tags: create_ggtags_project(directory)
3. If tags exist: find_definition, find_references, etc.
4. If stale: update_ggtags_project(directory)

Arguments:
- directory: Project root directory path

This tool helps avoid 'symbol not found' errors by verifying tag database status first.

Returns scope_violation error if directory not in allowed patterns.
Use request_scope_expansion to request access."
 (list '(:name "directory"
         :type string
         :description "Project root directory path"))
 "ggtags"
 (let* ((gtags-file (expand-file-name "GTAGS" directory))
        (exists (file-exists-p gtags-file))
        (mtime (when exists (file-attribute-modification-time
                             (file-attributes gtags-file))))
        (age-days (when mtime
                    (/ (float-time (time-subtract (current-time) mtime))
                       86400.0))))
   (if (not exists)
       (list :success t
             :gtags_exists nil
             :message (format "No GTAGS database found at %s\n\nTo enable semantic navigation:\n1. Use create_ggtags_project(%s) to create tags\n2. Then use find_definition, find_references, etc."
                              directory directory))
     (let ((status (if (< age-days 1) "Current"
                     (if (< age-days 7) "Likely current" "Possibly stale"))))
       (list :success t
             :gtags_exists t
             :project_root directory
             :age_days age-days
             :status status
             :message (format "GTAGS Status:\n\nProject Root: %s\nTags Exist: Yes\nLast Updated: %.1f days ago\nApproximate Status: %s\n\nNext Steps:\n- Use find_definition(directory, symbol) to navigate code\n- Use find_references(directory, symbol) to see usage\n- If tags seem stale, use update_ggtags_project(directory)"
                              directory age-days status))))))
#+end_src

* Code Navigation Tools

** find_definition
Find where a symbol is defined (primary navigation tool).

#+begin_src emacs-lisp
(gptel-make-scoped-tool
 "find_definition"
 "SCOPE-AWARE: Requires directory to match allowed patterns.

Find where a symbol is defined.

This is the PRIMARY tool for code navigation. Use this to:
- Locate function/method definitions
- Find class declarations
- Find variable/constant definitions
- Understand where code is implemented

MUCH faster and more accurate than grep because it understands code structure.

Returns locations in format:
  file:line: code_context

For example:
  src/utils.py:42: def process_data(input):
  src/models.py:15: class DataProcessor:

If multiple definitions exist (overloaded functions, multiple classes with same name),
all definitions are shown.

Typical workflow:
1. check_ggtags_project(directory) - Ensure tags exist
2. find_definition(directory, 'function_name') - Locate implementation
3. Use Read tool on the file to see full context
4. find_references(directory, 'function_name') - See where it's used

Arguments:
- directory: Project root directory (required)
- symbol: Symbol name to find (function, class, variable, etc.)
- limit: Max results to return (default 50, max 100)

Use this instead of grep when looking for where code is defined.

Returns scope_violation error if directory not in allowed patterns.
Use request_scope_expansion to request access."
 (list '(:name "directory"
         :type string
         :description "Project root directory")
       '(:name "symbol"
         :type string
         :description "Symbol name (function, class, variable)")
       '(:name "limit"
         :type integer
         :optional t
         :description "Max results (default 50, max 100)"))
 "ggtags"
 (let ((default-directory directory)
       (file-limit (min (or limit 50) 100)))
   (condition-case err
       (let* ((cmd (ggtags-global-build-command 'definition symbol))
              (output (shell-command-to-string cmd))
              (lines (split-string output "\n" t))
              (results (seq-take lines file-limit))
              (total (length lines)))
         (if (zerop total)
             (list :success t
                   :definitions nil
                   :symbol symbol
                   :count 0
                   :message (format "Symbol '%s' not found.\n\nPossible reasons:\n1. Symbol not defined in project\n2. Tags are stale - use update_ggtags_project(%s)\n3. Symbol in ignored files - use explain_ggtags_indexing(%s)"
                                    symbol directory directory))
           (let ((message-str (format "Found %d definition%s for '%s':\n\n%s%s"
                                      total
                                      (if (= total 1) "" "s")
                                      symbol
                                      (mapconcat #'identity results "\n")
                                      (if (> total file-limit)
                                          (format "\n\n[Truncated: showing %d of %d. Use limit parameter to adjust]"
                                                  file-limit total)
                                        ""))))
             (list :success t
                   :definitions results
                   :symbol symbol
                   :count total
                   :message (gptel-ggtags--result-limit message-str)))))
     (error (list :success nil
                  :error "find_definition_error"
                  :message (format "Error finding definition: %s\n\nCheck that:\n1. GTAGS exists (use check_ggtags_project)\n2. Global is installed\n3. Directory path is correct"
                                   (error-message-string err)))))))
#+end_src

** find_references
Find all places where a symbol is used/called.

#+begin_src emacs-lisp
(gptel-make-scoped-tool
 "find_references"
 "SCOPE-AWARE: Requires directory to match allowed patterns.

Find all references to a symbol (where it's used/called).

Use this to:
- Find all call sites of a function
- Locate all uses of a variable/constant
- Understand impact radius of changing code
- Trace code flow and dependencies
- See usage examples

Shows every place the symbol is referenced (excluding its definition).

Returns locations in format:
  file:line: code_context

IMPORTANT: Can return many results for commonly-used symbols (e.g., utility functions).
Use the limit parameter to control output size.

Typical workflow:
1. find_definition(directory, symbol) - See how it's implemented
2. find_references(directory, symbol) - See where it's used
3. Analyze usage patterns and dependencies
4. Use Read tool on specific files for detailed context

Arguments:
- directory: Project root directory (required)
- symbol: Symbol name to find references for
- limit: Max results (default 50, max 200 for heavily-used symbols)

Complements find_definition by showing usage rather than implementation.

Returns scope_violation error if directory not in allowed patterns.
Use request_scope_expansion to request access."
 (list '(:name "directory"
         :type string
         :description "Project root directory")
       '(:name "symbol"
         :type string
         :description "Symbol to find references for")
       '(:name "limit"
         :type integer
         :optional t
         :description "Max results (default 50, max 200)"))
 "ggtags"
 (let ((default-directory directory)
       (file-limit (min (or limit 50) 200)))
   (condition-case err
       (let* ((cmd (ggtags-global-build-command 'reference symbol))
              (output (shell-command-to-string cmd))
              (lines (split-string output "\n" t))
              (results (seq-take lines file-limit))
              (total (length lines)))
         (if (zerop total)
             (list :success t
                   :references nil
                   :symbol symbol
                   :count 0
                   :message (format "No references found for '%s'.\n\nThis could mean:\n1. Symbol is defined but never used\n2. Tags are stale - use update_ggtags_project(%s)\n3. Only used in ignored files"
                                    symbol directory))
           (let ((message-str (format "Found %d reference%s to '%s':\n\n%s%s"
                                      total
                                      (if (= total 1) "" "s")
                                      symbol
                                      (mapconcat #'identity results "\n")
                                      (if (> total file-limit)
                                          (format "\n\n[Truncated: showing %d of %d. Increase limit or refine search]"
                                                  file-limit total)
                                        ""))))
             (list :success t
                   :references results
                   :symbol symbol
                   :count total
                   :message (gptel-ggtags--result-limit message-str)))))
     (error (list :success nil
                  :error "find_references_error"
                  :message (format "Error finding references: %s" (error-message-string err)))))))
#+end_src

** find_symbol
Find all occurrences of symbol (definitions + references combined).

#+begin_src emacs-lisp
(gptel-make-scoped-tool
 "find_symbol"
 "SCOPE-AWARE: Requires directory to match allowed patterns.

Find all occurrences of a symbol (definitions + references).

Combines find_definition and find_references into one comprehensive search.
Shows everywhere a symbol appears in the codebase.

Use this when:
- You want a complete picture of a symbol
- You're not sure if something is defined or just used
- You need to see all occurrences at once
- You're exploring unfamiliar code

Returns locations in format:
  file:line: code_context

For commonly-used symbols this can return many results.

When to use each tool:
- find_definition: Just show where defined (fastest, most focused)
- find_references: Just show where used (understand impact)
- find_symbol: Show everything (complete overview)

Arguments:
- directory: Project root directory (required)
- symbol: Symbol name to search for
- limit: Max results (default 50, max 200)

Note: For large results, consider using find_definition first to understand
the symbol, then find_references to see specific usage.

Returns scope_violation error if directory not in allowed patterns.
Use request_scope_expansion to request access."
 (list '(:name "directory"
         :type string
         :description "Project root directory")
       '(:name "symbol"
         :type string
         :description "Symbol name to find")
       '(:name "limit"
         :type integer
         :optional t
         :description "Max results (default 50, max 200)"))
 "ggtags"
 (let ((default-directory directory)
       (file-limit (min (or limit 50) 200)))
   (condition-case err
       (let* ((cmd (ggtags-global-build-command 'symbol symbol))
              (output (shell-command-to-string cmd))
              (lines (split-string output "\n" t))
              (results (seq-take lines file-limit))
              (total (length lines)))
         (if (zerop total)
             (list :success t
                   :occurrences nil
                   :symbol symbol
                   :count 0
                   :message (format "Symbol '%s' not found anywhere in project.\n\nPossible reasons:\n1. Typo in symbol name\n2. Symbol doesn't exist\n3. Tags are stale - use update_ggtags_project(%s)"
                                    symbol directory))
           (let ((message-str (format "Found %d occurrence%s of '%s' (definitions + references):\n\n%s%s\n\nTip: Use find_definition for just definitions, or find_references for just usage."
                                      total
                                      (if (= total 1) "" "s")
                                      symbol
                                      (mapconcat #'identity results "\n")
                                      (if (> total file-limit)
                                          (format "\n\n[Truncated: showing %d of %d]" file-limit total)
                                        ""))))
             (list :success t
                   :occurrences results
                   :symbol symbol
                   :count total
                   :message (gptel-ggtags--result-limit message-str)))))
     (error (list :success nil
                  :error "find_symbol_error"
                  :message (format "Error finding symbol: %s" (error-message-string err)))))))
#+end_src

* Tag Database Management Tools

** create_ggtags_project
Create a new GTAGS database for semantic navigation.

#+begin_src emacs-lisp
(gptel-make-scoped-tool
 "create_ggtags_project"
 "SCOPE-AWARE: Requires directory to match allowed patterns.

Create a new ggtags tag database (GTAGS) in directory.

IMPORTANT: This operation can take time for large codebases (minutes for 100k+ files).
Small projects (< 1000 files) complete in seconds.

Creates these files in the project root:
- GTAGS: Definition database (where symbols are defined)
- GRTAGS: Reference database (where symbols are used)
- GPATH: Path name database (file locations)

The indexer:
- Respects .gitignore and VCS ignore rules
- Uses pygments parser (configured in this Emacs setup)
- Supports 300+ languages automatically
- Indexes function/class/variable definitions and references

Use this when:
- Starting work on a new codebase
- check_ggtags_project reports no GTAGS exists
- You need semantic navigation (go-to-definition, find-references)

After creation:
- Use find_definition to locate implementations
- Use find_references to see usage
- Use explain_ggtags_indexing to verify language support

Arguments:
- directory: Project root directory where GTAGS will be created

Returns: Success message with next steps, or error with troubleshooting guidance.

Note: Tags stay current automatically via git post-commit hooks (configured in gtags.org).
Manual updates: update_ggtags_project(directory)

Returns scope_violation error if directory not in allowed patterns.
Use request_scope_expansion to request access."
 (list '(:name "directory"
         :type string
         :description "Project root directory"))
 "ggtags"
 (let ((default-directory directory))
   (condition-case err
       (progn
         (ggtags-create-tags directory)
         (list :success t
               :gtags_created t
               :directory directory
               :message (format "Successfully created GTAGS database at %s\n\nCreated files:\n- GTAGS (definition database)\n- GRTAGS (reference database)\n- GPATH (path database)\n\nYou can now use:\n- find_definition(directory, symbol)\n- find_references(directory, symbol)\n- find_symbol(directory, symbol)\n\nIndexing respects .gitignore and uses pygments parser (300+ languages)."
                                directory)))
     (error (list :success nil
                  :error "create_gtags_error"
                  :message (format "Error creating GTAGS: %s\n\nCheck that:\n1. GNU Global is installed (gtags command available)\n2. Directory is writable\n3. Directory contains source files"
                                   (error-message-string err))))))
 t)
#+end_src

** update_ggtags_project
Update existing GTAGS database with recent changes.

#+begin_src emacs-lisp
(gptel-make-scoped-tool
 "update_ggtags_project"
 "SCOPE-AWARE: Requires directory to match allowed patterns.

Update the ggtags tag database with recent code changes.

Updates GTAGS to reflect changes in source files since last update.
Typically fast (seconds) because it's incremental by default.

Use this when:
- check_ggtags_project reports stale tags
- You've made code changes and searches return outdated results
- find_definition/find_references miss recently added symbols
- After pulling code changes from VCS

Update types:
- Incremental (default): Only reindex changed files (fast)
- Force rebuild (force=true): Reindex entire project (slower but thorough)

Arguments:
- directory: Project root directory (required)
- force: Force full rebuild instead of incremental (optional, default false)

Incremental updates use file modification times to detect changes.
Force rebuild useful if:
- Incremental updates seem broken
- Tag database is corrupted
- Major refactoring occurred

Note: Git post-commit hooks (configured in gtags.org) auto-update tags after commits.
This tool is for manual updates when hooks don't run or for uncommitted changes.

Returns: Success message indicating update type, or error with recovery suggestions.

Returns scope_violation error if directory not in allowed patterns.
Use request_scope_expansion to request access."
 (list '(:name "directory"
         :type string
         :description "Project root directory")
       '(:name "force"
         :type boolean
         :optional t
         :description "Force full rebuild (default: incremental)"))
 "ggtags"
 (let ((default-directory directory))
   (condition-case err
       (progn
         (if (not (file-exists-p (expand-file-name "GTAGS" directory)))
             (list :success nil
                   :error "no_gtags_found"
                   :message (format "No GTAGS database found at %s\n\nUse create_ggtags_project(%s) to create one first."
                                    directory directory))
           (progn
             (ggtags-update-tags force)
             (list :success t
                   :gtags_updated t
                   :directory directory
                   :update_type (if force "full" "incremental")
                   :message (format "Successfully updated GTAGS at %s\n\nUpdate type: %s\n\nTag database is now current with recent code changes.\n\nYou can now use find_definition, find_references with updated results."
                                    directory
                                    (if force "Full rebuild" "Incremental (changed files only)"))))))
     (error (list :success nil
                  :error "update_gtags_error"
                  :message (format "Error updating GTAGS: %s\n\nTry:\n1. Force full rebuild: update_ggtags_project(%s, true)\n2. Or recreate: create_ggtags_project(%s)"
                                   (error-message-string err) directory directory)))))
 t)
#+end_src

** explain_ggtags_indexing
Show how files are indexed (which parser for each file type).

#+begin_src emacs-lisp
(gptel-make-scoped-tool
 "explain_ggtags_indexing"
 "SCOPE-AWARE: Requires directory to match allowed patterns.

Explain how each file type is indexed in the project.

Shows which parser/indexer handles each file extension:
- pygments: Universal parser supporting 300+ languages (Python, JS, Ruby, Go, Rust, etc.)
- built-in: GNU Global native parsers (C, C++, Java, PHP, Yacc) - faster but fewer languages
- skip: Files not indexed (binaries, images, etc.)

Use this to:
- Understand what code can be navigated with find_definition/find_references
- Debug why certain files don't show up in searches
- Verify language support for your project
- See what file extensions are recognized

Your configuration (from gtags.org):
- Uses 'pygments' label for broad language support
- Respects .gitignore rules
- Enabled for Python and JavaScript modes

Arguments:
- directory: Project root directory (required)

Returns: Table/list of file extensions and their indexing method.

If a language you need shows 'skip':
1. Check if pygments supports it (likely yes for common languages)
2. Verify global/pygments installation
3. Check .gitignore isn't excluding those files

File types definitely supported:
Python, JavaScript, TypeScript, Ruby, Go, Rust, Java, C, C++, PHP,
Shell scripts, Perl, Lua, Haskell, Scala, and 280+ more via pygments.

Returns scope_violation error if directory not in allowed patterns.
Use request_scope_expansion to request access."
 (list '(:name "directory"
         :type string
         :description "Project root directory"))
 "ggtags"
 (let ((default-directory directory))
   (condition-case err
       (if (not (file-exists-p (expand-file-name "GTAGS" directory)))
           (list :success nil
                 :error "no_gtags_found"
                 :message (format "No GTAGS database at %s\n\nUse create_ggtags_project(%s) first."
                                  directory directory))
         (let* ((output (shell-command-to-string "global -h"))
                (message-str (format "Indexing Configuration for %s:\n\n%s\n\nParser types:\n- pygments: Universal parser (300+ languages) - PRIMARY\n- built-in: Native parsers (C, C++, Java, PHP, Yacc) - FAST\n- skip: Not indexed\n\nYour setup uses: pygments (configured in gtags.org)\n\nIf certain files aren't searchable:\n1. Check file extension in output above\n2. Verify .gitignore isn't excluding them\n3. Update tags: update_ggtags_project(%s)"
                                     directory output directory)))
           (list :success t
                 :directory directory
                 :configuration output
                 :message (gptel-ggtags--result-limit message-str))))
     (error (list :success nil
                  :error "explain_indexing_error"
                  :message (format "Error explaining indexing: %s" (error-message-string err)))))))
#+end_src

* Provide Feature
#+begin_src emacs-lisp
(provide 'ggtags-tools)
;;; ggtags-tools.el ends here
#+end_src
