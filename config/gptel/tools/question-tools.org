#+title: GPTEL Question Tools
#+property: header-args:emacs-lisp :tangle question-tools.el
#+auto_tangle: y

* File Header

#+begin_src emacs-lisp
;;; question-tools.el --- Async question tool for gptel -*- lexical-binding: t -*-
#+end_src

* Overview

This module implements an async gptel tool that allows LLMs (particularly the planner agent) to collect structured questions from users through an intuitive transient interface.

** Features
- Support for multiple question types (multiple-choice, yes/no, text, numeric)
- Optional comments on answers
- Progress tracking
- Validation of required fields
- Returns structured answers to LLM via callback
- Supports cancellation with partial answers

** Architecture
The tool uses transient for the UI and stores state in ~transient-scope~. When the LLM calls ~ask_questions~, a transient menu is displayed where the user can answer questions in any order. On submit or cancel, a callback is invoked with the collected answers.

* Data Structures

** Question Object (LLM ‚Üí Tool)
#+begin_src emacs-lisp
;; Example question plist:
;; (:id "question-1"                    ; Unique identifier (required)
;;  :type "multiple-choice"             ; Question type (required)
;;  :prompt "What is your goal?"        ; Question text (required)
;;  :description "Optional context"     ; Additional detail (optional)
;;  :required t                         ; Whether answer required (default: t)
;;  :default "value"                    ; Default value (optional)
;;  :choices ("Option A" "Option B")    ; For multiple-choice (required if type=multiple-choice)
;;  :min 0                              ; For numeric (optional)
;;  :max 100)                           ; For numeric (optional)
#+end_src

** Answer Object (Tool ‚Üí LLM)
#+begin_src emacs-lisp
;; Example answer plist returned to LLM:
;; (:id "question-1"                    ; Question identifier
;;  :answer "Option A"                  ; User's answer value
;;  :comment "My reasoning here"        ; Optional user comment
;;  :skipped nil)                       ; Whether skipped (if not required)
#+end_src

** Transient Scope Structure
#+begin_src emacs-lisp
;; Scope structure stored in transient:
;; (:questions (list ...)               ; Original questions from LLM
;;  :answers (hash-table)               ; ID ‚Üí answer value mapping
;;  :comments (hash-table)              ; ID ‚Üí comment string mapping
;;  :current-question "question-1")    ; Currently selected (for future nav features)
;;
;; NOTE: Callback is NOT stored in scope to avoid serialization issues.
;;       It's stored in buffer-local variable jf/gptel-questions--callback
#+end_src

* Helper Functions

** Callback Storage

#+begin_src emacs-lisp
(defvar-local jf/gptel-questions--callback nil
  "Buffer-local storage for async tool callback.
Stored outside transient scope to avoid serialization issues.")

(defvar-local jf/gptel-questions--origin-buffer nil
  "Buffer where the tool was originally invoked.
Callback must be invoked in this buffer to access FSM state.")
#+end_src

** Answer Storage and Retrieval

#+begin_src emacs-lisp
(defun jf/gptel-questions--answer-question (question-id answer)
  "Store ANSWER for QUESTION-ID in current scope."
  (let* ((scope (transient-scope))
         (answers (plist-get scope :answers)))
    (puthash question-id answer answers)))

(defun jf/gptel-questions--set-comment (question-id comment)
  "Store COMMENT for QUESTION-ID in current scope."
  (let* ((scope (transient-scope))
         (comments (plist-get scope :comments)))
    (puthash question-id comment comments)))

(defun jf/gptel-questions--get-answer (question-id)
  "Get current answer for QUESTION-ID from scope."
  (let* ((scope (transient-scope))
         (answers (plist-get scope :answers)))
    (gethash question-id answers)))

(defun jf/gptel-questions--get-comment (question-id)
  "Get current comment for QUESTION-ID from scope."
  (let* ((scope (transient-scope))
         (comments (plist-get scope :comments)))
    (gethash question-id comments)))

(defun jf/gptel-questions--is-answered-p (question-id)
  "Check if QUESTION-ID has been answered."
  (let ((answer (jf/gptel-questions--get-answer question-id)))
    (not (null answer))))
#+end_src

** Question Normalization

#+begin_src emacs-lisp
(defun jf/gptel-questions--normalize-question (question)
  "Normalize QUESTION plist from LLM into expected Emacs format.
Handles vector-to-list conversion and type coercion.
Returns normalized question or signals error with clear message."
  (let* ((id (plist-get question :id))
         (type (plist-get question :type))
         (prompt (plist-get question :prompt))
         (description (plist-get question :description))
         (required (plist-get question :required))
         (default (plist-get question :default))
         (choices-raw (plist-get question :choices))
         (min (plist-get question :min))
         (max (plist-get question :max)))

    ;; Validate required fields
    (unless id
      (error "Question missing required field: :id"))
    (unless type
      (error "Question %s missing required field: :type" id))
    (unless prompt
      (error "Question %s missing required field: :prompt" id))

    ;; Validate question type
    (unless (member type '("multiple-choice" "yes-no" "text" "numeric"))
      (error "Question %s has invalid type: %s (must be one of: multiple-choice, yes-no, text, numeric)" id type))

    ;; Type-specific validation and normalization
    (when (string= type "multiple-choice")
      (unless choices-raw
        (error "Question %s is multiple-choice but missing :choices field" id))

      ;; Convert vector to list if needed
      (let ((choices (if (vectorp choices-raw)
                         (append choices-raw nil)
                       choices-raw)))
        (unless (and (listp choices) (> (length choices) 0))
          (error "Question %s :choices must be non-empty array/list, got: %S" id choices-raw))

        ;; Ensure all choices are strings
        (setq choices (mapcar (lambda (c)
                                (if (stringp c)
                                    c
                                  (format "%s" c)))
                              choices))

        ;; Update question with normalized choices
        (setq question (plist-put question :choices choices))))

    (when (string= type "numeric")
      ;; Ensure min/max are numbers if provided
      (when min
        (unless (numberp min)
          (error "Question %s :min must be a number, got: %S" id min)))
      (when max
        (unless (numberp max)
          (error "Question %s :max must be a number, got: %S" id max))))

    ;; Normalize required field to boolean
    ;; Handle JSON false (represented as :json-false)
    (let ((required-normalized
           (cond
            ((eq required :json-false) nil)
            ((null required) t)  ; default to required
            (t (not (null required))))))
      (setq question (plist-put question :required required-normalized)))

    ;; Ensure string fields are strings
    (when description
      (unless (stringp description)
        (setq question (plist-put question :description (format "%s" description)))))
    (when default
      (unless (stringp default)
        (setq question (plist-put question :default (format "%s" default)))))

    question))

(defun jf/gptel-questions--normalize-questions (questions)
  "Normalize QUESTIONS array from LLM.
Converts vectors to lists and validates each question.
Returns list of normalized question plists."
  ;; Convert top-level array
  (let ((questions-list (if (vectorp questions)
                            (append questions nil)
                          questions)))

    (unless (listp questions-list)
      (error "Questions must be an array/list, got: %S" questions))

    (when (= (length questions-list) 0)
      (error "Questions array is empty"))

    ;; Normalize each question
    (mapcar #'jf/gptel-questions--normalize-question questions-list)))
#+end_src

** Validation

#+begin_src emacs-lisp
(defun jf/gptel-questions--validate-answers ()
  "Check if all required questions are answered.
Returns (valid-p . error-message)."
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (unanswered-required '()))

    (dolist (q questions)
      (let ((id (plist-get q :id))
            (required (if (plist-member q :required)
                          (plist-get q :required)
                        t)))  ; default to required
        (when (and required
                   (not (jf/gptel-questions--is-answered-p id)))
          (push (plist-get q :prompt) unanswered-required))))

    (if unanswered-required
        (cons nil (format "Required questions unanswered: %s"
                         (string-join (nreverse unanswered-required) ", ")))
      (cons t nil))))
#+end_src

** Answer List Builder

#+begin_src emacs-lisp
(defun jf/gptel-questions--build-answer-list ()
  "Build answer list from current state for callback.
Returns JSON-encoded string for LLM consumption."
  (require 'json)
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (answers-hash (plist-get scope :answers))
         (comments-hash (plist-get scope :comments))
         (answer-list '()))

    (dolist (q questions)
      (let* ((id (plist-get q :id))
             (answer (gethash id answers-hash))
             (comment (gethash id comments-hash))
             (skipped (null answer)))
        ;; Use alist format for proper JSON encoding
        (push `((id . ,id)
                (answer . ,(or answer ""))
                (comment . ,(or comment ""))
                (skipped . ,skipped))
              answer-list)))

    ;; Encode as JSON string for gptel tool result serialization
    (json-encode (nreverse answer-list))))
#+end_src

** Comment Management

#+begin_src emacs-lisp
(defun jf/gptel-questions--add-or-edit-comment ()
  "Interactively select a question and add/edit its comment."
  (interactive)
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (choices (mapcar (lambda (q)
                           (let* ((id (plist-get q :id))
                                  (prompt (plist-get q :prompt))
                                  (has-comment (not (string-empty-p
                                                    (jf/gptel-questions--get-comment id))))
                                  (indicator (if has-comment "üí¨ " "")))
                             (cons (format "%s%s" indicator prompt) id)))
                         questions))
         (selection (completing-read "Add/edit comment for: " choices nil t))
         (question-id (cdr (assoc selection choices))))

    (when question-id
      (let* ((current-comment (jf/gptel-questions--get-comment question-id))
             (new-comment (read-string "Comment: " current-comment)))
        (jf/gptel-questions--set-comment question-id new-comment)
        (message "Comment saved for: %s" selection)))))
#+end_src

** Formatting Functions

#+begin_src emacs-lisp
(defun jf/gptel-questions--format-question (question key)
  "Format QUESTION for display in transient menu with KEY binding."
  (let* ((prompt (plist-get question :prompt))
         (required (if (plist-member question :required)
                       (plist-get question :required)
                     t))
         (id (plist-get question :id))
         (answered (jf/gptel-questions--is-answered-p id))
         (answer (jf/gptel-questions--get-answer id))
         (comment (jf/gptel-questions--get-comment id))
         (has-comment (and comment (not (string-empty-p comment))))
         (indicator (cond
                     (answered (propertize "‚úì" 'face 'success))
                     (required (propertize "‚óè" 'face 'error))
                     (t (propertize "‚óã" 'face 'transient-inactive-value))))
         (comment-indicator (if has-comment
                                (propertize " üí¨" 'face 'transient-value)
                              ""))
         (key-str (propertize (format "[%s]" key) 'face 'transient-key)))

    (format "%s %s %s%s%s"
            key-str
            indicator
            prompt
            (if answered
                (propertize (format " ‚Üí %s" answer) 'face 'transient-value)
              "")
            comment-indicator)))

(defun jf/gptel-questions--progress-info ()
  "Generate progress indicator string."
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (total (length questions))
         (answered (cl-count-if
                    (lambda (q)
                      (jf/gptel-questions--is-answered-p (plist-get q :id)))
                    questions))
         (face (if (= answered total) 'success 'transient-value)))
    (propertize (format "Progress: %d/%d answered" answered total)
                'face face)))
#+end_src

** Submission and Cancellation

#+begin_src emacs-lisp
(defun jf/gptel-questions--submit ()
  "Validate and submit answers."
  (interactive)
  (let ((validation (jf/gptel-questions--validate-answers)))
    (if (car validation)
        ;; Build answer JSON from scope before quitting
        (let* ((answer-json (jf/gptel-questions--build-answer-list))
               (callback jf/gptel-questions--callback)
               (origin-buffer jf/gptel-questions--origin-buffer))

          ;; Close transient FIRST to clean up state
          (transient-quit-one)

          ;; THEN invoke callback via timer (after transient cleanup completes)
          ;; Timer ensures transient state doesn't interfere with callback
          (message "=== SUBMIT CALLBACK ===")
          (message "Origin: %s" origin-buffer)
          (message "Answers: %s" answer-json)

          (run-at-time
           0.05 nil
           (lambda ()
             (condition-case err
                 (with-current-buffer origin-buffer
                   (message "‚Üí In origin buffer (mode: %s, gptel--fsm: %s)"
                            major-mode (boundp 'gptel--fsm))
                   (when (boundp 'gptel--fsm)
                     (message "‚Üí FSM state: %s" (plist-get gptel--fsm :state)))

                   (message "‚Üí About to funcall callback...")
                   (funcall callback answer-json)
                   (message "‚Üí Callback returned")

                   (when (boundp 'gptel--fsm)
                     (message "‚Üí FSM state after: %s" (plist-get gptel--fsm :state))))
               (error
                (message "‚Üí ERROR: %s" (error-message-string err))
                (message "‚Üí Error details: %S" err))))))

      ;; Validation failed
      (message "%s" (cdr validation)))))

(defun jf/gptel-questions--cancel ()
  "Cancel and return partial answers to LLM."
  (interactive)
  ;; Build answer JSON from scope before quitting
  (let* ((answer-json (jf/gptel-questions--build-answer-list))
         (callback jf/gptel-questions--callback)
         (origin-buffer jf/gptel-questions--origin-buffer))

    ;; Close transient FIRST
    (transient-quit-one)

    ;; THEN invoke callback via timer
    (message "=== CANCEL CALLBACK ===")
    (message "Origin: %s (partial answers: %s)" origin-buffer answer-json)

    (run-at-time
     0.05 nil
     (lambda ()
       (condition-case err
           (with-current-buffer origin-buffer
             (message "‚Üí In origin (gptel--fsm: %s)" (boundp 'gptel--fsm))
             (when (boundp 'gptel--fsm)
               (message "‚Üí FSM state: %s" (plist-get gptel--fsm :state)))

             (funcall callback answer-json)
             (message "‚Üí Callback returned")

             (when (boundp 'gptel--fsm)
               (message "‚Üí FSM state after: %s" (plist-get gptel--fsm :state))))
         (error
          (message "‚Üí ERROR: %s" (error-message-string err))))))))
#+end_src

* Custom Transient Classes

** Question Infix Class

#+begin_src emacs-lisp
(defclass jf/gptel-question-infix (transient-infix)
  ((question :initarg :question))
  "Infix class for question answering.")
#+end_src

** Read Method (Type-Specific Input)

#+begin_src emacs-lisp
(cl-defmethod transient-infix-read ((obj jf/gptel-question-infix))
  "Read answer for question OBJ based on question type."
  (let* ((q (oref obj question))
         (q-type (plist-get q :type))
         (q-id (plist-get q :id))
         (prompt (plist-get q :prompt))
         (default (plist-get q :default))
         (current (jf/gptel-questions--get-answer q-id)))

    (pcase q-type
      ("multiple-choice"
       (let ((choices (plist-get q :choices)))
         (completing-read (format "%s: " prompt)
                         choices nil t (or current default))))

      ("yes-no"
       (if (y-or-n-p (format "%s " prompt)) "yes" "no"))

      ("text"
       (read-string (format "%s: " prompt) (or current default)))

      ("numeric"
       (let* ((min (plist-get q :min))
              (max (plist-get q :max))
              (default-val (or (and current (string-to-number current))
                              default
                              0))
              (input (read-number (format "%s: " prompt) default-val)))
         (when (and min (< input min))
           (error "Value must be at least %d" min))
         (when (and max (> input max))
           (error "Value must be at most %d" max))
         (number-to-string input)))

      (_ (error "Unknown question type: %s" q-type)))))
#+end_src

** Set Method

#+begin_src emacs-lisp
(cl-defmethod transient-infix-set ((obj jf/gptel-question-infix) value)
  "Set VALUE as answer for question OBJ."
  (let ((q-id (plist-get (oref obj question) :id)))
    (jf/gptel-questions--answer-question q-id value)
    (oset obj value value)))
#+end_src

** Format Method

#+begin_src emacs-lisp
(cl-defmethod transient-format ((obj jf/gptel-question-infix))
  "Format question and answer for display."
  (let* ((q (oref obj question))
         (key (oref obj key))
         (formatted (jf/gptel-questions--format-question q key)))
    (format "  %s" formatted)))
#+end_src

* Transient Menu

** Key Pool Generation

#+begin_src emacs-lisp
(defun jf/gptel-questions--generate-key-pool (count)
  "Generate COUNT key bindings for questions.
Uses single letters (a-z) for first 26, then two-letter combinations (aa-zz)."
  (let ((keys '())
        (letters "abcdefghijklmnopqrstuvwxyz"))
    ;; Single letters: a-z (26 keys)
    (dotimes (i (min count 26))
      (push (substring letters i (1+ i)) keys))

    ;; Two letters: aa-zz (676 more keys if needed)
    (when (> count 26)
      (dotimes (i (min (- count 26) 676))
        (let ((first (/ i 26))
              (second (mod i 26)))
          (push (format "%c%c"
                        (aref letters first)
                        (aref letters second))
                keys))))

    (nreverse keys)))
#+end_src

** Dynamic Suffix Generation

#+begin_src emacs-lisp
(defun jf/gptel-questions--setup-question-suffixes (_)
  "Generate transient suffixes for each question."
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (key-pool (jf/gptel-questions--generate-key-pool (length questions))))

    (transient-parse-suffixes
     'jf/gptel-questions-menu
     (cl-loop for q in questions
              for key in key-pool
              collect
              (list key
                    ""  ; Description computed dynamically by transient-format
                    (plist-get q :id)  ; Use question ID as the argument
                    :class 'jf/gptel-question-infix
                    :question q)))))
#+end_src

** Main Prefix

#+begin_src emacs-lisp
(transient-define-prefix jf/gptel-questions-menu ()
  "Answer questions from LLM agent."
  :refresh-suffixes t

  ;; Top section: Info and actions
  [:description "Answer Questions"
   [""
    (:info (lambda () (jf/gptel-questions--progress-info)))]
   [""
    ("RET" "Submit answers" jf/gptel-questions--submit)
    ("C" "Add/edit comment" jf/gptel-questions--add-or-edit-comment
     :transient t)
    ("q" "Cancel (send partial)" jf/gptel-questions--cancel)]]

  ;; Questions section: dynamically generated
  [[:class transient-column
    :setup-children jf/gptel-questions--setup-question-suffixes]])
#+end_src

* Tool Definition

** Tool Entry Point

#+begin_src emacs-lisp
(defun jf/gptel-questions--ask (callback questions)
  "Async tool function. Display questions UI and invoke CALLBACK with answers.
QUESTIONS is array of question plists from LLM.

Normalizes and validates questions before displaying UI.
Signals clear errors if questions are malformed."
  (message "=== TOOL INVOCATION START ===")
  (message "Entry buffer: %s (mode: %s)" (current-buffer) major-mode)
  (message "gptel--fsm bound: %s" (boundp 'gptel--fsm))
  (when (boundp 'gptel--fsm)
    (message "FSM state: %s" (plist-get gptel--fsm :state)))

  (condition-case err
      (let* ((origin-buffer (current-buffer))  ; Capture IMMEDIATELY
             ;; Normalize and validate questions
             (questions-list (jf/gptel-questions--normalize-questions questions))
             (answers (make-hash-table :test 'equal))
             (comments (make-hash-table :test 'equal)))

        (message "‚Üí Captured origin: %s" origin-buffer)

        ;; Initialize hash tables
        (dolist (q questions-list)
          (puthash (plist-get q :id) nil answers)
          (puthash (plist-get q :id) "" comments))

        ;; Store callback and origin buffer in buffer-local variables (NOT in transient scope)
        ;; This avoids serialization issues when gptel tries to serialize state
        ;; Origin buffer needed so callback can access FSM state
        ;; CRITICAL: Use captured origin-buffer, not (current-buffer) which may have changed
        (setq-local jf/gptel-questions--callback callback)
        (setq-local jf/gptel-questions--origin-buffer origin-buffer)
        (message "‚Üí Stored callback in: %s" (current-buffer))

        ;; Launch transient with scope (callback and origin buffer NOT included)
        (transient-setup
         'jf/gptel-questions-menu
         nil nil
         :scope (list :questions questions-list
                      :answers answers
                      :comments comments
                      :current-question (plist-get (car questions-list) :id))))

    ;; Handle errors gracefully - provide structured feedback to LLM
    (error
     (require 'json)
     (let ((error-msg (error-message-string err)))
       (message "Error in ask_questions tool: %s" error-msg)
       (message "This is likely due to malformed question structure from LLM")
       (message "Questions received: %S" questions)
       ;; Return validation error to LLM as JSON string so it can correct the tool call
       ;; Use alist format for proper JSON encoding
       (funcall callback
                (json-encode
                 (list `((error . t)
                        (error_type . "validation_error")
                        (error_message . ,error-msg)
                        (hint . "Check that all questions have required fields (:id, :type, :prompt), :type is valid (multiple-choice/yes-no/text/numeric), and multiple-choice questions include :choices array")))))))))
#+end_src

** Tool Registration

#+begin_src emacs-lisp
(gptel-make-tool
 :name "ask_questions"
 :function #'jf/gptel-questions--ask

 :description "Ask user structured questions and collect answers interactively.

Present multiple questions in an interactive menu where user can:
- Answer in any order
- Add optional comments/notes to answers
- See progress (answered vs total)
- Review and change answers before submission
- Submit when ready or cancel to return partial answers

Question types supported:
- multiple-choice: User selects from predefined choices list
- yes-no: Simple yes/no question
- text: Free-form text input
- numeric: Numeric input with optional min/max validation

Use this when you need user input to refine your plan or make decisions.
For example, ask about goals, constraints, preferences, or technical choices."

 :args '((:name "questions"
          :type "array"
          :items (:type "object"
                  :properties (:id (:type "string"
                                   :description "Unique question identifier")
                              :type (:type "string"
                                    :enum ["multiple-choice" "yes-no" "text" "numeric"]
                                    :description "Question type")
                              :prompt (:type "string"
                                      :description "Question text to display")
                              :description (:type "string"
                                           :description "Optional additional context")
                              :required (:type "boolean"
                                        :description "Whether answer is required (default: true)")
                              :default (:type "string"
                                       :description "Default answer value")
                              :choices (:type "array"
                                       :items (:type "string")
                                       :description "For multiple-choice: list of options")
                              :min (:type "number"
                                   :description "For numeric: minimum value")
                              :max (:type "number"
                                   :description "For numeric: maximum value")))
          :description "Array of question objects to ask user"))

 :category "interaction"
 :async t
 :confirm nil)
#+end_src

* Testing Utilities

** Manual Test Cases

These functions can be used to manually test the question tool.

#+begin_src emacs-lisp
(defun jf/gptel-questions-test-basic ()
  "Test basic functionality with text, yes-no, and multiple-choice."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json)
     (message "Parsed: %S" (json-read-from-string answers-json)))
   '((:id "test1" :type "text" :prompt "Your name?" :required t)
     (:id "test2" :type "yes-no" :prompt "Proceed?")
     (:id "test3" :type "multiple-choice"
      :prompt "Choose color"
      :choices ("Red" "Blue" "Green")))))

(defun jf/gptel-questions-test-numeric ()
  "Test numeric validation with min/max."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   '((:id "age" :type "numeric" :prompt "Age?" :min 0 :max 120 :required t))))

(defun jf/gptel-questions-test-optional ()
  "Test optional fields with defaults."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   '((:id "opt1" :type "text" :prompt "Optional field"
      :required nil :default "Default value"))))

(defun jf/gptel-questions-test-large ()
  "Test with 15 questions to verify scrolling."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (let ((answers (json-read-from-string answers-json)))
       (message "Got %d answers" (length answers))))
   (cl-loop for i from 1 to 15
            collect (list :id (format "q%d" i)
                         :type "text"
                         :prompt (format "Question %d?" i)
                         :required nil))))

(defun jf/gptel-questions-test-realistic ()
  "Test with realistic planning scenario questions."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (let ((answers (json-read-from-string answers-json)))
       (message "Planner received %d answers" (length answers))
       (dolist (a answers)
         (let-alist a
           (message "  %s: %s%s"
                    .id
                    .answer
                    (if (string-empty-p .comment)
                        ""
                      (format " [%s]" .comment)))))))
   '((:id "primary_goal"
      :type "multiple-choice"
      :prompt "What is your primary goal for this feature?"
      :description "This helps me prioritize design trade-offs"
      :choices ("Performance" "Readability" "Maintainability" "Simplicity")
      :required t)
     (:id "refactor_existing"
      :type "yes-no"
      :prompt "Should I refactor existing code or leave it as-is?"
      :required t)
     (:id "deadline"
      :type "text"
      :prompt "When do you need this completed?"
      :required nil
      :default "No specific deadline")
     (:id "complexity_tolerance"
      :type "numeric"
      :prompt "Complexity tolerance (1=simple, 10=complex)"
      :description "Higher values mean more sophisticated solutions"
      :min 1
      :max 10
      :default "5"
      :required nil))))
#+end_src

** Robustness Tests

#+begin_src emacs-lisp
(defun jf/gptel-questions-test-vector-choices ()
  "Test that vector choices (from LLM JSON) work correctly."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   ;; Simulate JSON array as vector
   [(:id "test1" :type "multiple-choice"
     :prompt "Choose option"
     :choices ["Option A" "Option B" "Option C"]  ; Vector, not list
     :required t)]))

(defun jf/gptel-questions-test-json-false ()
  "Test that :json-false for required field works correctly."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   [(:id "test1" :type "text"
     :prompt "Optional field"
     :required :json-false)]))  ; JSON false becomes :json-false

(defun jf/gptel-questions-test-malformed ()
  "Test error handling for malformed questions."
  (interactive)
  ;; Missing :id
  (condition-case err
      (jf/gptel-questions--ask
       (lambda (answers) (message "Should not reach here"))
       [(:type "text" :prompt "No ID")])
    (error (message "Correctly caught error: %s" (error-message-string err))))

  ;; Missing :type
  (condition-case err
      (jf/gptel-questions--ask
       (lambda (answers) (message "Should not reach here"))
       [(:id "test" :prompt "No type")])
    (error (message "Correctly caught error: %s" (error-message-string err))))

  ;; Multiple-choice without choices
  (condition-case err
      (jf/gptel-questions--ask
       (lambda (answers) (message "Should not reach here"))
       [(:id "test" :type "multiple-choice" :prompt "No choices")])
    (error (message "Correctly caught error: %s" (error-message-string err)))))

(defun jf/gptel-questions-test-type-coercion ()
  "Test that non-string values get coerced to strings."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   [(:id "test1" :type "multiple-choice"
     :prompt "Choose number"
     :choices [1 2 3]  ; Numbers, should be coerced to strings
     :required t)
    (:id "test2" :type "text"
     :prompt "Text field"
     :default 42)]))  ; Number default, should be coerced

(defun jf/gptel-questions-test-error-feedback ()
  "Test that validation errors are returned to LLM callback in structured format."
  (interactive)
  ;; This simulates what the LLM would receive when providing malformed questions
  (jf/gptel-questions--ask
   (lambda (result-json)
     (let ((result (json-read-from-string result-json)))
       (if (alist-get 'error (elt result 0))
           (let-alist (elt result 0)
             (message "LLM received validation error:")
             (message "  Error type: %s" .error_type)
             (message "  Error message: %s" .error_message)
             (message "  Hint: %s" .hint))
         (message "LLM received valid answers: %S" result))))
   ;; Invalid question: missing :type field
   [(:id "test" :prompt "Question without type field")]))
#+end_src

* Implementation Notes and Known Issues

** Background

This async gptel tool uses transient for UI and must integrate with gptel's FSM (finite state machine) for tool execution. The implementation faced several challenges due to the interaction between transient's scope management and gptel's request serialization.

** Challenge 1: Data Structure Serialization

*** Problem
When returning tool results to the LLM, gptel serializes the request context (including tool results) to send to the API. Initial implementations encountered errors:

#+begin_example
(wrong-type-argument symbolp "User documentation (how-to guides, tutorials)")
#+end_example

*** Root Cause
Emacs ~json-encode~ doesn't handle plists correctly - it treats them as flat arrays instead of objects:

#+begin_src emacs-lisp :tangle no
;; This plist:
'(:id "test" :answer "foo")

;; Gets encoded as:
{"id": ["test", "answer", "foo"]}  ; Wrong!

;; Instead of:
{"id": "test", "answer": "foo"}    ; Correct
#+end_src

*** Solution
Convert to alists before JSON encoding:

#+begin_src emacs-lisp :tangle no
;; Use alist format for proper JSON encoding
`((id . ,id)
  (answer . ,(or answer ""))
  (comment . ,(or comment ""))
  (skipped . ,skipped))
#+end_src

** Challenge 2: Callback in Transient Scope

*** Problem
Initially stored the callback function in the transient scope:

#+begin_src emacs-lisp :tangle no
:scope (list :questions questions-list
             :answers answers
             :comments comments
             :callback callback)  ; PROBLEM: callback in scope
#+end_src

This caused serialization errors because when gptel tried to serialize the request context after the tool completed, it encountered the transient scope data (including question choices, hash tables, etc.) embedded in the callback's closure.

Error: ~(wrong-type-argument symbolp "Code implementation or refactoring")~

*** Root Cause
The callback is a closure that captures gptel's request context. When we stored it in the transient scope, we created a circular reference or unexpected data structure that gptel's serialization couldn't handle. Specifically:

1. Callback captures gptel request info (including buffer, position, data)
2. We stored callback in transient scope
3. Transient scope contains all our UI data (questions with choice arrays, hash tables)
4. When tool completes, gptel tries to serialize context to send results back
5. Serialization encounters transient scope data where it expects simple values

*** Solution
Store callback in buffer-local variable **outside** transient scope:

#+begin_src emacs-lisp :tangle no
;; Store callback separately
(setq-local jf/gptel-questions--callback callback)

;; Don't include in scope
:scope (list :questions questions-list
             :answers answers
             :comments comments)  ; callback NOT here
#+end_src

** Challenge 3: Callback Invocation and FSM Continuation (IN PROGRESS)

*** Problem Evolution

**** Issue 1: Closure Scoping (SOLVED)
Initial implementation failed with ~(void-variable hook-fn)~ errors.

**Root cause:** Missing ~lexical-binding: t~ header in tangled .el file.
- Without lexical binding, Emacs uses dynamic scoping
- Closures cannot capture variables from enclosing scope
- Self-referential lambdas (hooks that remove themselves) fail

**Solution:** Added file header ~;;; -*- lexical-binding: t -*-~ to enable lexical closures.

**** Issue 2: FSM Not Continuing (CURRENT)
Tool UI works, callback is invoked, tool results appear in buffer, but LLM doesn't respond.

**Observable behavior:**
- Transient menu appears ‚úì
- User can answer questions ‚úì
- Submit triggers post-command hook ‚úì
- Callback is invoked ‚úì
- Tool result appears in gptel buffer ‚úì
- FSM does NOT continue to send results back to LLM ‚úó

**Example tool result visible in buffer:**
#+begin_example
[{"id":"task_type","answer":"Debug or fix an issue","comment":"","skipped":null}]
#+end_example

**What should happen next (but doesn't):**
1. Tool result stored in FSM state
2. GPtel makes follow-up API request with tool results
3. LLM responds with final answer incorporating user's answers

*** Current Hypothesis: Buffer Context Issue

The ~process-tool-result~ closure (callback parameter) likely requires execution in the
**originating gptel buffer context** to properly access FSM state and trigger transitions.

**Current implementation problem:**
1. Tool invoked in gptel buffer A
2. Callback stored as buffer-local variable in buffer A
3. Transient may run in buffer A or separate buffer
4. Post-command hook runs in *current buffer* (wherever transient quit)
5. Callback invoked without ensuring we're in buffer A
6. Callback cannot access buffer-local FSM state ‚Üí FSM doesn't transition

**Supporting evidence:**
- Working async tool (~persistent-agent~) invokes callback from within gptel's own
  callback infrastructure, which manages buffer context automatically
- Our tool invokes callback from user command context after transient cleanup
- GPtel FSM state is buffer-local in the originating gptel buffer

*** Proposed Solution: Buffer Context Preservation

Store originating buffer and restore context before invoking callback:

#+begin_src emacs-lisp :tangle no
;; In jf/gptel-questions--ask:
(setq-local jf/gptel-questions--callback callback)
(setq-local jf/gptel-questions--origin-buffer (current-buffer))  ; NEW

;; In jf/gptel-questions--submit:
(let ((answer-json (jf/gptel-questions--build-answer-list))
      (callback jf/gptel-questions--callback)
      (origin-buffer jf/gptel-questions--origin-buffer))  ; NEW

  (transient-quit-one)

  (let (hook-fn)
    (setq hook-fn
          (lambda ()
            (remove-hook 'post-command-hook hook-fn)
            (condition-case err
                (progn
                  (message "Invoking callback with: %s" answer-json)
                  ;; NEW: Invoke in originating buffer context
                  (with-current-buffer origin-buffer
                    (funcall callback answer-json)))
              (error
               (message "Error in callback: %s" (error-message-string err))
               (message "Answer JSON was: %s" answer-json)))))
    (add-hook 'post-command-hook hook-fn)))
#+end_src

*** Research Questions

To validate hypothesis and solution:

1. **Which buffer is current when callback executes?**
   - Add debug logging: ~(message "Callback buffer: %s" (current-buffer))~
   - Compare to originating gptel buffer name

2. **Does gptel FSM state exist in callback buffer?**
   - Check buffer-local variables related to gptel requests/FSM
   - Look for ~gptel--*~ buffer-local variables

3. **What does ~process-tool-result~ closure expect?**
   - Examine ~gptel-request.el:1700-1713~ to understand closure implementation
   - What buffer-local state does it access?
   - Does it call ~gptel--fsm-transition~ directly or schedule it?

4. **Does ~persistent-agent~ tool handle buffer context explicitly?**
   - Review ~config/gptel/tools/persistent-agent.el:220-272~
   - How does it ensure callback runs in correct buffer?

5. **Can we trace FSM transitions?**
   - Enable ~(setq gptel-log-level 'debug)~
   - Look for FSM state changes in ~*gptel-log*~ buffer
   - Expected: TOOL ‚Üí WAIT ‚Üí (should see follow-up request)
   - Actual: TOOL ‚Üí nothing

*** Debugging Steps

#+begin_src emacs-lisp :tangle no
;; 1. Enable gptel debug logging
(setq gptel-log-level 'debug)

;; 2. Add buffer context logging to submit function
(defun jf/gptel-questions--submit ()
  "Validate and submit answers."
  (interactive)
  (let ((validation (jf/gptel-questions--validate-answers)))
    (if (car validation)
        (let* ((answer-json (jf/gptel-questions--build-answer-list))
               (callback jf/gptel-questions--callback)
               (origin-buffer (current-buffer)))  ; Capture current buffer

          (message "Origin buffer: %s" origin-buffer)  ; DEBUG

          (transient-quit-one)

          (let (hook-fn)
            (setq hook-fn
                  (lambda ()
                    (remove-hook 'post-command-hook hook-fn)
                    (message "Callback buffer: %s" (current-buffer))  ; DEBUG
                    (message "Origin buffer: %s" origin-buffer)       ; DEBUG
                    (condition-case err
                        (progn
                          (message "Invoking callback with: %s" answer-json)
                          (funcall callback answer-json))
                      (error
                       (message "Error in callback: %s" (error-message-string err))
                       (message "Answer JSON was: %s" answer-json)))))
            (add-hook 'post-command-hook hook-fn)))

      (message "%s" (cdr validation)))))

;; 3. Test and check *Messages* buffer for:
;;    - "Origin buffer: *gptel*"
;;    - "Callback buffer: *gptel*" or different?

;; 4. Check *gptel-log* buffer for FSM transitions after tool result
#+end_src

*** Files to Study

- ~gptel-request.el:1700-1713~ - ~process-tool-result~ closure implementation
- ~gptel-request.el:1564-1582~ - FSM transition table and state machine
- ~gptel-request.el:1679-1747~ - ~gptel--handle-tool-use~ (async tool execution)
- ~config/gptel/tools/persistent-agent.el:220-272~ - Working async tool for comparison

*** Key Architectural Insights

1. **Lexical binding is mandatory** for closures to work correctly in Elisp
2. **Post-command hooks run in current buffer** - not guaranteed to be originating buffer
3. **GPtel FSM state is buffer-local** - callbacks must execute in correct buffer context
4. **Async tool callbacks** are ~process-tool-result~ closures that manage FSM state
5. **Transient cleanup** must complete before FSM operations (confirmed working)

*** Current Status

- ‚úì Tool UI fully functional
- ‚úì Question answering and validation working
- ‚úì JSON serialization working
- ‚úì Callback storage outside transient scope working
- ‚úì Lexical binding enabled
- ‚úì Post-command hook pattern working (callback invokes)
- ‚úó FSM continuation failing (no follow-up LLM request)

**Next step:** Implement buffer context preservation and test hypothesis.

*** Debugging Session: January 2026 - FSM Integration Attempts

**** Problem Statement

After implementing buffer context preservation and callback invocation, the tool still fails
to continue the GPtel conversation after returning results. The conversation stops after the
tool result is captured.

**** Key Observations

**1. FSM Not Present in Buffer**

~gptel--fsm~ is consistently ~nil~ in the session.md buffer when the tool is invoked:

#+begin_example
=== TOOL INVOCATION START ===
Entry buffer: session.md (mode: markdown-mode)
gptel--fsm bound: nil
#+end_example

However, examining the callback structure reveals the FSM IS embedded in the callback closure
as the last element: ~#s(gptel-fsm TOOL ...)~

This suggests gptel does NOT use a buffer-local FSM variable, but rather passes FSM state
through callback closures.

**2. Error Shows Choice Strings, Not User Answers**

Critical observation: The error message references strings from the question's ~:choices~ array,
NOT the user's selected answer:

#+begin_example
User selected: "Summer - Warm weather and long days"
Error message: Wrong type argument: symbolp, "Spring - Fresh beginnings and flowers blooming"
#+end_example

"Spring" is a choice from the ~:choices~ array, not the answer. This indicates the error occurs
when GPtel processes the ORIGINAL tool call arguments (the question definition), not when
processing the tool RESULT (the user's answer).

**3. Tool Schema Type Issue**

Initial tool schema used symbol types instead of string types:

#+begin_src emacs-lisp :tangle no
;; WRONG - causes type errors
:args '((:name "questions"
         :type array          ; Should be "array"
         :items (:type object ; Should be "object"
#+end_src

Fixed to use string types:

#+begin_src emacs-lisp :tangle no
;; CORRECT
:args '((:name "questions"
         :type "array"
         :items (:type "object"
#+end_src

However, the error persists even after this fix, suggesting either:
- The tool definition wasn't actually reloaded
- The error occurs in a different part of the schema serialization
- There's a deeper incompatibility with how GPtel serializes tool schemas

**** Attempted Solutions

**Attempt 1: Synchronous Callback (Before Quit)**

Strategy: Invoke callback immediately before closing transient to ensure FSM is still active.

#+begin_src emacs-lisp :tangle no
(funcall callback answer-json)  ; Call first
(transient-quit-one)            ; Then close
#+end_src

Result: ERROR - "Wrong type argument: symbolp" on choice string. User reported that calling
callback before closing transient causes "extra stuff" to be passed back, likely due to
transient state contamination.

**Attempt 2: Post-Command Hook Deferral**

Strategy: Close transient first, then defer callback via ~post-command-hook~.

#+begin_src emacs-lisp :tangle no
(transient-quit-one)           ; Close first

(let (hook-fn)
  (setq hook-fn
        (lambda ()
          (remove-hook 'post-command-hook hook-fn)
          (funcall callback answer-json)))
  (add-hook 'post-command-hook hook-fn))
#+end_src

Result: ERROR - Same error. Post-command-hook runs after transient cleanup but FSM context
may be stale by that point.

**Attempt 3: Timer-Based Deferral**

Strategy: Close transient first, then use ~run-at-time~ with short delay to invoke callback
after transient cleanup completes.

#+begin_src emacs-lisp :tangle no
(transient-quit-one)           ; Close first

(run-at-time
 0.05 nil                      ; 50ms delay
 (lambda ()
   (funcall callback answer-json)))
#+end_src

Result: ERROR - Same error persists. Timer allows transient to fully clean up but doesn't
resolve the underlying type error.

**Attempt 4: Buffer Context Preservation**

Strategy: Capture origin buffer immediately at tool entry, store as buffer-local, and use
it when invoking callback.

#+begin_src emacs-lisp :tangle no
;; In jf/gptel-questions--ask:
(let* ((origin-buffer (current-buffer))  ; Capture immediately
       ...)
  (setq-local jf/gptel-questions--origin-buffer origin-buffer))

;; In jf/gptel-questions--submit:
(with-current-buffer origin-buffer
  (funcall callback answer-json))
#+end_src

Result: ERROR - Same error. Buffer context is correct (session.md), but ~gptel--fsm~ is
still nil in that buffer, confirming FSM is not buffer-local.

**** Current Understanding

1. **FSM is NOT buffer-local** - It's passed through callback closures, not stored in buffers
2. **Error occurs during schema serialization** - The error references choice strings from
   the tool schema, not the user's answer
3. **Callback structure appears correct** - The callback contains the FSM and is being invoked
   correctly
4. **Type error in schema** - Despite fixing type declarations from symbols to strings,
   the error persists, suggesting:
   - Tool wasn't reloaded properly, OR
   - There's additional schema issues we haven't found, OR
   - GPtel's serialization has different requirements we're not meeting

**** Open Questions

1. Why does the error reference choice strings instead of the answer?
   - Hypothesis: Error occurs when GPtel re-serializes the original tool call arguments
     to include in the next API request message history

2. Why does ~gptel--fsm bound: nil~ if FSM is in the callback?
   - Hypothesis: GPtel doesn't use buffer-local FSM, only closure-based FSM

3. Are there additional type issues in the schema?
   - Need to verify ALL type declarations use strings
   - Check if ~:enum~ vectors need special handling

4. Is the tool definition actually being reloaded?
   - ~M-x jf/reload-module~ may not fully re-register the tool
   - May need to clear gptel's tool cache manually

**** Next Debugging Steps

1. **Verify tool reload**: Check ~gptel--known-tools~ to confirm new schema is registered
2. **Test minimal tool**: Create simplified test tool with single string arg to isolate issue
3. **Trace callback execution**: Add logging inside the callback closure to see what it does
4. **Check Anthropic backend**: Verify ~gptel--parse-tool-results~ for Anthropic backend
5. **Compare with working tool**: Study ~persistent-agent~ callback structure in detail

* Provide Feature

#+begin_src emacs-lisp
(provide 'jf/gptel-questions)

;;; question-tools.el ends here
#+end_src
