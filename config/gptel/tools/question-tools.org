#+title: GPTEL Question Tools
#+property: header-args:emacs-lisp :tangle question-tools.el
#+auto_tangle: y

* Overview

This module implements an async gptel tool that allows LLMs (particularly the planner agent) to collect structured questions from users through an intuitive transient interface.

** Features
- Support for multiple question types (multiple-choice, yes/no, text, numeric)
- Optional comments on answers
- Progress tracking
- Validation of required fields
- Returns structured answers to LLM via callback
- Supports cancellation with partial answers

** Architecture
The tool uses transient for the UI and stores state in ~transient-scope~. When the LLM calls ~ask_questions~, a transient menu is displayed where the user can answer questions in any order. On submit or cancel, a callback is invoked with the collected answers.

* Data Structures

** Question Object (LLM ‚Üí Tool)
#+begin_src emacs-lisp
;; Example question plist:
;; (:id "question-1"                    ; Unique identifier (required)
;;  :type "multiple-choice"             ; Question type (required)
;;  :prompt "What is your goal?"        ; Question text (required)
;;  :description "Optional context"     ; Additional detail (optional)
;;  :required t                         ; Whether answer required (default: t)
;;  :default "value"                    ; Default value (optional)
;;  :choices ("Option A" "Option B")    ; For multiple-choice (required if type=multiple-choice)
;;  :min 0                              ; For numeric (optional)
;;  :max 100)                           ; For numeric (optional)
#+end_src

** Answer Object (Tool ‚Üí LLM)
#+begin_src emacs-lisp
;; Example answer plist returned to LLM:
;; (:id "question-1"                    ; Question identifier
;;  :answer "Option A"                  ; User's answer value
;;  :comment "My reasoning here"        ; Optional user comment
;;  :skipped nil)                       ; Whether skipped (if not required)
#+end_src

** Transient Scope Structure
#+begin_src emacs-lisp
;; Scope structure stored in transient:
;; (:questions (list ...)               ; Original questions from LLM
;;  :answers (hash-table)               ; ID ‚Üí answer value mapping
;;  :comments (hash-table)              ; ID ‚Üí comment string mapping
;;  :current-question "question-1")    ; Currently selected (for future nav features)
;;
;; NOTE: Callback is NOT stored in scope to avoid serialization issues.
;;       It's stored in buffer-local variable jf/gptel-questions--callback
#+end_src

* Helper Functions

** Callback Storage

#+begin_src emacs-lisp
(defvar-local jf/gptel-questions--callback nil
  "Buffer-local storage for async tool callback.
Stored outside transient scope to avoid serialization issues.")
#+end_src

** Answer Storage and Retrieval

#+begin_src emacs-lisp
(defun jf/gptel-questions--answer-question (question-id answer)
  "Store ANSWER for QUESTION-ID in current scope."
  (let* ((scope (transient-scope))
         (answers (plist-get scope :answers)))
    (puthash question-id answer answers)))

(defun jf/gptel-questions--set-comment (question-id comment)
  "Store COMMENT for QUESTION-ID in current scope."
  (let* ((scope (transient-scope))
         (comments (plist-get scope :comments)))
    (puthash question-id comment comments)))

(defun jf/gptel-questions--get-answer (question-id)
  "Get current answer for QUESTION-ID from scope."
  (let* ((scope (transient-scope))
         (answers (plist-get scope :answers)))
    (gethash question-id answers)))

(defun jf/gptel-questions--get-comment (question-id)
  "Get current comment for QUESTION-ID from scope."
  (let* ((scope (transient-scope))
         (comments (plist-get scope :comments)))
    (gethash question-id comments)))

(defun jf/gptel-questions--is-answered-p (question-id)
  "Check if QUESTION-ID has been answered."
  (let ((answer (jf/gptel-questions--get-answer question-id)))
    (not (null answer))))
#+end_src

** Question Normalization

#+begin_src emacs-lisp
(defun jf/gptel-questions--normalize-question (question)
  "Normalize QUESTION plist from LLM into expected Emacs format.
Handles vector-to-list conversion and type coercion.
Returns normalized question or signals error with clear message."
  (let* ((id (plist-get question :id))
         (type (plist-get question :type))
         (prompt (plist-get question :prompt))
         (description (plist-get question :description))
         (required (plist-get question :required))
         (default (plist-get question :default))
         (choices-raw (plist-get question :choices))
         (min (plist-get question :min))
         (max (plist-get question :max)))

    ;; Validate required fields
    (unless id
      (error "Question missing required field: :id"))
    (unless type
      (error "Question %s missing required field: :type" id))
    (unless prompt
      (error "Question %s missing required field: :prompt" id))

    ;; Validate question type
    (unless (member type '("multiple-choice" "yes-no" "text" "numeric"))
      (error "Question %s has invalid type: %s (must be one of: multiple-choice, yes-no, text, numeric)" id type))

    ;; Type-specific validation and normalization
    (when (string= type "multiple-choice")
      (unless choices-raw
        (error "Question %s is multiple-choice but missing :choices field" id))

      ;; Convert vector to list if needed
      (let ((choices (if (vectorp choices-raw)
                         (append choices-raw nil)
                       choices-raw)))
        (unless (and (listp choices) (> (length choices) 0))
          (error "Question %s :choices must be non-empty array/list, got: %S" id choices-raw))

        ;; Ensure all choices are strings
        (setq choices (mapcar (lambda (c)
                                (if (stringp c)
                                    c
                                  (format "%s" c)))
                              choices))

        ;; Update question with normalized choices
        (setq question (plist-put question :choices choices))))

    (when (string= type "numeric")
      ;; Ensure min/max are numbers if provided
      (when min
        (unless (numberp min)
          (error "Question %s :min must be a number, got: %S" id min)))
      (when max
        (unless (numberp max)
          (error "Question %s :max must be a number, got: %S" id max))))

    ;; Normalize required field to boolean
    ;; Handle JSON false (represented as :json-false)
    (let ((required-normalized
           (cond
            ((eq required :json-false) nil)
            ((null required) t)  ; default to required
            (t (not (null required))))))
      (setq question (plist-put question :required required-normalized)))

    ;; Ensure string fields are strings
    (when description
      (unless (stringp description)
        (setq question (plist-put question :description (format "%s" description)))))
    (when default
      (unless (stringp default)
        (setq question (plist-put question :default (format "%s" default)))))

    question))

(defun jf/gptel-questions--normalize-questions (questions)
  "Normalize QUESTIONS array from LLM.
Converts vectors to lists and validates each question.
Returns list of normalized question plists."
  ;; Convert top-level array
  (let ((questions-list (if (vectorp questions)
                            (append questions nil)
                          questions)))

    (unless (listp questions-list)
      (error "Questions must be an array/list, got: %S" questions))

    (when (= (length questions-list) 0)
      (error "Questions array is empty"))

    ;; Normalize each question
    (mapcar #'jf/gptel-questions--normalize-question questions-list)))
#+end_src

** Validation

#+begin_src emacs-lisp
(defun jf/gptel-questions--validate-answers ()
  "Check if all required questions are answered.
Returns (valid-p . error-message)."
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (unanswered-required '()))

    (dolist (q questions)
      (let ((id (plist-get q :id))
            (required (if (plist-member q :required)
                          (plist-get q :required)
                        t)))  ; default to required
        (when (and required
                   (not (jf/gptel-questions--is-answered-p id)))
          (push (plist-get q :prompt) unanswered-required))))

    (if unanswered-required
        (cons nil (format "Required questions unanswered: %s"
                         (string-join (nreverse unanswered-required) ", ")))
      (cons t nil))))
#+end_src

** Answer List Builder

#+begin_src emacs-lisp
(defun jf/gptel-questions--build-answer-list ()
  "Build answer list from current state for callback.
Returns JSON-encoded string for LLM consumption."
  (require 'json)
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (answers-hash (plist-get scope :answers))
         (comments-hash (plist-get scope :comments))
         (answer-list '()))

    (dolist (q questions)
      (let* ((id (plist-get q :id))
             (answer (gethash id answers-hash))
             (comment (gethash id comments-hash))
             (skipped (null answer)))
        ;; Use alist format for proper JSON encoding
        (push `((id . ,id)
                (answer . ,(or answer ""))
                (comment . ,(or comment ""))
                (skipped . ,skipped))
              answer-list)))

    ;; Encode as JSON string for gptel tool result serialization
    (json-encode (nreverse answer-list))))
#+end_src

** Comment Management

#+begin_src emacs-lisp
(defun jf/gptel-questions--add-or-edit-comment ()
  "Interactively select a question and add/edit its comment."
  (interactive)
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (choices (mapcar (lambda (q)
                           (let* ((id (plist-get q :id))
                                  (prompt (plist-get q :prompt))
                                  (has-comment (not (string-empty-p
                                                    (jf/gptel-questions--get-comment id))))
                                  (indicator (if has-comment "üí¨ " "")))
                             (cons (format "%s%s" indicator prompt) id)))
                         questions))
         (selection (completing-read "Add/edit comment for: " choices nil t))
         (question-id (cdr (assoc selection choices))))

    (when question-id
      (let* ((current-comment (jf/gptel-questions--get-comment question-id))
             (new-comment (read-string "Comment: " current-comment)))
        (jf/gptel-questions--set-comment question-id new-comment)
        (message "Comment saved for: %s" selection)))))
#+end_src

** Formatting Functions

#+begin_src emacs-lisp
(defun jf/gptel-questions--format-question (question key)
  "Format QUESTION for display in transient menu with KEY binding."
  (let* ((prompt (plist-get question :prompt))
         (required (if (plist-member question :required)
                       (plist-get question :required)
                     t))
         (id (plist-get question :id))
         (answered (jf/gptel-questions--is-answered-p id))
         (answer (jf/gptel-questions--get-answer id))
         (comment (jf/gptel-questions--get-comment id))
         (has-comment (and comment (not (string-empty-p comment))))
         (indicator (cond
                     (answered (propertize "‚úì" 'face 'success))
                     (required (propertize "‚óè" 'face 'error))
                     (t (propertize "‚óã" 'face 'transient-inactive-value))))
         (comment-indicator (if has-comment
                                (propertize " üí¨" 'face 'transient-value)
                              ""))
         (key-str (propertize (format "[%s]" key) 'face 'transient-key)))

    (format "%s %s %s%s%s"
            key-str
            indicator
            prompt
            (if answered
                (propertize (format " ‚Üí %s" answer) 'face 'transient-value)
              "")
            comment-indicator)))

(defun jf/gptel-questions--progress-info ()
  "Generate progress indicator string."
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (total (length questions))
         (answered (cl-count-if
                    (lambda (q)
                      (jf/gptel-questions--is-answered-p (plist-get q :id)))
                    questions))
         (face (if (= answered total) 'success 'transient-value)))
    (propertize (format "Progress: %d/%d answered" answered total)
                'face face)))
#+end_src

** Submission and Cancellation

#+begin_src emacs-lisp
(defun jf/gptel-questions--submit ()
  "Validate and submit answers."
  (interactive)
  (let ((validation (jf/gptel-questions--validate-answers)))
    (if (car validation)
        ;; Build answer JSON from scope before quitting
        (let* ((answer-json (jf/gptel-questions--build-answer-list))
               (callback jf/gptel-questions--callback))

          ;; Close transient to clean up scope
          (transient-quit-one)

          ;; Invoke callback directly - no delay needed
          ;; The key fix is storing callback outside transient scope
          (condition-case err
              (progn
                (message "Invoking callback with: %s" answer-json)
                (funcall callback answer-json))
            (error
             (message "Error in callback: %s" (error-message-string err))
             (message "Answer JSON was: %s" answer-json))))

      ;; Validation failed
      (message "%s" (cdr validation)))))

(defun jf/gptel-questions--cancel ()
  "Cancel and return partial answers to LLM."
  (interactive)
  ;; Build answer JSON from scope before quitting
  (let* ((answer-json (jf/gptel-questions--build-answer-list))
         (callback jf/gptel-questions--callback))

    ;; Close transient to clean up scope
    (transient-quit-one)

    ;; Invoke callback directly - no delay needed
    ;; The key fix is storing callback outside transient scope
    (condition-case err
        (progn
          (message "Invoking callback (cancel) with: %s" answer-json)
          (funcall callback answer-json))
      (error
       (message "Error in callback: %s" (error-message-string err))
       (message "Answer JSON was: %s" answer-json)))))
#+end_src

* Custom Transient Classes

** Question Infix Class

#+begin_src emacs-lisp
(defclass jf/gptel-question-infix (transient-infix)
  ((question :initarg :question))
  "Infix class for question answering.")
#+end_src

** Read Method (Type-Specific Input)

#+begin_src emacs-lisp
(cl-defmethod transient-infix-read ((obj jf/gptel-question-infix))
  "Read answer for question OBJ based on question type."
  (let* ((q (oref obj question))
         (q-type (plist-get q :type))
         (q-id (plist-get q :id))
         (prompt (plist-get q :prompt))
         (default (plist-get q :default))
         (current (jf/gptel-questions--get-answer q-id)))

    (pcase q-type
      ("multiple-choice"
       (let ((choices (plist-get q :choices)))
         (completing-read (format "%s: " prompt)
                         choices nil t (or current default))))

      ("yes-no"
       (if (y-or-n-p (format "%s " prompt)) "yes" "no"))

      ("text"
       (read-string (format "%s: " prompt) (or current default)))

      ("numeric"
       (let* ((min (plist-get q :min))
              (max (plist-get q :max))
              (default-val (or (and current (string-to-number current))
                              default
                              0))
              (input (read-number (format "%s: " prompt) default-val)))
         (when (and min (< input min))
           (error "Value must be at least %d" min))
         (when (and max (> input max))
           (error "Value must be at most %d" max))
         (number-to-string input)))

      (_ (error "Unknown question type: %s" q-type)))))
#+end_src

** Set Method

#+begin_src emacs-lisp
(cl-defmethod transient-infix-set ((obj jf/gptel-question-infix) value)
  "Set VALUE as answer for question OBJ."
  (let ((q-id (plist-get (oref obj question) :id)))
    (jf/gptel-questions--answer-question q-id value)
    (oset obj value value)))
#+end_src

** Format Method

#+begin_src emacs-lisp
(cl-defmethod transient-format ((obj jf/gptel-question-infix))
  "Format question and answer for display."
  (let* ((q (oref obj question))
         (key (oref obj key))
         (formatted (jf/gptel-questions--format-question q key)))
    (format "  %s" formatted)))
#+end_src

* Transient Menu

** Key Pool Generation

#+begin_src emacs-lisp
(defun jf/gptel-questions--generate-key-pool (count)
  "Generate COUNT key bindings for questions.
Uses single letters (a-z) for first 26, then two-letter combinations (aa-zz)."
  (let ((keys '())
        (letters "abcdefghijklmnopqrstuvwxyz"))
    ;; Single letters: a-z (26 keys)
    (dotimes (i (min count 26))
      (push (substring letters i (1+ i)) keys))

    ;; Two letters: aa-zz (676 more keys if needed)
    (when (> count 26)
      (dotimes (i (min (- count 26) 676))
        (let ((first (/ i 26))
              (second (mod i 26)))
          (push (format "%c%c"
                        (aref letters first)
                        (aref letters second))
                keys))))

    (nreverse keys)))
#+end_src

** Dynamic Suffix Generation

#+begin_src emacs-lisp
(defun jf/gptel-questions--setup-question-suffixes (_)
  "Generate transient suffixes for each question."
  (let* ((scope (transient-scope))
         (questions (plist-get scope :questions))
         (key-pool (jf/gptel-questions--generate-key-pool (length questions))))

    (transient-parse-suffixes
     'jf/gptel-questions-menu
     (cl-loop for q in questions
              for key in key-pool
              collect
              (list key
                    ""  ; Description computed dynamically by transient-format
                    (plist-get q :id)  ; Use question ID as the argument
                    :class 'jf/gptel-question-infix
                    :question q)))))
#+end_src

** Main Prefix

#+begin_src emacs-lisp
(transient-define-prefix jf/gptel-questions-menu ()
  "Answer questions from LLM agent."
  :refresh-suffixes t

  ;; Top section: Info and actions
  [:description "Answer Questions"
   [""
    (:info (lambda () (jf/gptel-questions--progress-info)))]
   [""
    ("RET" "Submit answers" jf/gptel-questions--submit)
    ("C" "Add/edit comment" jf/gptel-questions--add-or-edit-comment
     :transient t)
    ("q" "Cancel (send partial)" jf/gptel-questions--cancel)]]

  ;; Questions section: dynamically generated
  [[:class transient-column
    :setup-children jf/gptel-questions--setup-question-suffixes]])
#+end_src

* Tool Definition

** Tool Entry Point

#+begin_src emacs-lisp
(defun jf/gptel-questions--ask (callback questions)
  "Async tool function. Display questions UI and invoke CALLBACK with answers.
QUESTIONS is array of question plists from LLM.

Normalizes and validates questions before displaying UI.
Signals clear errors if questions are malformed."
  (condition-case err
      (let* (;; Normalize and validate questions
             (questions-list (jf/gptel-questions--normalize-questions questions))
             (answers (make-hash-table :test 'equal))
             (comments (make-hash-table :test 'equal)))

        ;; Initialize hash tables
        (dolist (q questions-list)
          (puthash (plist-get q :id) nil answers)
          (puthash (plist-get q :id) "" comments))

        ;; Store callback in buffer-local variable (NOT in transient scope)
        ;; This avoids serialization issues when gptel tries to serialize state
        (setq-local jf/gptel-questions--callback callback)

        ;; Launch transient with scope (callback NOT included)
        (transient-setup
         'jf/gptel-questions-menu
         nil nil
         :scope (list :questions questions-list
                      :answers answers
                      :comments comments
                      :current-question (plist-get (car questions-list) :id))))

    ;; Handle errors gracefully - provide structured feedback to LLM
    (error
     (require 'json)
     (let ((error-msg (error-message-string err)))
       (message "Error in ask_questions tool: %s" error-msg)
       (message "This is likely due to malformed question structure from LLM")
       (message "Questions received: %S" questions)
       ;; Return validation error to LLM as JSON string so it can correct the tool call
       ;; Use alist format for proper JSON encoding
       (funcall callback
                (json-encode
                 (list `((error . t)
                        (error_type . "validation_error")
                        (error_message . ,error-msg)
                        (hint . "Check that all questions have required fields (:id, :type, :prompt), :type is valid (multiple-choice/yes-no/text/numeric), and multiple-choice questions include :choices array")))))))))
#+end_src

** Tool Registration

#+begin_src emacs-lisp
(gptel-make-tool
 :name "ask_questions"
 :function #'jf/gptel-questions--ask

 :description "Ask user structured questions and collect answers interactively.

Present multiple questions in an interactive menu where user can:
- Answer in any order
- Add optional comments/notes to answers
- See progress (answered vs total)
- Review and change answers before submission
- Submit when ready or cancel to return partial answers

Question types supported:
- multiple-choice: User selects from predefined choices list
- yes-no: Simple yes/no question
- text: Free-form text input
- numeric: Numeric input with optional min/max validation

Use this when you need user input to refine your plan or make decisions.
For example, ask about goals, constraints, preferences, or technical choices."

 :args '((:name "questions"
          :type array
          :items (:type object
                  :properties (:id (:type string
                                   :description "Unique question identifier")
                              :type (:type string
                                    :enum ["multiple-choice" "yes-no" "text" "numeric"]
                                    :description "Question type")
                              :prompt (:type string
                                      :description "Question text to display")
                              :description (:type string
                                           :description "Optional additional context")
                              :required (:type boolean
                                        :description "Whether answer is required (default: true)")
                              :default (:type string
                                       :description "Default answer value")
                              :choices (:type array
                                       :items (:type string)
                                       :description "For multiple-choice: list of options")
                              :min (:type number
                                   :description "For numeric: minimum value")
                              :max (:type number
                                   :description "For numeric: maximum value")))
          :description "Array of question objects to ask user"))

 :category "interaction"
 :async t
 :confirm nil)
#+end_src

* Testing Utilities

** Manual Test Cases

These functions can be used to manually test the question tool.

#+begin_src emacs-lisp
(defun jf/gptel-questions-test-basic ()
  "Test basic functionality with text, yes-no, and multiple-choice."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json)
     (message "Parsed: %S" (json-read-from-string answers-json)))
   '((:id "test1" :type "text" :prompt "Your name?" :required t)
     (:id "test2" :type "yes-no" :prompt "Proceed?")
     (:id "test3" :type "multiple-choice"
      :prompt "Choose color"
      :choices ("Red" "Blue" "Green")))))

(defun jf/gptel-questions-test-numeric ()
  "Test numeric validation with min/max."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   '((:id "age" :type "numeric" :prompt "Age?" :min 0 :max 120 :required t))))

(defun jf/gptel-questions-test-optional ()
  "Test optional fields with defaults."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   '((:id "opt1" :type "text" :prompt "Optional field"
      :required nil :default "Default value"))))

(defun jf/gptel-questions-test-large ()
  "Test with 15 questions to verify scrolling."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (let ((answers (json-read-from-string answers-json)))
       (message "Got %d answers" (length answers))))
   (cl-loop for i from 1 to 15
            collect (list :id (format "q%d" i)
                         :type "text"
                         :prompt (format "Question %d?" i)
                         :required nil))))

(defun jf/gptel-questions-test-realistic ()
  "Test with realistic planning scenario questions."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (let ((answers (json-read-from-string answers-json)))
       (message "Planner received %d answers" (length answers))
       (dolist (a answers)
         (let-alist a
           (message "  %s: %s%s"
                    .id
                    .answer
                    (if (string-empty-p .comment)
                        ""
                      (format " [%s]" .comment)))))))
   '((:id "primary_goal"
      :type "multiple-choice"
      :prompt "What is your primary goal for this feature?"
      :description "This helps me prioritize design trade-offs"
      :choices ("Performance" "Readability" "Maintainability" "Simplicity")
      :required t)
     (:id "refactor_existing"
      :type "yes-no"
      :prompt "Should I refactor existing code or leave it as-is?"
      :required t)
     (:id "deadline"
      :type "text"
      :prompt "When do you need this completed?"
      :required nil
      :default "No specific deadline")
     (:id "complexity_tolerance"
      :type "numeric"
      :prompt "Complexity tolerance (1=simple, 10=complex)"
      :description "Higher values mean more sophisticated solutions"
      :min 1
      :max 10
      :default "5"
      :required nil))))
#+end_src

** Robustness Tests

#+begin_src emacs-lisp
(defun jf/gptel-questions-test-vector-choices ()
  "Test that vector choices (from LLM JSON) work correctly."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   ;; Simulate JSON array as vector
   [(:id "test1" :type "multiple-choice"
     :prompt "Choose option"
     :choices ["Option A" "Option B" "Option C"]  ; Vector, not list
     :required t)]))

(defun jf/gptel-questions-test-json-false ()
  "Test that :json-false for required field works correctly."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   [(:id "test1" :type "text"
     :prompt "Optional field"
     :required :json-false)]))  ; JSON false becomes :json-false

(defun jf/gptel-questions-test-malformed ()
  "Test error handling for malformed questions."
  (interactive)
  ;; Missing :id
  (condition-case err
      (jf/gptel-questions--ask
       (lambda (answers) (message "Should not reach here"))
       [(:type "text" :prompt "No ID")])
    (error (message "Correctly caught error: %s" (error-message-string err))))

  ;; Missing :type
  (condition-case err
      (jf/gptel-questions--ask
       (lambda (answers) (message "Should not reach here"))
       [(:id "test" :prompt "No type")])
    (error (message "Correctly caught error: %s" (error-message-string err))))

  ;; Multiple-choice without choices
  (condition-case err
      (jf/gptel-questions--ask
       (lambda (answers) (message "Should not reach here"))
       [(:id "test" :type "multiple-choice" :prompt "No choices")])
    (error (message "Correctly caught error: %s" (error-message-string err)))))

(defun jf/gptel-questions-test-type-coercion ()
  "Test that non-string values get coerced to strings."
  (interactive)
  (jf/gptel-questions--ask
   (lambda (answers-json)
     (message "Answers JSON: %s" answers-json))
   [(:id "test1" :type "multiple-choice"
     :prompt "Choose number"
     :choices [1 2 3]  ; Numbers, should be coerced to strings
     :required t)
    (:id "test2" :type "text"
     :prompt "Text field"
     :default 42)]))  ; Number default, should be coerced

(defun jf/gptel-questions-test-error-feedback ()
  "Test that validation errors are returned to LLM callback in structured format."
  (interactive)
  ;; This simulates what the LLM would receive when providing malformed questions
  (jf/gptel-questions--ask
   (lambda (result-json)
     (let ((result (json-read-from-string result-json)))
       (if (alist-get 'error (elt result 0))
           (let-alist (elt result 0)
             (message "LLM received validation error:")
             (message "  Error type: %s" .error_type)
             (message "  Error message: %s" .error_message)
             (message "  Hint: %s" .hint))
         (message "LLM received valid answers: %S" result))))
   ;; Invalid question: missing :type field
   [(:id "test" :prompt "Question without type field")]))
#+end_src

* Implementation Notes and Known Issues

** Background

This async gptel tool uses transient for UI and must integrate with gptel's FSM (finite state machine) for tool execution. The implementation faced several challenges due to the interaction between transient's scope management and gptel's request serialization.

** Challenge 1: Data Structure Serialization

*** Problem
When returning tool results to the LLM, gptel serializes the request context (including tool results) to send to the API. Initial implementations encountered errors:

#+begin_example
(wrong-type-argument symbolp "User documentation (how-to guides, tutorials)")
#+end_example

*** Root Cause
Emacs ~json-encode~ doesn't handle plists correctly - it treats them as flat arrays instead of objects:

#+begin_src emacs-lisp
;; This plist:
'(:id "test" :answer "foo")

;; Gets encoded as:
{"id": ["test", "answer", "foo"]}  ; Wrong!

;; Instead of:
{"id": "test", "answer": "foo"}    ; Correct
#+end_src

*** Solution
Convert to alists before JSON encoding:

#+begin_src emacs-lisp
;; Use alist format for proper JSON encoding
`((id . ,id)
  (answer . ,(or answer ""))
  (comment . ,(or comment ""))
  (skipped . ,skipped))
#+end_src

** Challenge 2: Callback in Transient Scope

*** Problem
Initially stored the callback function in the transient scope:

#+begin_src emacs-lisp
:scope (list :questions questions-list
             :answers answers
             :comments comments
             :callback callback)  ; PROBLEM: callback in scope
#+end_src

This caused serialization errors because when gptel tried to serialize the request context after the tool completed, it encountered the transient scope data (including question choices, hash tables, etc.) embedded in the callback's closure.

Error: ~(wrong-type-argument symbolp "Code implementation or refactoring")~

*** Root Cause
The callback is a closure that captures gptel's request context. When we stored it in the transient scope, we created a circular reference or unexpected data structure that gptel's serialization couldn't handle. Specifically:

1. Callback captures gptel request info (including buffer, position, data)
2. We stored callback in transient scope
3. Transient scope contains all our UI data (questions with choice arrays, hash tables)
4. When tool completes, gptel tries to serialize context to send results back
5. Serialization encounters transient scope data where it expects simple values

*** Solution
Store callback in buffer-local variable **outside** transient scope:

#+begin_src emacs-lisp
;; Store callback separately
(setq-local jf/gptel-questions--callback callback)

;; Don't include in scope
:scope (list :questions questions-list
             :answers answers
             :comments comments)  ; callback NOT here
#+end_src

** Challenge 3: Callback Invocation Timing

*** Problem
After fixing serialization, tool results appeared in buffer but LLM didn't respond:

#+begin_example
[{"id":"coding_philosophy","answer":"Take a break...","skipped":null}]

# Conversation ends here - no LLM response
#+end_example

*** Investigation
Tried multiple approaches to callback invocation timing:

1. **Call immediately after quit** - Current approach, still not working
2. **Call with timer delay** - Caused variable scoping issues, lost tool output display
3. **Call with buffer context switching** - Same issues as timer approach

*** Current Status
The callback is being invoked (we can see tool output in buffer), but gptel's FSM is not continuing to send results back to LLM and get final response.

*** Hypotheses for FSM Not Continuing

**** H1: Transient Command Context
Callback might need to execute outside the transient command's interactive context. The ~transient-quit-one~ may not be sufficient cleanup before callback invocation.

**** H2: Buffer Context
Callback might need to execute in the original gptel session buffer context, not from within the transient command's execution context.

**** H3: FSM State Issue
The FSM might be in an unexpected state after the async tool completes. Comparing with persistent-agent tool (which works), that tool's callback is invoked from within gptel's own callback infrastructure, not from a user command.

**** H4: Missing FSM Signals
The callback might need to trigger specific FSM transitions or signals that we're not providing. The persistent-agent tool's dual-duty callback both inserts to buffer AND accumulates for return - we might be missing a step.

** Comparison with Working Async Tools

*** persistent-agent Tool (WORKING)

#+begin_src emacs-lisp
;; In persistent-agent tool:
(gptel-request nil
  :callback
  (lambda (resp info &optional raw)
    ;; ... process response ...
    (unless (plist-get info :tool-use)
      ;; Call main-cb when done
      (funcall main-cb partial))))
#+end_src

Key differences:
- Callback is invoked FROM WITHIN gptel's response handler
- Not invoked from user command context
- Buffer context is managed by gptel-request

*** ask_questions Tool (NOT WORKING)

#+begin_src emacs-lisp
;; In ask_questions tool:
(defun jf/gptel-questions--submit ()
  (interactive)  ; <- User command context
  ;; ... build result ...
  (transient-quit-one)
  (funcall callback answer-json))  ; <- Called from user command
#+end_src

Key differences:
- Callback invoked from user interactive command
- After transient UI cleanup
- Not within gptel's callback infrastructure

** Potential Solutions to Investigate

*** Option 1: Defer Callback to Idle Timer
Instead of calling immediately after quit, defer to next idle time:

#+begin_src emacs-lisp
(run-with-idle-timer 0.1 nil
  (lambda ()
    (funcall callback answer-json)))
#+end_src

This ensures we're completely outside transient's command context.

*** Option 2: Use gptel's Callback Infrastructure
Store the result and have gptel poll/check for completion, similar to how it handles other async operations.

*** Option 3: Invoke from Post-Command Hook
Register a one-time post-command hook that invokes the callback after the transient command fully completes:

#+begin_src emacs-lisp
(let ((hook-fn (lambda ()
                 (funcall callback answer-json)
                 (remove-hook 'post-command-hook hook-fn))))
  (add-hook 'post-command-hook hook-fn))
#+end_src

*** Option 4: Study gptel's Tool Execution Context
Need to understand exactly what context gptel expects when async tool callback is invoked:
- What buffer should be current?
- What FSM state should exist?
- What info plist fields are needed?
- Are there specific signals or transitions we need to trigger?

** Questions for Further Investigation

1. Does the callback need to be invoked in the gptel buffer that initiated the tool call?
2. Is there FSM state that gets corrupted/lost when we invoke from transient command context?
3. Do we need to manually trigger ~(gptel--fsm-transition fsm)~ or similar?
4. Should we store the FSM instance itself and interact with it directly?
5. What does gptel's log buffer show when this happens? (Enable ~gptel-log-level 'debug~)

** Current Workaround

None - feature is not functional. Tool UI works perfectly, JSON encoding works, but conversation doesn't continue after tool results are submitted.

** Files to Study

- =gptel-request.el:1679-1747= - ~gptel--handle-tool-use~ (how gptel executes async tools)
- =gptel-request.el:1564-1582= - FSM transition table
- =config/gptel/tools/persistent-agent.el= - Working async tool implementation

** Debug Commands for Next Session

#+begin_src emacs-lisp
;; Enable gptel debug logging
(setq gptel-log-level 'debug)

;; Check FSM state in gptel buffer
;; (examine buffer-local variables after tool completes)

;; Trace callback invocation
(trace-function 'jf/gptel-questions--callback)

;; Compare working vs non-working tool execution in *gptel-log*
#+end_src

* Provide Feature

#+begin_src emacs-lisp
(provide 'jf/gptel-questions)
#+end_src
