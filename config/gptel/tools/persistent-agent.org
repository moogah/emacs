#+title: GPTEL Persistent Agent Tool
#+property: header-args:emacs-lisp :tangle persistent-agent.el
#+auto_tangle: y

* Overview

The PersistentAgent tool launches specialized agents in persistent session buffers that:
- Run autonomously with full tool access
- Persist conversations to disk with complete history
- Display real-time progress in parent buffer via overlay
- Maintain bidirectional parent-child session links
- Support resumable sessions

This tool replicates gptel-agent's superior architecture while maintaining buffer-based persistence for seamless integration with gptel's save/restore mechanisms.

** Key Architecture

- *Configuration Isolation*: Uses gptel-with-preset for proper dynamic scope
- *Persistent State*: Buffer-local session vars survive preset scope
- *Parent Feedback*: Overlay system shows progress without context switching
- *Tool Persistence*: All tool I/O saved via gptel-include-tool-results
- *Auto-save*: Automatic buffer save after each response
- *Zero Inheritance*: Agent configured ONLY from agent definition, not parent

* Detailed Architecture

This section provides comprehensive architectural analysis of the PersistentAgent tool implementation.

** Context & Purpose

PersistentAgent is an Emacs Lisp tool that integrates with the =gptel= package (an LLM client for Emacs) to create *persistent, autonomous agent sessions*.

*Domain:* Emacs-based AI assistant infrastructure for literate programming workflows

*Primary Use Cases:*
- Research tasks requiring multiple tool invocations
- Complex exploration of codebases
- Planning and execution that benefits from conversation history
- Hierarchical agent delegation (parent agents spawning child agents)

*Architectural Philosophy:*

The tool emphasizes *"zero inheritance"* - child agents are configured ONLY from their agent definition files, not from parent session state. This prevents configuration pollution and ensures predictable agent behavior.

** Component Architecture

The PersistentAgent tool is part of a larger modular gptel configuration:

#+begin_example
config/gptel/
├── gptel.org/el           - Main loader
├── sessions/              - 8 session management modules
│   ├── constants.el       - Path constants
│   ├── logging.el         - Debug logging
│   ├── filesystem.el      - Directory structure, path helpers
│   ├── registry.el        - Global session tracking (runtime state only)
│   ├── metadata.el        - Read metadata from scope-plan.yml + preset.md
│   ├── agent-integration.el - Parent-child session linking
│   ├── commands.el        - User-facing session commands
│   └── activities-integration.el - Activities package integration
├── tools/                 - 10 tool definitions
│   ├── persistent-agent.el  - THIS MODULE
│   ├── filesystem-tools.el
│   └── projectile-tools.el
└── agents/                - 5 agent definition markdown files
    ├── executor.md
    ├── explorer.md
    ├── planner.md
    └── researcher.md
#+end_example

** Component Diagram

#+begin_src mermaid
graph TB
    LLM[Parent LLM Session] -->|invokes tool| Tool[PersistentAgent Tool]
    Tool --> Session[Session Creation]
    Tool --> Overlay[Overlay System]
    Tool --> FSM[Custom FSM Handlers]

    Session --> Dir[Directory Structure]
    Session --> Meta[Metadata Files]
    Session --> Buffer[Agent Buffer]
    Session --> Registry[Global Registry]

    Buffer --> Preset[Agent Preset Config]
    Buffer --> AutoSave[Auto-save Hook]
    Buffer --> Request[gptel-request]

    Request --> FSM
    FSM --> Wait[WAIT State Handler]
    FSM --> ToolState[TOOL State Handler]

    Wait --> Overlay
    ToolState --> Overlay

    Request --> Callback[Response Callback]
    Callback --> Accumulate[Accumulate Response]
    Callback --> Persist[Persist to Buffer]
    Callback --> Return[Return to Parent]

    style Tool fill:#f9f,stroke:#333,stroke-width:4px
    style Buffer fill:#bbf,stroke:#333,stroke-width:2px
    style Overlay fill:#bfb,stroke:#333,stroke-width:2px
#+end_src

** Data Flow

#+begin_src mermaid
sequenceDiagram
    participant P as Parent LLM
    participant T as PersistentAgent Tool
    participant FS as Filesystem
    participant B as Agent Buffer
    participant O as Overlay
    participant API as LLM API

    P->>T: Invoke tool(agent_type, description, prompt)
    T->>T: Validate parent session exists
    T->>FS: Create agent directory
    FS-->>T: session-dir path

    T->>FS: Load agent config (NO parent inheritance)
    T->>FS: Write scope-plan.yml (includes parent_session_id)
    T->>FS: Write preset.md

    T->>B: Create buffer with session vars
    T->>B: Insert prompt
    T->>B: Add auto-save hook

    T->>O: Create overlay in parent buffer

    T->>API: gptel-request with FSM handlers

    loop Tool calls & responses
        API->>B: Tool call
        B->>O: Update overlay (tool count)
        B->>API: Tool results
        API->>B: Response chunk
        B->>B: Accumulate response
        B->>FS: Auto-save buffer
    end

    API->>B: Final response
    B->>O: Delete overlay
    B->>P: Return accumulated result
#+end_src

** Session Directory Structure

Sessions are persisted to disk with the following structure:

#+begin_example
~/gptel-sessions/
└── parent-session-20260121143022/
    ├── scope-plan.yml               # Session metadata and permissions
    ├── preset.md                    # Backend and model configuration
    ├── session.md                   # Parent conversation
    ├── tools.org                    # Parent tool calls
    └── agents/                      # Agent sessions
        └── researcher-20260121143245-analyze-code/
            ├── scope-plan.yml       # Agent metadata (includes parent_session_id)
            ├── preset.md            # Agent-specific config (NO inheritance)
            ├── session.md           # Agent conversation (auto-saved)
            └── tools.org            # Agent tool calls
#+end_example

** FSM State Handler Flow

#+begin_src mermaid
stateDiagram-v2
    [*] --> WAIT: gptel-request initiated

    WAIT --> TOOL: LLM requests tools
    WAIT --> Response: LLM sends text

    TOOL --> WAIT: Tool results sent

    Response --> Accumulate: String response
    Accumulate --> CheckToolUse: Is in tool-use?

    CheckToolUse --> WAIT: Yes (more turns)
    CheckToolUse --> Complete: No (final response)

    Complete --> [*]: Return to parent

    note right of WAIT
        Custom handler:
        jf/gptel-persistent-agent--indicate-wait
        Updates overlay: "Waiting..."
    end note

    note right of TOOL
        Custom handler:
        jf/gptel-persistent-agent--indicate-tool-call
        Updates overlay: "Tools (+N)"
    end note

    note right of Accumulate
        DUAL DUTY:
        1. Insert to buffer (persist)
        2. Accumulate for parent callback
    end note
#+end_src

** Design Patterns

*** Finite State Machine (FSM) Pattern

*Location:* Lines 129-136

The tool extends gptel's FSM architecture with custom handlers for WAIT and TOOL states.

*Why good:* Clean separation of concerns - UI updates (overlay) are decoupled from core request handling. Each state has a dedicated handler.

*** Overlay-based Progress Indicator Pattern

*Location:* Lines 67-88

Instead of switching buffers or popping up windows, progress is shown via text overlays in the parent buffer.

*Why good:* Non-intrusive UX - user stays in parent context while monitoring agent progress. Similar to how gptel-agent works.

*** Configuration Isolation via Dynamic Scoping

*Location:* Lines 230-235

Uses =gptel-with-preset= macro to create a clean dynamic scope for agent configuration.

*Why good:* Prevents configuration leakage between parent and child sessions. Agent gets config ONLY from its definition file.

*** Hook-based Auto-save Pattern

*Location:* Lines 52-60, 208-210

Leverages gptel's post-response hook infrastructure for automatic persistence.

*Why good:* Automatic, transparent persistence. No manual save calls scattered through code.

*** Registry Pattern

*Location:* Line 223 (via =jf/gptel--register-session=)

Sessions are registered in a global registry (=jf/gptel--session-registry=) that maps session IDs to metadata plists.

*Why good:* Centralized session lookup, enables features like session browsing, parent-child navigation, and resumption.

*** Dual-duty Callback Pattern

*Location:* Lines 273-300

The response callback serves two purposes:
1. Insert responses into buffer (for persistence)
2. Accumulate responses (for parent return value)

*Why good:* Single source of truth for response handling. Ensures buffer content matches what parent receives.

** Anti-patterns & Risks

*** Complex Nested Let Bindings (Medium Risk)

*Location:* Lines 162-300

The main function has 6 nested =let*= blocks creating deep nesting.

*Impact:* Hard to follow data flow, difficult to debug, high cognitive load.

*Mitigation:* Already uses descriptive variable names. Could be refactored into helper functions, but current implementation is manageable for a 150-line function.

*** Implicit Global State Dependencies (Low Risk)

*Location:* Line 158

The function checks buffer-local variable =jf/gptel--session-dir= without explicit parameter.

*Impact:* Function behavior depends on buffer context. Not obvious from signature.

*Mitigation:* This is intentional - the tool is designed to work ONLY in persistent session buffers. The error message clearly states the requirement.

*** Marker Position Mutation Risk (Low Risk)

*Location:* Lines 162, 78

Creates overlay at marker position in parent buffer, potentially modifying buffer content if cursor is at beginning.

*Impact:* Modifies buffer content (inserts newline) if cursor is at buffer start.

*Mitigation:* Minimal - only inserts single newline, and this is expected behavior (can't create overlay at buffer start).

** Architectural Strengths

1. *Clear Separation of Concerns*
   - Session management (filesystem, metadata, registry)
   - UI feedback (overlays)
   - Configuration (preset files, agent definitions)
   - Persistence (auto-save hooks)

2. *Configuration Isolation*
   - Zero inheritance from parent
   - Explicit agent configuration loading
   - Clean dynamic scope via =gptel-with-preset=

3. *Transparent Persistence*
   - Automatic buffer saves via hooks
   - Conversation history preserved
   - Tool calls included (via =gptel-include-tool-results=)

4. *Resumable Sessions*
   - Full state saved to disk
   - Session registry enables lookup
   - Parent-child links preserved

5. *Non-intrusive UX*
   - Overlay-based progress (no buffer switching)
   - Async execution (non-blocking)
   - User confirmation required (=:confirm t=)

** Architectural Trade-offs

| Aspect | Choice | Benefit | Cost |
|--------|--------|---------|------|
| *Persistence* | Save every response to disk | Complete history, resumable | I/O overhead on every turn |
| *Configuration* | Zero inheritance, agent-only config | Predictable behavior | More setup (preset files, agent defs) |
| *Async* | Tool runs async (=:async t=) | Non-blocking parent | Complex callback handling |
| *Overlay UI* | In-buffer progress display | No context switching | Limited visual space |
| *Nested structure* | 6-level let* nesting | All state in one function | Hard to test individual steps |

** Critical Invariants

1. *Parent Session Required* (Line 158)

   Tool ONLY works in persistent session buffers, not ad-hoc gptel buffers.

2. *Buffer-local Vars Set Before Preset Scope* (Lines 202-205)

   Session state persists outside preset dynamic scope.

3. *Tool Results Included* (Lines 205, 234)

   Ensures tool I/O is saved to context.md for full conversation history.

4. *Auto-save Triggers on Response* (Lines 208-210)

   Every API response triggers buffer save.

5. *Prompt Inserted to Buffer, Request Reads from Buffer* (Lines 212-242)

   Prompt becomes part of buffer content (persisted) rather than ephemeral parameter.

** Integration Points

*Key Dependencies:*
- *gptel-agent*: Provides agent definition loading (=gptel-agent--agents= alist)
- *gptel-session-filesystem*: Directory creation, path helpers
- *gptel-session-metadata*: Metadata file read/write
- *gptel-session-registry*: Global session tracking
- *gptel-session-agent-integration*: Parent-child linking

** Testing Considerations

*How to test:*
1. Create parent persistent session
2. Invoke PersistentAgent tool from parent
3. Verify agent directory created under =agents/=
4. Check scope-plan.yml includes =parent_session_id=
5. Verify overlay appears in parent buffer
6. Monitor overlay updates during tool calls
7. Check final result returned to parent
8. Verify session.md contains full conversation

*Edge cases:*
- Parent session doesn't exist → Error (expected)
- Agent type not in =gptel-agent--agents= → Nil config (graceful degradation)
- Network failure → Error callback invoked, overlay deleted
- User aborts tool confirmation → 'abort callback, overlay deleted
- Buffer killed during execution → Overlay buffer check prevents crash

** Summary & Recommendations

*Architectural Highlights:*

PersistentAgent is a well-structured Emacs Lisp tool that elegantly solves the problem of *persistent, autonomous agent sessions* within gptel. Its architecture emphasizes:

1. *Configuration Isolation* - Zero inheritance from parent ensures predictable agent behavior
2. *Transparent Persistence* - Hook-based auto-save makes session preservation automatic
3. *Non-intrusive UX* - Overlay-based progress display keeps user in parent context
4. *Clean State Management* - FSM pattern with custom handlers separates UI from logic
5. *Resumable Sessions* - Complete history saved enables session browsing and resumption

*Strengths:*
- Leverages Emacs idioms (overlays, buffer-local vars, hooks, markers)
- Clean separation between transient (preset scope) and persistent (session vars) state
- Dual-duty callback elegantly handles both persistence and parent return
- Registry pattern enables advanced features (browsing, linking, resumption)

*Areas for Improvement:*
- *Complexity:* 6-level nested let* blocks could be refactored into helper functions
- *Testing:* No visible test suite (consider ERT tests for critical invariants)
- *Documentation:* Inline comments are sparse; relies on docstrings
- *Error Handling:* Limited error recovery (e.g., filesystem errors during metadata write)

*Recommendation:*

The architecture is *sound and fit for purpose*. The complexity is justified by the feature set (persistence + async + overlay UI + configuration isolation). The "zero inheritance" principle is well-implemented and prevents configuration pollution. The main improvement opportunity is refactoring the nested let* blocks into smaller helper functions for better testability and maintainability.

* Lexical Binding

#+begin_src emacs-lisp :tangle persistent-agent.el
;;; persistent-agent.el --- GPTEL Persistent Agent Tool -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;;; Commentary:

;; Persistent agent tool for gptel that launches specialized agents
;; in persistent session buffers with full tool access and conversation history.

;;; Code:

(require 'gptel)
(require 'gptel-agent)
(require 'gptel-session-filesystem)
(require 'gptel-session-metadata)
(require 'gptel-session-registry)
(require 'gptel-session-logging)
#+end_src

* Constants

Define visual constants used in overlay display.

#+begin_src emacs-lisp
(defconst jf/gptel-persistent-agent--hrule
  (propertize "\n" 'face '(:inherit shadow :underline t :extend t))
  "Horizontal rule for separating overlay sections.")
#+end_src

* Auto-save Hook Function

Automatically save session buffer after each gptel response.

#+begin_src emacs-lisp
(defun jf/gptel--auto-save-session-buffer (&rest _args)
  "Auto-save session buffer after each gptel response.
Hooked into gptel-post-response-functions.
Only saves if buffer has associated file and session directory."
  (when (and jf/gptel--session-dir
             (buffer-file-name))
    (save-buffer)
    ;; Note: scope-plan.yml updated timestamp is managed by scope commands,
    ;; not auto-save
    ))
#+end_src

* Overlay System

Create and manage overlays in the parent buffer to show agent progress.

#+begin_src emacs-lisp
(defun jf/gptel-persistent-agent--create-overlay (where preset description)
  "Create status overlay in parent buffer at WHERE.
PRESET is the preset name (e.g., \"researcher\").
DESCRIPTION is a short summary of the task.
Returns overlay to pass as :context to gptel-request."
  (let* ((buffer (if (markerp where) (marker-buffer where) (current-buffer)))
         (pos (if (markerp where) (marker-position where) where)))
    (with-current-buffer buffer
      (let* ((bounds
              (save-excursion
                (goto-char pos)
                (when (bobp) (insert "\n"))
                (if (and (bolp) (eolp))
                    (cons (1- (point)) (point))
                  (cons (line-beginning-position) (line-end-position)))))
             (ov (make-overlay (car bounds) (cdr bounds) nil t))
             (msg (concat
                   (unless (eq (char-after (car bounds)) 10) "\n")
                   "\n" jf/gptel-persistent-agent--hrule
                   (propertize (concat (capitalize preset) " Task: ")
                               'face 'font-lock-escape-face)
                   (propertize description 'face 'font-lock-doc-face) "\n")))
        (overlay-put ov 'gptel-persistent-agent t)
        (overlay-put ov 'count 0)
        (overlay-put ov 'msg msg)
        (overlay-put ov 'line-prefix "")
        (overlay-put ov 'after-string
                    (concat msg (propertize "Waiting... " 'face 'warning) "\n"
                            jf/gptel-persistent-agent--hrule))
        ov))))
#+end_src

* Custom FSM Handlers

Implement custom FSM handlers for WAIT and TOOL states to update the overlay with progress information.

#+begin_src emacs-lisp
(defun jf/gptel-persistent-agent--indicate-wait (fsm)
  "Update overlay to show waiting status.
FSM is the finite state machine managing the request."
  (when-let* ((info (gptel-fsm-info fsm))
              (ov (plist-get info :context)))
    (let ((count (overlay-get ov 'count)))
      (run-at-time 1.5 nil
        (lambda (overlay count)
          (when (and (overlay-buffer overlay)
                     (eql (overlay-get overlay 'count) count))
            (let* ((task-msg (overlay-get overlay 'msg))
                   (new-info-msg
                    (concat task-msg
                            (concat
                             (propertize "Waiting... " 'face 'warning) "\n"
                             (propertize "\n" 'face
                                        '(:inherit shadow :underline t :extend t))))))
              (overlay-put overlay 'after-string new-info-msg))))
        ov count))))

(defun jf/gptel-persistent-agent--indicate-tool-call (fsm)
  "Update overlay to show tool calls in progress.
FSM is the finite state machine managing the request."
  (when-let* ((info (gptel-fsm-info fsm))
              (tool-use (plist-get info :tool-use))
              (ov (plist-get info :context)))
    (when (overlay-buffer ov)
      (let* ((task-msg (overlay-get ov 'msg))
             (info-count (overlay-get ov 'count))
             (new-info-msg))
        (setq new-info-msg
              (concat task-msg
                      (concat
                       (propertize "Calling Tools... " 'face 'mode-line-emphasis)
                       (if (= info-count 0) "\n" (format "(+%d)\n" info-count))
                       (mapconcat (lambda (call)
                                    (gptel--format-tool-call
                                     (plist-get call :name)
                                     (map-values (plist-get call :args))))
                                  tool-use)
                       "\n" jf/gptel-persistent-agent--hrule)))
        (overlay-put ov 'count (+ info-count (length tool-use)))
        (overlay-put ov 'after-string new-info-msg)))))

(defvar jf/gptel-persistent-agent--fsm-handlers
  `((WAIT ,#'jf/gptel-persistent-agent--indicate-wait
          ,#'gptel--handle-wait)
    (TOOL ,#'jf/gptel-persistent-agent--indicate-tool-call
          ,#'gptel--handle-tool-use))
  "Custom FSM handlers for persistent agents.
Each entry is (STATE UI-HANDLER CORE-HANDLER).")
#+end_src

* Main Tool Function

The core function that creates the agent session and launches the request.

#+begin_src emacs-lisp :tangle persistent-agent.el
(defun jf/gptel-persistent-agent--task (main-cb preset description prompt &optional allowed-paths denied-paths)
  "Launch a persistent agent in a new session buffer.

MAIN-CB is the callback function to invoke with the final result.
PRESET is the preset name (e.g., \"researcher\").
DESCRIPTION is a short (3-5 word) task summary.
PROMPT is the detailed task instructions.
ALLOWED-PATHS is optional array of file paths the agent can access.
DENIED-PATHS is optional array of file paths the agent cannot access.

If ALLOWED-PATHS is not specified, the agent inherits allowed paths from
the parent session's scope plan. If specified as empty array [], agent has
no path restrictions (reads from anywhere).

Creates a nested agent session under the current persistent session,
launches the agent with tool support, displays progress in parent buffer
via overlay, and returns the final result to the parent.

The agent's configuration comes ONLY from the agent definition file,
with zero inheritance from the parent session."
  ;; Validate parent session exists
  (unless jf/gptel--session-dir
    (user-error "PersistentAgent requires parent persistent session"))

  ;; Get where to insert result in parent buffer
  (let ((where (point-marker)))

    ;; Create nested agent directory and session ID
    (let* ((session-dir (jf/gptel--create-agent-directory
                         jf/gptel--session-dir preset description))
           (session-id (jf/gptel--session-id-from-directory session-dir)))

      ;; Copy preset template directly (file-first approach)
      (jf/gptel--copy-preset-template preset session-dir)

      ;; Load preset from copied file (like regular sessions)
      (let* ((preset-plist (jf/gptel--load-preset-from-file session-dir)))
        (unless preset-plist
          (error "Failed to load preset from %s" session-dir))

        ;; Handle allowed/denied paths
        ;; Convert from vectors (JSON arrays) to lists if needed
        (let* ((allowed-paths-list (if (vectorp allowed-paths)
                                      (append allowed-paths nil)
                                    allowed-paths))
               (denied-paths-list (if (vectorp denied-paths)
                                     (append denied-paths nil)
                                   denied-paths))
               ;; If allowed-paths not specified, inherit from parent scope plan
               (effective-allowed-paths
                (or allowed-paths-list
                    ;; Inherit: read parent's scope plan and extract allowed patterns
                    (let ((parent-scope-file (jf/gptel--scope-plan-file-path jf/gptel--session-dir)))
                      (when (file-exists-p parent-scope-file)
                        (let ((parent-plan (with-temp-buffer
                                            (insert-file-contents parent-scope-file)
                                            (jf/gptel-scope--parse-yaml (buffer-string)))))
                          ;; Extract patterns from first tool (they should all be the same)
                          (when-let* ((tools (plist-get parent-plan :tools))
                                     (first-tool-key (car (cl-loop for (k v) on tools by #'cddr
                                                                  when (keywordp k) return k)))
                                     (first-tool (plist-get tools first-tool-key)))
                            (plist-get first-tool :patterns)))))))
               ;; Generate scope plan using preset tools + explicit paths
               (scope-yaml (jf/gptel--generate-scope-plan-yaml
                           session-id
                           "deny-all"        ; Template type
                           nil               ; No projects (agents use worktrees only)
                           session-dir       ; Branch dir (for parsing preset tools)
                           effective-allowed-paths  ; Explicit or inherited paths
                           nil))             ; No activity-org-file needed
               (scope-file (expand-file-name "scope-plan.yml" session-dir)))
          (with-temp-file scope-file
            (insert scope-yaml))
          (jf/gptel--log 'info "Created agent scope plan: %s with %d allowed path(s)"
                        scope-file
                        (length effective-allowed-paths)))

        ;; Parent-child relationship is now tracked via parent_session_id in scope-plan.yml

        ;; Read metadata from scope-plan.yml for registry
        (let ((metadata (or (jf/gptel--read-session-metadata session-dir)
                           ;; Fallback if scope-plan.yml read fails
                           (list :created (format-time-string "%Y-%m-%dT%H:%M:%SZ" nil t)
                                 :type "agent"
                                 :parent-session-id jf/gptel--session-id
                                 :preset preset))))

          ;; Create agent buffer with session infrastructure
          (let* ((buffer-name (format "*gptel-agent:%s:%s*" preset description))
                 (agent-buffer (generate-new-buffer buffer-name))
                 ;; Capture agent tools AFTER buffer initialization
                 (agent-tools nil))

            ;; Initialize buffer with session tracking and preset configuration
            (with-current-buffer agent-buffer
              (markdown-mode)
              (gptel-mode 1)

              ;; Set persistent session vars BEFORE preset application
              (setq-local jf/gptel--session-id session-id)
              (setq-local jf/gptel--session-dir session-dir)
              (setq-local jf/gptel--branch-name "main")
              (setq-local jf/gptel--branch-dir session-dir)

              ;; Apply preset from file (sets backend, model, tools, system message, etc.)
              ;; This replaces manual setting of gptel-tools and gptel-include-tool-results
              (jf/gptel--apply-session-preset preset-plist)
              (jf/gptel--log 'info "Applied preset to agent buffer from file")

              ;; Add auto-save via gptel's post-response hook
              (add-hook 'gptel-post-response-functions
                        #'jf/gptel--auto-save-session-buffer
                        nil t)

              ;; Insert prompt into buffer
              (insert prompt)
              (insert "\n\n")

              ;; Associate buffer with file
              (set-visited-file-name (jf/gptel--context-file-path session-dir))
              (set-buffer-modified-p t)

              ;; CRITICAL: Capture agent's buffer-local tools before leaving buffer context
              ;; This must be INSIDE with-current-buffer, otherwise we get parent's tools
              (setq agent-tools gptel-tools))

            ;; Register session globally with branch info
            ;; Agents don't support branching, so use "main" as default branch and session-dir as branch-dir
            (jf/gptel--register-session session-dir agent-buffer session-id "main" session-dir)

            ;; Create overlay for parent feedback
            (let ((ov (jf/gptel-persistent-agent--create-overlay
                       where preset description)))

              ;; Execute with request-specific overrides
              ;; CRITICAL: Use captured agent-tools, not current buffer's gptel-tools
              ;; We're in parent buffer context here, so gptel-tools would be parent's tools
              (gptel-with-preset
                  (list :include-reasoning nil
                        :use-tools t
                        :use-context nil
                        :include-tool-results t
                        :tools agent-tools)  ; Use captured tools from agent buffer for isolation

                ;; Accumulator for response (must be inside preset scope)
                (let ((partial ""))

                  ;; Launch the agent request
                  ;; PROMPT=nil reads from agent-buffer (which now contains prompt)
                  (gptel-request nil
                    :buffer agent-buffer
                    :position (point-max)  ; Insert response at end of buffer
                    :context ov  ; Parent buffer overlay
                    :fsm (gptel-make-fsm :handlers jf/gptel-persistent-agent--fsm-handlers)

                    :callback
                    (lambda (resp info &optional raw)
                      (let ((ov (plist-get info :context))
                            (buf (plist-get info :buffer)))
                        (pcase resp
                          ;; Network/API error
                          ('nil
                           (delete-overlay ov)
                           (funcall main-cb
                                    (format "Error: Network failure\n%S"
                                            (plist-get info :error))))

                          ;; User aborted tool confirmation
                          ('abort
                           (delete-overlay ov)
                           (funcall main-cb "Error: User aborted agent"))

                          ;; Tool calls pending - wait for completion
                          (`(tool-call . ,calls)
                           (gptel--display-tool-calls calls info))

                          ;; Tool results ready - display in agent buffer
                          (`(tool-result . ,tool-results)
                           (gptel--display-tool-results tool-results info))

                          ;; String response - DUAL DUTY: insert to buffer AND accumulate
                          ((pred stringp)
                           ;; 1. Insert into agent-buffer for persistence
                           (with-current-buffer buf
                             (save-excursion
                               (goto-char (point-max))
                               (if raw
                                   ;; Raw (tool results): properties already set
                                   (insert resp)
                                 ;; Regular response: add properties
                                 (let ((start (point)))
                                   (insert resp)
                                   (when gptel-mode
                                     (put-text-property start (point)
                                                       'gptel 'response))))))

                           ;; 2-3. Accumulate and callback only for non-raw responses
                           (unless raw
                             ;; 2. Accumulate for parent callback
                             (setq partial (concat partial resp))

                             ;; 3. Return to parent when done (not in tool-use)
                             (unless (plist-get info :tool-use)
                               (delete-overlay ov)
                               ;; Apply transformer if present
                               (when-let ((transform (plist-get info :transformer)))
                                 (setq partial (funcall transform partial)))
                               (funcall main-cb partial)))))))))))))))))
#+end_src

* Tool Registration

Register the PersistentAgent tool with gptel.

#+begin_src emacs-lisp
(gptel-make-tool
 :name "PersistentAgent"
 :description "Launch specialized agent in persistent session buffer.

Agents run autonomously and return results in one message.
Sessions persist to disk with full conversation history.

Use for complex research, open-ended exploration, or iterative tasks.

IMPORTANT: You should typically pass allowed_paths to control the agent's file access.
Use the inspect_scope_plan tool to get your current allowed paths, then pass them
to the agent. Example:
  allowed_paths: [\"/path/to/project/**\", \"/another/path/**\"]

If allowed_paths is omitted, the agent inherits your paths automatically.
If you want to restrict the agent to a subset of your paths, specify only those paths.

Note: denied_paths parameter is reserved for future use. Agents always deny
access to .git, runtime, node_modules, and .env paths."

 :function #'jf/gptel-persistent-agent--task

 :args '(( :name "preset"
           :type string
           :enum ["researcher" "executor" "explorer" "planner"]
           :description "Preset name for specialized agent")

         ( :name "description"
           :type string
           :description "Short (3-5 word) task description")

         ( :name "prompt"
           :type string
           :description "Detailed task instructions")

         ( :name "allowed_paths"
           :type array
           :items (:type string)
           :description "Array of glob patterns for paths the agent can access. Use /** suffix for recursive access. Example: [\"/path/to/project/**\"]. If omitted, inherits from parent session. Use inspect_scope_plan to see your current paths.")

         ( :name "denied_paths"
           :type array
           :items (:type string)
           :description "Array of glob patterns for paths the agent cannot access (reserved for future use)"))

 :category "gptel-persistent"
 :async t      ; Runs asynchronously
 :confirm t    ; User confirmation required
 :include t)   ; Results appear in parent buffer
#+end_src

* Footer

#+begin_src emacs-lisp :tangle persistent-agent.el
(provide 'gptel-persistent-agent)
;;; persistent-agent.el ends here
#+end_src
