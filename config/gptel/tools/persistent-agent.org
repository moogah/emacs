#+title: GPTEL Persistent Agent Tool
#+property: header-args:emacs-lisp :tangle persistent-agent.el
#+auto_tangle: y

* Overview

The PersistentAgent tool launches specialized agents in persistent session buffers that:
- Run autonomously with full tool access
- Persist conversations to disk with complete history
- Display real-time progress in parent buffer via overlay
- Maintain bidirectional parent-child session links
- Support resumable sessions

This tool provides persistent agent sessions with buffer-based persistence for seamless integration with gptel's save/restore mechanisms.

** Key Architecture

- *Configuration Isolation*: Uses gptel--apply-preset for proper buffer-local configuration
- *Persistent State*: Buffer-local session vars survive preset scope
- *Parent Feedback*: Overlay system shows progress without context switching
- *Tool Persistence*: All tool I/O saved via gptel-include-tool-results
- *Auto-save*: Automatic buffer save after each response
- *Zero Inheritance*: Agent configured ONLY from agent definition, not parent

* Detailed Architecture

This section provides comprehensive architectural analysis of the PersistentAgent tool implementation.

** Context & Purpose

PersistentAgent is an Emacs Lisp tool that integrates with the =gptel= package (an LLM client for Emacs) to create *persistent, autonomous agent sessions*.

*Domain:* Emacs-based AI assistant infrastructure for literate programming workflows

*Primary Use Cases:*
- Research tasks requiring multiple tool invocations
- Complex exploration of codebases
- Planning and execution that benefits from conversation history
- Hierarchical agent delegation (parent agents spawning child agents)

*Architectural Philosophy:*

The tool emphasizes *"zero inheritance"* - child agents are configured ONLY from their agent definition files, not from parent session state. This prevents configuration pollution and ensures predictable agent behavior.

** Component Architecture

The PersistentAgent tool is part of a larger modular gptel configuration:

#+begin_example
config/gptel/
├── gptel.org/el           - Main loader
├── sessions/              - 8 session management modules
│   ├── constants.el       - Path constants
│   ├── logging.el         - Debug logging
│   ├── filesystem.el      - Directory structure, path helpers
│   ├── registry.el        - Global session tracking (runtime state only)
│   ├── metadata.el        - Read metadata from metadata.yml + scope.yml
│   ├── agent-integration.el - Parent-child session linking
│   ├── commands.el        - User-facing session commands
│   └── activities-integration.el - Activities package integration
├── tools/                 - 10 tool definitions
│   ├── persistent-agent.el  - THIS MODULE
│   ├── filesystem-tools.el
│   └── projectile-tools.el
└── agents/                - 5 agent definition markdown files
    ├── executor.md
    ├── explorer.md
    ├── planner.md
    └── researcher.md
#+end_example

** Component Diagram

#+begin_src mermaid
graph TB
    LLM[Parent LLM Session] -->|invokes tool| Tool[PersistentAgent Tool]
    Tool --> Session[Session Creation]
    Tool --> Overlay[Overlay System]
    Tool --> FSM[Custom FSM Handlers]

    Session --> Dir[Directory Structure]
    Session --> Meta[Metadata Files]
    Session --> Buffer[Agent Buffer]
    Session --> Registry[Global Registry]

    Buffer --> Preset[Agent Preset Config]
    Buffer --> AutoSave[Auto-save Hook]
    Buffer --> Request[gptel-request]

    Request --> FSM
    FSM --> Wait[WAIT State Handler]
    FSM --> ToolState[TOOL State Handler]

    Wait --> Overlay
    ToolState --> Overlay

    Request --> Callback[Response Callback]
    Callback --> Accumulate[Accumulate Response]
    Callback --> Persist[Persist to Buffer]
    Callback --> Return[Return to Parent]

    style Tool fill:#f9f,stroke:#333,stroke-width:4px
    style Buffer fill:#bbf,stroke:#333,stroke-width:2px
    style Overlay fill:#bfb,stroke:#333,stroke-width:2px
#+end_src

** Data Flow

#+begin_src mermaid
sequenceDiagram
    participant P as Parent LLM
    participant T as PersistentAgent Tool
    participant FS as Filesystem
    participant B as Agent Buffer
    participant O as Overlay
    participant API as LLM API

    P->>T: Invoke tool(agent_type, description, prompt)
    T->>T: Validate parent session exists
    T->>FS: Create agent directory
    FS-->>T: session-dir path

    T->>FS: Load agent config (NO parent inheritance)
    T->>FS: Write scope.yml (includes path permissions)
    T->>FS: Write metadata.yml (includes parent_session_id)

    T->>B: Create buffer with session vars
    T->>B: Insert prompt
    T->>B: Add auto-save hook

    T->>O: Create overlay in parent buffer

    T->>API: gptel-request with FSM handlers

    loop Tool calls & responses
        API->>B: Tool call
        B->>O: Update overlay (tool count)
        B->>API: Tool results
        API->>B: Response chunk
        B->>B: Accumulate response
        B->>FS: Auto-save buffer
    end

    API->>B: Final response
    B->>O: Delete overlay
    B->>P: Return accumulated result
#+end_src

** Session Directory Structure

Sessions are persisted to disk with the following structure:

#+begin_example
~/gptel-sessions/
└── parent-session-20260121143022/
    ├── metadata.yml                 # Session metadata (session_id, timestamps, preset)
    ├── scope.yml                    # Path permissions and scope configuration
    ├── session.md                   # Parent conversation
    ├── tools.org                    # Parent tool calls
    └── agents/                      # Agent sessions
        └── researcher-20260121143245-analyze-code/
            ├── metadata.yml         # Agent metadata (includes parent_session_id)
            ├── scope.yml            # Agent-specific scope (NO inheritance)
            ├── session.md           # Agent conversation (auto-saved)
            └── tools.org            # Agent tool calls
#+end_example

** FSM State Handler Flow

#+begin_src mermaid
stateDiagram-v2
    [*] --> WAIT: gptel-request initiated

    WAIT --> TOOL: LLM requests tools
    WAIT --> Response: LLM sends text

    TOOL --> WAIT: Tool results sent

    Response --> Accumulate: String response
    Accumulate --> CheckToolUse: Is in tool-use?

    CheckToolUse --> WAIT: Yes (more turns)
    CheckToolUse --> Complete: No (final response)

    Complete --> [*]: Return to parent

    note right of WAIT
        Custom handler:
        jf/gptel-persistent-agent--indicate-wait
        Updates overlay: "Waiting..."
    end note

    note right of TOOL
        Custom handler:
        jf/gptel-persistent-agent--indicate-tool-call
        Updates overlay: "Tools (+N)"
    end note

    note right of Accumulate
        DUAL DUTY:
        1. Insert to buffer (persist)
        2. Accumulate for parent callback
    end note
#+end_src

** Design Patterns

*** Finite State Machine (FSM) Pattern

*Location:* Lines 129-136

The tool extends gptel's FSM architecture with custom handlers for WAIT and TOOL states.

*Why good:* Clean separation of concerns - UI updates (overlay) are decoupled from core request handling. Each state has a dedicated handler.

*** Overlay-based Progress Indicator Pattern

*Location:* Lines 67-88

Instead of switching buffers or popping up windows, progress is shown via text overlays in the parent buffer.

*Why good:* Non-intrusive UX - user stays in parent context while monitoring agent progress.

*** Configuration Isolation via Dynamic Scoping

*Location:* Lines 230-235

Uses =gptel--apply-preset= to set buffer-local configuration from registered preset.

*Why good:* Prevents configuration leakage between parent and child sessions. Agent gets config ONLY from its preset definition.

*** Hook-based Auto-save Pattern

*Location:* Lines 52-60, 208-210

Leverages gptel's post-response hook infrastructure for automatic persistence.

*Why good:* Automatic, transparent persistence. No manual save calls scattered through code.

*** Registry Pattern

*Location:* Line 223 (via =jf/gptel--register-session=)

Sessions are registered in a global registry (=jf/gptel--session-registry=) that maps session IDs to metadata plists.

*Why good:* Centralized session lookup, enables features like session browsing, parent-child navigation, and resumption.

*** Dual-duty Callback Pattern

*Location:* Lines 273-300

The response callback serves two purposes:
1. Insert responses into buffer (for persistence)
2. Accumulate responses (for parent return value)

*Why good:* Single source of truth for response handling. Ensures buffer content matches what parent receives.

** Anti-patterns & Risks

*** Complex Nested Let Bindings (Medium Risk)

*Location:* Lines 162-300

The main function has 6 nested =let*= blocks creating deep nesting.

*Impact:* Hard to follow data flow, difficult to debug, high cognitive load.

*Mitigation:* Already uses descriptive variable names. Could be refactored into helper functions, but current implementation is manageable for a 150-line function.

*** Implicit Global State Dependencies (Low Risk)

*Location:* Line 158

The function checks buffer-local variable =jf/gptel--session-dir= without explicit parameter.

*Impact:* Function behavior depends on buffer context. Not obvious from signature.

*Mitigation:* This is intentional - the tool is designed to work ONLY in persistent session buffers. The error message clearly states the requirement.

*** Marker Position Mutation Risk (Low Risk)

*Location:* Lines 162, 78

Creates overlay at marker position in parent buffer, potentially modifying buffer content if cursor is at beginning.

*Impact:* Modifies buffer content (inserts newline) if cursor is at buffer start.

*Mitigation:* Minimal - only inserts single newline, and this is expected behavior (can't create overlay at buffer start).

** Architectural Strengths

1. *Clear Separation of Concerns*
   - Session management (filesystem, metadata, registry)
   - UI feedback (overlays)
   - Configuration (preset files, agent definitions)
   - Persistence (auto-save hooks)

2. *Configuration Isolation*
   - Zero inheritance from parent
   - Explicit agent configuration loading
   - Clean buffer-local configuration via =gptel--apply-preset=

3. *Transparent Persistence*
   - Automatic buffer saves via hooks
   - Conversation history preserved
   - Tool calls included (via =gptel-include-tool-results=)

4. *Resumable Sessions*
   - Full state saved to disk
   - Session registry enables lookup
   - Parent-child links preserved

5. *Non-intrusive UX*
   - Overlay-based progress (no buffer switching)
   - Async execution (non-blocking)
   - User confirmation required (=:confirm t=)

** Architectural Trade-offs

| Aspect | Choice | Benefit | Cost |
|--------|--------|---------|------|
| *Persistence* | Save every response to disk | Complete history, resumable | I/O overhead on every turn |
| *Configuration* | Zero inheritance, agent-only config | Predictable behavior | More setup (preset files, agent defs) |
| *Async* | Tool runs async (=:async t=) | Non-blocking parent | Complex callback handling |
| *Overlay UI* | In-buffer progress display | No context switching | Limited visual space |
| *Nested structure* | 6-level let* nesting | All state in one function | Hard to test individual steps |

** Critical Invariants

1. *Parent Session Required* (Line 158)

   Tool ONLY works in persistent session buffers, not ad-hoc gptel buffers.

2. *Buffer-local Vars Set Before Preset Scope* (Lines 202-205)

   Session state persists outside preset dynamic scope.

3. *Tool Results Included* (Lines 205, 234)

   Ensures tool I/O is saved to context.md for full conversation history.

4. *Auto-save Triggers on Response* (Lines 208-210)

   Every API response triggers buffer save.

5. *Prompt Inserted to Buffer, Request Reads from Buffer* (Lines 212-242)

   Prompt becomes part of buffer content (persisted) rather than ephemeral parameter.

** Integration Points

*Key Dependencies:*
- *gptel presets*: Provides preset definitions via =gptel--known-presets=
- *gptel-session-filesystem*: Directory creation, path helpers
- *gptel-session-metadata*: Metadata file read/write
- *gptel-session-registry*: Global session tracking
- *gptel-session-agent-integration*: Parent-child linking

** Testing Considerations

*How to test:*
1. Create parent persistent session
2. Invoke PersistentAgent tool from parent
3. Verify agent directory created under =agents/=
4. Check metadata.yml includes =parent_session_id=
5. Verify overlay appears in parent buffer
6. Monitor overlay updates during tool calls
7. Check final result returned to parent
8. Verify session.md contains full conversation

*Edge cases:*
- Parent session doesn't exist → Error (expected)
- Preset not in =gptel--known-presets= → Error (validated before launch)
- Network failure → Error callback invoked, overlay deleted
- User aborts tool confirmation → 'abort callback, overlay deleted
- Buffer killed during execution → Overlay buffer check prevents crash

** Summary & Recommendations

*Architectural Highlights:*

PersistentAgent is a well-structured Emacs Lisp tool that elegantly solves the problem of *persistent, autonomous agent sessions* within gptel. Its architecture emphasizes:

1. *Configuration Isolation* - Zero inheritance from parent ensures predictable agent behavior
2. *Transparent Persistence* - Hook-based auto-save makes session preservation automatic
3. *Non-intrusive UX* - Overlay-based progress display keeps user in parent context
4. *Clean State Management* - FSM pattern with custom handlers separates UI from logic
5. *Resumable Sessions* - Complete history saved enables session browsing and resumption

*Strengths:*
- Leverages Emacs idioms (overlays, buffer-local vars, hooks, markers)
- Clean separation between transient (preset scope) and persistent (session vars) state
- Dual-duty callback elegantly handles both persistence and parent return
- Registry pattern enables advanced features (browsing, linking, resumption)

*Areas for Improvement:*
- *Complexity:* 6-level nested let* blocks could be refactored into helper functions
- *Testing:* No visible test suite (consider ERT tests for critical invariants)
- *Documentation:* Inline comments are sparse; relies on docstrings
- *Error Handling:* Limited error recovery (e.g., filesystem errors during metadata write)

*Recommendation:*

The architecture is *sound and fit for purpose*. The complexity is justified by the feature set (persistence + async + overlay UI + configuration isolation). The "zero inheritance" principle is well-implemented and prevents configuration pollution. The main improvement opportunity is refactoring the nested let* blocks into smaller helper functions for better testability and maintainability.

* Lexical Binding

#+begin_src emacs-lisp :tangle persistent-agent.el
;;; persistent-agent.el --- GPTEL Persistent Agent Tool -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;;; Commentary:

;; Persistent agent tool for gptel that launches specialized agents
;; in persistent session buffers with full tool access and conversation history.

;;; Code:

(require 'gptel)
(require 'gptel-session-constants)
(require 'gptel-session-filesystem)
(require 'gptel-session-metadata)
(require 'gptel-session-registry)
(require 'gptel-session-logging)
#+end_src

* Constants

Define visual constants used in overlay display.

#+begin_src emacs-lisp
(defconst jf/gptel-persistent-agent--hrule
  (propertize "\n" 'face '(:inherit shadow :underline t :extend t))
  "Horizontal rule for separating overlay sections.")
#+end_src

* Auto-save Hook Function

Automatically save session buffer after each gptel response.

#+begin_src emacs-lisp
(defun jf/gptel--auto-save-session-buffer (&rest _args)
  "Auto-save session buffer after each gptel response.
Hooked into gptel-post-response-functions.
Only saves if buffer has associated file and session directory."
  (when (and jf/gptel--session-dir
             (buffer-file-name))
    (save-buffer)
    ;; Note: metadata.yml updated timestamp is managed by scope commands,
    ;; not auto-save
    ))
#+end_src

* Overlay System

Create and manage overlays in the parent buffer to show agent progress.

#+begin_src emacs-lisp
(defun jf/gptel-persistent-agent--create-overlay (where preset description)
  "Create status overlay in parent buffer at WHERE.
PRESET is the preset name (e.g., \"researcher\").
DESCRIPTION is a short summary of the task.
Returns overlay to pass as :context to gptel-request."
  (let* ((buffer (if (markerp where) (marker-buffer where) (current-buffer)))
         (pos (if (markerp where) (marker-position where) where)))
    (with-current-buffer buffer
      (let* ((bounds
              (save-excursion
                (goto-char pos)
                (when (bobp) (insert "\n"))
                (if (and (bolp) (eolp))
                    (cons (1- (point)) (point))
                  (cons (line-beginning-position) (line-end-position)))))
             (ov (make-overlay (car bounds) (cdr bounds) nil t))
             (msg (concat
                   (unless (eq (char-after (car bounds)) 10) "\n")
                   "\n" jf/gptel-persistent-agent--hrule
                   (propertize (concat (capitalize preset) " Task: ")
                               'face 'font-lock-escape-face)
                   (propertize description 'face 'font-lock-doc-face) "\n")))
        (overlay-put ov 'gptel-persistent-agent t)
        (overlay-put ov 'count 0)
        (overlay-put ov 'msg msg)
        (overlay-put ov 'line-prefix "")
        (overlay-put ov 'after-string
                    (concat msg (propertize "Waiting... " 'face 'warning) "\n"
                            jf/gptel-persistent-agent--hrule))
        ov))))
#+end_src

* Custom FSM Handlers

Implement custom FSM handlers for WAIT and TOOL states to update the overlay with progress information.

#+begin_src emacs-lisp
(defun jf/gptel-persistent-agent--indicate-wait (fsm)
  "Update overlay to show waiting status.
FSM is the finite state machine managing the request."
  (when-let* ((info (gptel-fsm-info fsm))
              (ov (plist-get info :context)))
    (let ((count (overlay-get ov 'count)))
      (run-at-time 1.5 nil
        (lambda (overlay count)
          (when (and (overlay-buffer overlay)
                     (eql (overlay-get overlay 'count) count))
            (let* ((task-msg (overlay-get overlay 'msg))
                   (new-info-msg
                    (concat task-msg
                            (concat
                             (propertize "Waiting... " 'face 'warning) "\n"
                             (propertize "\n" 'face
                                        '(:inherit shadow :underline t :extend t))))))
              (overlay-put overlay 'after-string new-info-msg))))
        ov count))))

(defun jf/gptel-persistent-agent--indicate-tool-call (fsm)
  "Update overlay to show tool calls in progress.
FSM is the finite state machine managing the request."
  (when-let* ((info (gptel-fsm-info fsm))
              (tool-use (plist-get info :tool-use))
              (ov (plist-get info :context)))
    (when (overlay-buffer ov)
      (let* ((task-msg (overlay-get ov 'msg))
             (info-count (overlay-get ov 'count))
             (new-info-msg))
        (setq new-info-msg
              (concat task-msg
                      (concat
                       (propertize "Calling Tools... " 'face 'mode-line-emphasis)
                       (if (= info-count 0) "\n" (format "(+%d)\n" info-count))
                       (mapconcat (lambda (call)
                                    (gptel--format-tool-call
                                     (plist-get call :name)
                                     (map-values (plist-get call :args))))
                                  tool-use)
                       "\n" jf/gptel-persistent-agent--hrule)))
        (overlay-put ov 'count (+ info-count (length tool-use)))
        (overlay-put ov 'after-string new-info-msg)))))

(defvar jf/gptel-persistent-agent--fsm-handlers
  `((WAIT ,#'jf/gptel-persistent-agent--indicate-wait
          ,#'gptel--handle-wait)
    (TOOL ,#'jf/gptel-persistent-agent--indicate-tool-call
          ,#'gptel--handle-tool-use))
  "Custom FSM handlers for persistent agents.
Each entry is (STATE UI-HANDLER CORE-HANDLER).")
#+end_src

* Main Tool Function

The core function that creates the agent session and launches the request.

#+begin_src emacs-lisp :tangle persistent-agent.el
(defun jf/gptel-persistent-agent--task (main-cb preset description prompt &optional allowed-paths denied-paths)
  "Launch a persistent agent in a new session buffer.

MAIN-CB is the callback function to invoke with the final result.
PRESET is the preset name (e.g., \"researcher\").
DESCRIPTION is a short (3-5 word) task summary.
PROMPT is the detailed task instructions.
ALLOWED-PATHS is optional array of file paths the agent can access.
DENIED-PATHS is optional array of file paths the agent cannot access.

If ALLOWED-PATHS is not specified or specified as empty array [], the agent
has no read permissions. Paths are never inherited from the parent session -
they must be explicitly provided.

Creates a nested agent session under the current persistent session,
launches the agent with tool support, displays progress in parent buffer
via overlay, and returns the final result to the parent.

The agent's configuration comes ONLY from the preset in
gptel--known-presets, with zero inheritance from the parent session."
  ;; Validate parent session exists
  (unless jf/gptel--session-dir
    (user-error "PersistentAgent requires parent persistent session"))

  ;; Validate preset exists in registry
  (let ((preset-name (intern preset)))
    (unless (gptel-get-preset preset-name)
      (user-error "Preset '%s' not found in gptel--known-presets" preset)))

  ;; Get where to insert result in parent buffer
  (let ((where (point-marker)))

    ;; Create nested agent directory and session ID
    ;; Agents are created under the current branch, not at session root
    (let* ((session-dir (jf/gptel--create-agent-directory
                         jf/gptel--branch-dir preset description))
           (session-id (jf/gptel--session-id-from-directory session-dir)))

      ;; Write scope.yml with paths from allowed_paths parameter
      ;; Zero inheritance: paths come from tool invocation, not parent
      (let* ((allowed-paths-list (if (vectorp allowed-paths)
                                     (append allowed-paths nil)
                                   allowed-paths))
             (denied-paths-list (if (vectorp denied-paths)
                                    (append denied-paths nil)
                                  denied-paths))
             (scope-file (expand-file-name jf/gptel-session--scope-file session-dir)))
        (with-temp-file scope-file
          (insert "paths:\n")
          (insert "  read:\n")
          (if allowed-paths-list
              (dolist (p allowed-paths-list)
                (insert (format "    - \"%s\"\n" p)))
            (insert "    []\n"))
          (insert "  write:\n")
          (insert "    - \"/tmp/**\"\n")
          (insert "  deny:\n")
          (dolist (p (or denied-paths-list
                         '("**/.git/**" "**/runtime/**" "**/.env" "**/node_modules/**")))
            (insert (format "    - \"%s\"\n" p))))
        (jf/gptel--log 'info "Created agent scope.yml with %d read path(s)"
                      (length allowed-paths-list)))

      ;; Write metadata.yml with session metadata
      (let ((metadata-file (expand-file-name jf/gptel-session--metadata-file session-dir))
            (timestamp (format-time-string "%Y-%m-%dT%H:%M:%SZ")))
        (with-temp-file metadata-file
          (insert (format "version: \"3.0\"\n"))
          (insert (format "session_id: \"%s\"\n" session-id))
          (insert (format "created: \"%s\"\n" timestamp))
          (insert (format "updated: \"%s\"\n" timestamp))
          (insert (format "type: \"agent\"\n"))
          (insert (format "parent_session_id: \"%s\"\n" jf/gptel--session-id))
          (insert (format "preset: \"%s\"\n" preset)))
        (jf/gptel--log 'info "Created agent metadata.yml: %s" metadata-file))

      ;; Create agent buffer with session infrastructure
      (let* ((buffer-name (format "*gptel-agent:%s:%s*" preset description))
             (agent-buffer (generate-new-buffer buffer-name)))

        ;; Initialize buffer with session tracking and preset configuration
        (with-current-buffer agent-buffer
          (markdown-mode)

          ;; Set persistent session vars BEFORE preset application
          (setq-local jf/gptel--session-id session-id)
          (setq-local jf/gptel--session-dir session-dir)
          (setq-local jf/gptel--branch-name "main")
          (setq-local jf/gptel--branch-dir session-dir)

          ;; Apply preset via upstream with buffer-local setter
          (gptel--apply-preset (intern preset)
                               (lambda (var val) (set (make-local-variable var) val)))

          ;; Enable gptel-mode AFTER preset application
          (gptel-mode 1)

          ;; Add auto-save via gptel's post-response hook
          (add-hook 'gptel-post-response-functions
                    #'jf/gptel--auto-save-session-buffer
                    nil t)

          ;; Insert prompt into buffer
          (insert prompt)
          (insert "\n\n")

          ;; Associate buffer with file
          (set-visited-file-name (jf/gptel--context-file-path session-dir))
          (set-buffer-modified-p t))

        ;; Register session globally with branch info
        ;; Agents don't support branching, so use "main" as default branch and session-dir as branch-dir
        (jf/gptel--register-session session-dir agent-buffer session-id "main" session-dir)

        ;; Create overlay for parent feedback
        (let ((ov (jf/gptel-persistent-agent--create-overlay
                   where preset description)))

          ;; Execute request from agent buffer
          ;; Buffer-local settings from gptel--apply-preset are sufficient
          (let ((partial ""))
            (gptel-request nil
              :buffer agent-buffer
              :position (with-current-buffer agent-buffer (point-max))
              :context ov
              :fsm (gptel-make-fsm :handlers jf/gptel-persistent-agent--fsm-handlers)
              :use-tools t
              :include-tool-results t

              :callback
              (lambda (resp info &optional raw)
                (let ((ov (plist-get info :context))
                      (buf (plist-get info :buffer)))
                  (pcase resp
                    ;; Network/API error
                    ('nil
                     (delete-overlay ov)
                     (funcall main-cb
                              (format "Error: Network failure\n%S"
                                      (plist-get info :error))))

                    ;; User aborted tool confirmation
                    ('abort
                     (delete-overlay ov)
                     (funcall main-cb "Error: User aborted agent"))

                    ;; Tool calls pending - wait for completion
                    (`(tool-call . ,calls)
                     (gptel--display-tool-calls calls info))

                    ;; Tool results ready - display in agent buffer
                    (`(tool-result . ,tool-results)
                     (gptel--display-tool-results tool-results info))

                    ;; String response - DUAL DUTY: insert to buffer AND accumulate
                    ((pred stringp)
                     ;; 1. Insert into agent-buffer for persistence
                     (with-current-buffer buf
                       (save-excursion
                         (goto-char (point-max))
                         (if raw
                             ;; Raw (tool results): properties already set
                             (insert resp)
                           ;; Regular response: add properties
                           (let ((start (point)))
                             (insert resp)
                             (when gptel-mode
                               (put-text-property start (point)
                                                 'gptel 'response))))))

                     ;; 2-3. Accumulate and callback only for non-raw responses
                     (unless raw
                       ;; 2. Accumulate for parent callback
                       (setq partial (concat partial resp))

                       ;; 3. Return to parent when done (not in tool-use)
                       (unless (plist-get info :tool-use)
                         (delete-overlay ov)
                         ;; Apply transformer if present
                         (when-let ((transform (plist-get info :transformer)))
                           (setq partial (funcall transform partial)))
                         (funcall main-cb partial))))))))))))))
#+end_src

* Tool Registration

Register the PersistentAgent tool with gptel.

#+begin_src emacs-lisp
(gptel-make-tool
 :name "PersistentAgent"
 :description "Launch specialized agent in persistent session buffer.

Agents run autonomously and return results in one message.
Sessions persist to disk with full conversation history.

Use for complex research, open-ended exploration, or iterative tasks.

IMPORTANT: You should typically pass allowed_paths to control the agent's file access.
Use the read_file tool on scope.yml to get your current allowed paths, then pass them
to the agent. Example:
  allowed_paths: [\"/path/to/project/**\", \"/another/path/**\"]

If allowed_paths is omitted or empty, the agent has NO read access to any paths.
You must explicitly provide paths for the agent to read files.

Note: denied_paths parameter is reserved for future use. Agents always deny
access to .git, runtime, node_modules, and .env paths."

 :function #'jf/gptel-persistent-agent--task

 :args '(( :name "preset"
           :type string
           :enum ["researcher" "executor" "explore" "planner"]
           :description "Preset name for specialized agent")

         ( :name "description"
           :type string
           :description "Short (3-5 word) task description")

         ( :name "prompt"
           :type string
           :description "Detailed task instructions")

         ( :name "allowed_paths"
           :type array
           :items (:type string)
           :description "Array of glob patterns for paths the agent can access. Use /** suffix for recursive access. Example: [\"/path/to/project/**\"]. If omitted, agent has no read access. Use read_file on scope.yml to see your current paths.")

         ( :name "denied_paths"
           :type array
           :items (:type string)
           :description "Array of glob patterns for paths the agent cannot access (reserved for future use)"))

 :category "gptel-persistent"
 :async t      ; Runs asynchronously
 :confirm t    ; User confirmation required
 :include t)   ; Results appear in parent buffer
#+end_src

* Footer

#+begin_src emacs-lisp :tangle persistent-agent.el
(provide 'gptel-persistent-agent)
;;; persistent-agent.el ends here
#+end_src
