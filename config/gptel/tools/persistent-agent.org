#+title: GPTEL Persistent Agent Tool
#+property: header-args:emacs-lisp :tangle persistent-agent.el
#+auto_tangle: y

* Overview

The PersistentAgent tool launches specialized agents in persistent session buffers that:
- Run autonomously with full tool access
- Persist conversations to disk with complete history
- Display real-time progress in parent buffer via overlay
- Maintain bidirectional parent-child session links
- Support resumable sessions

This tool replicates gptel-agent's superior architecture while maintaining buffer-based persistence for seamless integration with gptel's save/restore mechanisms.

** Key Architecture

- *Configuration Isolation*: Uses gptel-with-preset for proper dynamic scope
- *Persistent State*: Buffer-local session vars survive preset scope
- *Parent Feedback*: Overlay system shows progress without context switching
- *Tool Persistence*: All tool I/O saved via gptel-include-tool-results
- *Auto-save*: Automatic buffer save after each response
- *Zero Inheritance*: Agent configured ONLY from agent definition, not parent

* Detailed Architecture

This section provides comprehensive architectural analysis of the PersistentAgent tool implementation.

** Context & Purpose

PersistentAgent is an Emacs Lisp tool that integrates with the =gptel= package (an LLM client for Emacs) to create *persistent, autonomous agent sessions*.

*Domain:* Emacs-based AI assistant infrastructure for literate programming workflows

*Primary Use Cases:*
- Research tasks requiring multiple tool invocations
- Complex exploration of codebases
- Planning and execution that benefits from conversation history
- Hierarchical agent delegation (parent agents spawning child agents)

*Architectural Philosophy:*

The tool emphasizes *"zero inheritance"* - child agents are configured ONLY from their agent definition files, not from parent session state. This prevents configuration pollution and ensures predictable agent behavior.

** Component Architecture

The PersistentAgent tool is part of a larger modular gptel configuration:

#+begin_example
config/gptel/
├── gptel.org/el           - Main loader
├── sessions/              - 9 session management modules
│   ├── constants.el       - Path constants
│   ├── logging.el         - Debug logging
│   ├── filesystem.el      - Directory structure, path helpers
│   ├── registry.el        - Global session tracking (runtime state only)
│   ├── metadata.el        - Read metadata from scope-plan.yml + preset.md
│   ├── subagent.el        - Parent-child session linking
│   ├── commands.el        - User-facing session commands
│   ├── transient.el       - Transient menu UI (currently disabled)
│   └── activities-integration.el - Activities package integration
├── tools/                 - 10 tool definitions
│   ├── persistent-agent.el  - THIS MODULE
│   ├── filesystem-tools.el
│   └── projectile-tools.el
└── agents/                - 5 agent definition markdown files
    ├── executor.md
    ├── explorer.md
    ├── planner.md
    └── researcher.md
#+end_example

** Component Diagram

#+begin_src mermaid
graph TB
    LLM[Parent LLM Session] -->|invokes tool| Tool[PersistentAgent Tool]
    Tool --> Session[Session Creation]
    Tool --> Overlay[Overlay System]
    Tool --> FSM[Custom FSM Handlers]

    Session --> Dir[Directory Structure]
    Session --> Meta[Metadata Files]
    Session --> Buffer[Agent Buffer]
    Session --> Registry[Global Registry]

    Buffer --> Preset[Agent Preset Config]
    Buffer --> AutoSave[Auto-save Hook]
    Buffer --> Request[gptel-request]

    Request --> FSM
    FSM --> Wait[WAIT State Handler]
    FSM --> ToolState[TOOL State Handler]

    Wait --> Overlay
    ToolState --> Overlay

    Request --> Callback[Response Callback]
    Callback --> Accumulate[Accumulate Response]
    Callback --> Persist[Persist to Buffer]
    Callback --> Return[Return to Parent]

    style Tool fill:#f9f,stroke:#333,stroke-width:4px
    style Buffer fill:#bbf,stroke:#333,stroke-width:2px
    style Overlay fill:#bfb,stroke:#333,stroke-width:2px
#+end_src

** Data Flow

#+begin_src mermaid
sequenceDiagram
    participant P as Parent LLM
    participant T as PersistentAgent Tool
    participant FS as Filesystem
    participant B as Agent Buffer
    participant O as Overlay
    participant API as LLM API

    P->>T: Invoke tool(agent_type, description, prompt)
    T->>T: Validate parent session exists
    T->>FS: Create subagent directory
    FS-->>T: session-dir path

    T->>FS: Load agent config (NO parent inheritance)
    T->>FS: Write scope-plan.yml (includes parent_session_id)
    T->>FS: Write preset.md

    T->>B: Create buffer with session vars
    T->>B: Insert prompt
    T->>B: Add auto-save hook

    T->>O: Create overlay in parent buffer

    T->>API: gptel-request with FSM handlers

    loop Tool calls & responses
        API->>B: Tool call
        B->>O: Update overlay (tool count)
        B->>API: Tool results
        API->>B: Response chunk
        B->>B: Accumulate response
        B->>FS: Auto-save buffer
    end

    API->>B: Final response
    B->>O: Delete overlay
    B->>P: Return accumulated result
#+end_src

** Session Directory Structure

Sessions are persisted to disk with the following structure:

#+begin_example
~/gptel-sessions/
└── parent-session-20260121143022/
    ├── scope-plan.yml               # Session metadata and permissions
    ├── preset.md                    # Backend and model configuration
    ├── session.md                   # Parent conversation
    ├── tools.org                    # Parent tool calls
    └── subagents/                   # Subagent sessions
        └── researcher-20260121143245-analyze-code/
            ├── scope-plan.yml       # Subagent metadata (includes parent_session_id)
            ├── preset.md            # Agent-specific config (NO inheritance)
            ├── session.md           # Subagent conversation (auto-saved)
            └── tools.org            # Subagent tool calls
#+end_example

** FSM State Handler Flow

#+begin_src mermaid
stateDiagram-v2
    [*] --> WAIT: gptel-request initiated

    WAIT --> TOOL: LLM requests tools
    WAIT --> Response: LLM sends text

    TOOL --> WAIT: Tool results sent

    Response --> Accumulate: String response
    Accumulate --> CheckToolUse: Is in tool-use?

    CheckToolUse --> WAIT: Yes (more turns)
    CheckToolUse --> Complete: No (final response)

    Complete --> [*]: Return to parent

    note right of WAIT
        Custom handler:
        jf/gptel-persistent-agent--indicate-wait
        Updates overlay: "Waiting..."
    end note

    note right of TOOL
        Custom handler:
        jf/gptel-persistent-agent--indicate-tool-call
        Updates overlay: "Tools (+N)"
    end note

    note right of Accumulate
        DUAL DUTY:
        1. Insert to buffer (persist)
        2. Accumulate for parent callback
    end note
#+end_src

** Design Patterns

*** Finite State Machine (FSM) Pattern

*Location:* Lines 129-136

The tool extends gptel's FSM architecture with custom handlers for WAIT and TOOL states.

*Why good:* Clean separation of concerns - UI updates (overlay) are decoupled from core request handling. Each state has a dedicated handler.

*** Overlay-based Progress Indicator Pattern

*Location:* Lines 67-88

Instead of switching buffers or popping up windows, progress is shown via text overlays in the parent buffer.

*Why good:* Non-intrusive UX - user stays in parent context while monitoring subagent progress. Similar to how gptel-agent works.

*** Configuration Isolation via Dynamic Scoping

*Location:* Lines 230-235

Uses =gptel-with-preset= macro to create a clean dynamic scope for agent configuration.

*Why good:* Prevents configuration leakage between parent and child sessions. Agent gets config ONLY from its definition file.

*** Hook-based Auto-save Pattern

*Location:* Lines 52-60, 208-210

Leverages gptel's post-response hook infrastructure for automatic persistence.

*Why good:* Automatic, transparent persistence. No manual save calls scattered through code.

*** Registry Pattern

*Location:* Line 223 (via =jf/gptel--register-session=)

Sessions are registered in a global registry (=jf/gptel--session-registry=) that maps session IDs to metadata plists.

*Why good:* Centralized session lookup, enables features like session browsing, parent-child navigation, and resumption.

*** Dual-duty Callback Pattern

*Location:* Lines 273-300

The response callback serves two purposes:
1. Insert responses into buffer (for persistence)
2. Accumulate responses (for parent return value)

*Why good:* Single source of truth for response handling. Ensures buffer content matches what parent receives.

** Anti-patterns & Risks

*** Complex Nested Let Bindings (Medium Risk)

*Location:* Lines 162-300

The main function has 6 nested =let*= blocks creating deep nesting.

*Impact:* Hard to follow data flow, difficult to debug, high cognitive load.

*Mitigation:* Already uses descriptive variable names. Could be refactored into helper functions, but current implementation is manageable for a 150-line function.

*** Implicit Global State Dependencies (Low Risk)

*Location:* Line 158

The function checks buffer-local variable =jf/gptel--session-dir= without explicit parameter.

*Impact:* Function behavior depends on buffer context. Not obvious from signature.

*Mitigation:* This is intentional - the tool is designed to work ONLY in persistent session buffers. The error message clearly states the requirement.

*** Marker Position Mutation Risk (Low Risk)

*Location:* Lines 162, 78

Creates overlay at marker position in parent buffer, potentially modifying buffer content if cursor is at beginning.

*Impact:* Modifies buffer content (inserts newline) if cursor is at buffer start.

*Mitigation:* Minimal - only inserts single newline, and this is expected behavior (can't create overlay at buffer start).

** Architectural Strengths

1. *Clear Separation of Concerns*
   - Session management (filesystem, metadata, registry)
   - UI feedback (overlays)
   - Configuration (preset files, agent definitions)
   - Persistence (auto-save hooks)

2. *Configuration Isolation*
   - Zero inheritance from parent
   - Explicit agent configuration loading
   - Clean dynamic scope via =gptel-with-preset=

3. *Transparent Persistence*
   - Automatic buffer saves via hooks
   - Conversation history preserved
   - Tool calls included (via =gptel-include-tool-results=)

4. *Resumable Sessions*
   - Full state saved to disk
   - Session registry enables lookup
   - Parent-child links preserved

5. *Non-intrusive UX*
   - Overlay-based progress (no buffer switching)
   - Async execution (non-blocking)
   - User confirmation required (=:confirm t=)

** Architectural Trade-offs

| Aspect | Choice | Benefit | Cost |
|--------|--------|---------|------|
| *Persistence* | Save every response to disk | Complete history, resumable | I/O overhead on every turn |
| *Configuration* | Zero inheritance, agent-only config | Predictable behavior | More setup (preset files, agent defs) |
| *Async* | Tool runs async (=:async t=) | Non-blocking parent | Complex callback handling |
| *Overlay UI* | In-buffer progress display | No context switching | Limited visual space |
| *Nested structure* | 6-level let* nesting | All state in one function | Hard to test individual steps |

** Critical Invariants

1. *Parent Session Required* (Line 158)

   Tool ONLY works in persistent session buffers, not ad-hoc gptel buffers.

2. *Buffer-local Vars Set Before Preset Scope* (Lines 202-205)

   Session state persists outside preset dynamic scope.

3. *Tool Results Included* (Lines 205, 234)

   Ensures tool I/O is saved to context.md for full conversation history.

4. *Auto-save Triggers on Response* (Lines 208-210)

   Every API response triggers buffer save.

5. *Prompt Inserted to Buffer, Request Reads from Buffer* (Lines 212-242)

   Prompt becomes part of buffer content (persisted) rather than ephemeral parameter.

** Integration Points

*Key Dependencies:*
- *gptel-agent*: Provides agent definition loading (=gptel-agent--agents= alist)
- *gptel-session-filesystem*: Directory creation, path helpers
- *gptel-session-metadata*: Metadata file read/write
- *gptel-session-registry*: Global session tracking
- *gptel-session-subagent*: Parent-child linking

** Testing Considerations

*How to test:*
1. Create parent persistent session
2. Invoke PersistentAgent tool from parent
3. Verify subagent directory created under =subagents/=
4. Check scope-plan.yml includes =parent_session_id=
5. Verify overlay appears in parent buffer
6. Monitor overlay updates during tool calls
7. Check final result returned to parent
8. Verify session.md contains full conversation

*Edge cases:*
- Parent session doesn't exist → Error (expected)
- Agent type not in =gptel-agent--agents= → Nil config (graceful degradation)
- Network failure → Error callback invoked, overlay deleted
- User aborts tool confirmation → 'abort callback, overlay deleted
- Buffer killed during execution → Overlay buffer check prevents crash

** Summary & Recommendations

*Architectural Highlights:*

PersistentAgent is a well-structured Emacs Lisp tool that elegantly solves the problem of *persistent, autonomous agent sessions* within gptel. Its architecture emphasizes:

1. *Configuration Isolation* - Zero inheritance from parent ensures predictable agent behavior
2. *Transparent Persistence* - Hook-based auto-save makes session preservation automatic
3. *Non-intrusive UX* - Overlay-based progress display keeps user in parent context
4. *Clean State Management* - FSM pattern with custom handlers separates UI from logic
5. *Resumable Sessions* - Complete history saved enables session browsing and resumption

*Strengths:*
- Leverages Emacs idioms (overlays, buffer-local vars, hooks, markers)
- Clean separation between transient (preset scope) and persistent (session vars) state
- Dual-duty callback elegantly handles both persistence and parent return
- Registry pattern enables advanced features (browsing, linking, resumption)

*Areas for Improvement:*
- *Complexity:* 6-level nested let* blocks could be refactored into helper functions
- *Testing:* No visible test suite (consider ERT tests for critical invariants)
- *Documentation:* Inline comments are sparse; relies on docstrings
- *Error Handling:* Limited error recovery (e.g., filesystem errors during metadata write)

*Recommendation:*

The architecture is *sound and fit for purpose*. The complexity is justified by the feature set (persistence + async + overlay UI + configuration isolation). The "zero inheritance" principle is well-implemented and prevents configuration pollution. The main improvement opportunity is refactoring the nested let* blocks into smaller helper functions for better testability and maintainability.

* Lexical Binding

#+begin_src emacs-lisp
;;; persistent-agent.el --- GPTEL Persistent Agent Tool -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;;; Commentary:

;; Persistent agent tool for gptel that launches specialized agents
;; in persistent session buffers with full tool access and conversation history.

;;; Code:

(require 'gptel)
(require 'gptel-agent)
(require 'gptel-session-filesystem)
(require 'gptel-session-metadata)
(require 'gptel-session-registry)
(require 'gptel-session-logging)
#+end_src

* Constants

Define visual constants used in overlay display.

#+begin_src emacs-lisp
(defconst jf/gptel-persistent-agent--hrule
  (propertize "\n" 'face '(:inherit shadow :underline t :extend t))
  "Horizontal rule for separating overlay sections.")
#+end_src

* Auto-save Hook Function

Automatically save session buffer after each gptel response.

#+begin_src emacs-lisp
(defun jf/gptel--auto-save-session-buffer (&rest _args)
  "Auto-save session buffer after each gptel response.
Hooked into gptel-post-response-functions.
Only saves if buffer has associated file and session directory."
  (when (and jf/gptel--session-dir
             (buffer-file-name))
    (save-buffer)
    ;; Note: scope-plan.yml updated timestamp is managed by scope commands,
    ;; not auto-save
    ))
#+end_src

* Overlay System

Create and manage overlays in the parent buffer to show agent progress.

#+begin_src emacs-lisp
(defun jf/gptel-persistent-agent--create-overlay (where agent-type description)
  "Create status overlay in parent buffer at WHERE.
AGENT-TYPE is the type of agent (e.g., \"researcher\").
DESCRIPTION is a short summary of the task.
Returns overlay to pass as :context to gptel-request."
  (let* ((buffer (if (markerp where) (marker-buffer where) (current-buffer)))
         (pos (if (markerp where) (marker-position where) where)))
    (with-current-buffer buffer
      (let* ((bounds
              (save-excursion
                (goto-char pos)
                (when (bobp) (insert "\n"))
                (if (and (bolp) (eolp))
                    (cons (1- (point)) (point))
                  (cons (line-beginning-position) (line-end-position)))))
             (ov (make-overlay (car bounds) (cdr bounds) nil t))
             (msg (concat
                   (unless (eq (char-after (car bounds)) 10) "\n")
                   "\n" jf/gptel-persistent-agent--hrule
                   (propertize (concat (capitalize agent-type) " Task: ")
                               'face 'font-lock-escape-face)
                   (propertize description 'face 'font-lock-doc-face) "\n")))
        (overlay-put ov 'gptel-persistent-agent t)
        (overlay-put ov 'count 0)
        (overlay-put ov 'msg msg)
        (overlay-put ov 'line-prefix "")
        (overlay-put ov 'after-string
                    (concat msg (propertize "Waiting... " 'face 'warning) "\n"
                            jf/gptel-persistent-agent--hrule))
        ov))))
#+end_src

* Custom FSM Handlers

Implement custom FSM handlers for WAIT and TOOL states to update the overlay with progress information.

#+begin_src emacs-lisp
(defun jf/gptel-persistent-agent--indicate-wait (fsm)
  "Update overlay to show waiting status.
FSM is the finite state machine managing the request."
  (when-let* ((info (gptel-fsm-info fsm))
              (ov (plist-get info :context)))
    (let ((count (overlay-get ov 'count)))
      (run-at-time 1.5 nil
        (lambda (overlay count)
          (when (and (overlay-buffer overlay)
                     (eql (overlay-get overlay 'count) count))
            (let* ((task-msg (overlay-get overlay 'msg))
                   (new-info-msg
                    (concat task-msg
                            (concat
                             (propertize "Waiting... " 'face 'warning) "\n"
                             (propertize "\n" 'face
                                        '(:inherit shadow :underline t :extend t))))))
              (overlay-put overlay 'after-string new-info-msg))))
        ov count))))

(defun jf/gptel-persistent-agent--indicate-tool-call (fsm)
  "Update overlay to show tool calls in progress.
FSM is the finite state machine managing the request."
  (when-let* ((info (gptel-fsm-info fsm))
              (tool-use (plist-get info :tool-use))
              (ov (plist-get info :context)))
    (when (overlay-buffer ov)
      (let* ((task-msg (overlay-get ov 'msg))
             (info-count (overlay-get ov 'count))
             (new-info-msg))
        (setq new-info-msg
              (concat task-msg
                      (concat
                       (propertize "Calling Tools... " 'face 'mode-line-emphasis)
                       (if (= info-count 0) "\n" (format "(+%d)\n" info-count))
                       (mapconcat (lambda (call)
                                    (gptel--format-tool-call
                                     (plist-get call :name)
                                     (map-values (plist-get call :args))))
                                  tool-use)
                       "\n" jf/gptel-persistent-agent--hrule)))
        (overlay-put ov 'count (+ info-count (length tool-use)))
        (overlay-put ov 'after-string new-info-msg)))))

(defvar jf/gptel-persistent-agent--fsm-handlers
  `((WAIT ,#'jf/gptel-persistent-agent--indicate-wait
          ,#'gptel--handle-wait)
    (TOOL ,#'jf/gptel-persistent-agent--indicate-tool-call
          ,#'gptel--handle-tool-use))
  "Custom FSM handlers for persistent agents.
Each entry is (STATE UI-HANDLER CORE-HANDLER).")
#+end_src

* Main Tool Function

The core function that creates the agent session and launches the request.

#+begin_src emacs-lisp
(defun jf/gptel-persistent-agent--task (main-cb agent_type description prompt)
  "Launch a persistent agent in a new session buffer.

MAIN-CB is the callback function to invoke with the final result.
AGENT_TYPE is the type of agent (e.g., \"researcher\").
DESCRIPTION is a short (3-5 word) task summary.
PROMPT is the detailed task instructions.

Creates a nested subagent session under the current persistent session,
launches the agent with tool support, displays progress in parent buffer
via overlay, and returns the final result to the parent.

The agent's configuration comes ONLY from the agent definition file,
with zero inheritance from the parent session."
  ;; Validate parent session exists
  (unless jf/gptel--session-dir
    (user-error "PersistentAgent requires parent persistent session"))

  ;; Get where to insert result in parent buffer
  (let ((where (point-marker)))

    ;; Create nested subagent directory and session ID
    (let* ((session-dir (jf/gptel--create-subagent-directory
                         jf/gptel--session-dir agent_type description))
           (session-id (jf/gptel--session-id-from-directory session-dir)))

      ;; Get agent config to determine backend/model (NO parent inheritance)
      (let* ((agent-config (cdr (assoc agent_type gptel-agent--agents)))
             (agent-backend-name (or (plist-get agent-config :backend)
                                    (gptel-backend-name gptel-backend)))
             (agent-model (or (plist-get agent-config :model)
                             gptel-model)))

        ;; Create scope-plan.yml with subagent fields (deny-all template)
        (let* ((scope-yaml (jf/gptel-scope--template-deny-all
                           session-id "subagent" jf/gptel--session-id agent_type))
               (scope-file (expand-file-name "scope-plan.yml" session-dir)))
          (with-temp-file scope-file
            (insert scope-yaml))
          (jf/gptel--log 'info "Created subagent scope plan: %s" scope-file))

        ;; Parent-child relationship is now tracked via parent_session_id in scope-plan.yml

        ;; Create preset file ONLY from agent definition (NO parent inheritance)
        (let* ((preset-plist (copy-sequence agent-config)))
          ;; Override to ensure tool results are included
          (plist-put preset-plist :include-tool-results t)
          (jf/gptel--write-preset-file session-dir preset-plist))

        ;; Read metadata from scope-plan.yml for registry
        (let ((metadata (or (jf/gptel--read-session-metadata session-dir)
                           ;; Fallback if scope-plan.yml read fails
                           (list :created (format-time-string "%Y-%m-%dT%H:%M:%SZ" nil t)
                                 :type "subagent"
                                 :parent-session-id jf/gptel--session-id
                                 :agent-type agent_type))))

          ;; Create agent buffer with session infrastructure
          (let* ((buffer-name (format "*gptel-agent:%s:%s*" agent_type description))
                 (agent-buffer (generate-new-buffer buffer-name)))

            ;; Initialize buffer with session tracking and auto-save
            (with-current-buffer agent-buffer
              (markdown-mode)
              (gptel-mode 1)

              ;; Set persistent session vars BEFORE preset scope
              (setq-local jf/gptel--session-id session-id)
              (setq-local jf/gptel--session-dir session-dir)
              (setq-local gptel-tools nil)  ; Prevent inheritance EXPLICITLY
              (setq-local gptel-include-tool-results t)  ; Enable tool result persistence

              ;; Add auto-save via gptel's post-response hook
              (add-hook 'gptel-post-response-functions
                        #'jf/gptel--auto-save-session-buffer
                        nil t)  ; buffer-local hook

              ;; Insert prompt into buffer
              ;; This allows gptel-request with PROMPT=nil to read from buffer
              (insert prompt)
              (insert "\n\n")  ; Separator for response

              ;; Associate buffer with file but don't write yet
              ;; Let auto-save handle first write (ensures Local Variables at end)
              (set-visited-file-name (jf/gptel--context-file-path session-dir))
              (set-buffer-modified-p t))

            ;; Register session globally (metadata no longer needed in registry)
            (jf/gptel--register-session session-dir agent-buffer session-id)

          ;; Create overlay for parent feedback
          (let ((ov (jf/gptel-persistent-agent--create-overlay
                     where agent_type description)))

            ;; Execute with preset scope for configuration only
            (gptel-with-preset
                (nconc (list :include-reasoning nil
                             :use-tools t
                             :use-context nil
                             :include-tool-results t)
                       (cdr (assoc agent_type gptel-agent--agents)))

              ;; Accumulator for response (must be inside preset scope)
              (let ((partial ""))

                ;; Launch the agent request
                ;; PROMPT=nil reads from agent-buffer (which now contains prompt)
                (gptel-request nil
                  :buffer agent-buffer
                  :position (point-max)  ; Insert response at end of buffer
                  :context ov  ; Parent buffer overlay
                  :fsm (gptel-make-fsm :handlers jf/gptel-persistent-agent--fsm-handlers)

                  :callback
                  (lambda (resp info &optional raw)
                    (let ((ov (plist-get info :context))
                          (buf (plist-get info :buffer)))
                      (pcase resp
                        ;; Network/API error
                        ('nil
                         (delete-overlay ov)
                         (funcall main-cb
                                  (format "Error: Network failure\n%S"
                                          (plist-get info :error))))

                        ;; User aborted tool confirmation
                        ('abort
                         (delete-overlay ov)
                         (funcall main-cb "Error: User aborted agent"))

                        ;; Tool calls pending - wait for completion
                        (`(tool-call . ,calls)
                         (gptel--display-tool-calls calls info))

                        ;; Tool results ready - display in agent buffer
                        (`(tool-result . ,tool-results)
                         (gptel--display-tool-results tool-results info))

                        ;; String response - DUAL DUTY: insert to buffer AND accumulate
                        ((pred stringp)
                         ;; 1. Insert into agent-buffer for persistence
                         (with-current-buffer buf
                           (save-excursion
                             (goto-char (point-max))
                             (if raw
                                 ;; Raw (tool results): properties already set
                                 (insert resp)
                               ;; Regular response: add properties
                               (let ((start (point)))
                                 (insert resp)
                                 (when gptel-mode
                                   (put-text-property start (point)
                                                     'gptel 'response))))))

                         ;; 2-3. Accumulate and callback only for non-raw responses
                         (unless raw
                           ;; 2. Accumulate for parent callback
                           (setq partial (concat partial resp))

                           ;; 3. Return to parent when done (not in tool-use)
                           (unless (plist-get info :tool-use)
                             (delete-overlay ov)
                             ;; Apply transformer if present
                             (when-let ((transform (plist-get info :transformer)))
                               (setq partial (funcall transform partial)))
                             (funcall main-cb partial)))))))))))))))))
#+end_src

* Tool Registration

Register the PersistentAgent tool with gptel.

#+begin_src emacs-lisp
(gptel-make-tool
 :name "PersistentAgent"
 :description "Launch specialized agent in persistent session buffer.

Agents run autonomously and return results in one message.
Sessions persist to disk with full conversation history.

Use for complex research, open-ended exploration, or iterative tasks."

 :function #'jf/gptel-persistent-agent--task

 :args '(( :name "agent_type"
           :type string
           :enum ["researcher" "executor" "explorer" "planner"]
           :description "Type of specialized agent")

         ( :name "description"
           :type string
           :description "Short (3-5 word) task description")

         ( :name "prompt"
           :type string
           :description "Detailed task instructions"))

 :category "gptel-persistent"
 :async t      ; Runs asynchronously
 :confirm t    ; User confirmation required
 :include t)   ; Results appear in parent buffer
#+end_src

* Footer

#+begin_src emacs-lisp
(provide 'gptel-persistent-agent)
;;; persistent-agent.el ends here
#+end_src
