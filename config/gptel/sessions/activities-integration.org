#+title: GPTEL Sessions Activities Integration
#+property: header-args:emacs-lisp :tangle activities-integration.el
#+auto_tangle: y

* Overview

This module integrates persistent gptel sessions with the activities-extensions package,
providing the *primary workflow* for creating and managing persistent gptel sessions.

** Why Activities Integration?

Activities integration provides the best experience for persistent gptel sessions:
- *Automatic organization*: Sessions stored alongside activity resources (worktrees, docs)
- *Lifecycle management*: Sessions open automatically on resume, saved on suspend
- *Context preservation*: Activity metadata links sessions to projects and documentation
- *Directory isolation*: Each activity gets its own =session/= directory
- *Zero friction*: Create session and activity in one transient UI flow

** Features
- Activity-aware persistent sessions
- Immediate resource creation (directories, files, scope plans)
- File-backed buffers from creation
- Default scope profiles from registered presets
- Resume/suspend integration with automatic buffer management
- Optional registered preset selection via transient UI
- Integration with org-roam documentation and projectile worktrees

** User Workflow

*** Creating an Activity with gptel Session

1. Run =M-x activities-ext-create= (or =C-x C-a C-e=)
2. Enter an activity name (e.g., "implement-auth-system")
3. In the transient menu:
   - *Select projects* (optional): Toggle projects with letter keys (a-z)
   - *Choose gptel preset*: Select registered preset with number keys (1-9)
   - *Toggle options*: Use =-G= to skip gptel session (on by default)
   - Press *RET* to create

Result:
- Activity created at =~/emacs-activities/<activity-slug-date>/=
- gptel session in =session/branches/main/session.md=
- Session buffer opened in split window (right side)
- Org-roam doc opened in left window (if not skipped)

*** Resuming Activities

When you resume an activity (=M-x activities-resume=):
- gptel session buffer opens automatically if one exists
- Conversation history fully restored from =session.md=
- Backend, model, and tool configuration preserved
- Scope configuration remains active for file access controls

*** Session Directory Structure

#+begin_example
~/emacs-activities/
└── implement-auth-20260130/
    ├── session/
    │   ├── branches/
    │   │   └── main/
    │   │       ├── session.md        # Your conversation
    │   │       ├── metadata.yml      # Session metadata (preset, timestamps)
    │   │       └── scope.yml         # File access permissions
    │   ├── current -> branches/main  # Symlink to active branch
    │   └── gptel-logs.txt            # Debug logs
    └── worktrees/
        └── my-project/               # Git worktrees (if using projectile)
#+end_example

*** Customization

*Disable gptel session creation by default*:
#+begin_src emacs-lisp :tangle no
;; In init.org or config/local/machine.el
(setq activities-ext-create-gptel-by-default nil)
#+end_src

*Default preset* (symbol from =gptel--known-presets=):
#+begin_src emacs-lisp :tangle no
(setq activities-ext-default-gptel-preset 'executor)
#+end_src

** Dependencies
- activities-extensions (optional - checked at runtime)
- gptel session modules (registry, metadata, filesystem)
- gptel-scope-profiles (scope profile creation)

* Dependencies and Requirements

#+begin_src emacs-lisp
;;; activities-integration.el --- GPTEL Sessions Activities Integration -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;; This file integrates persistent gptel sessions with activities-extensions.

;;; Code:

(require 'gptel nil t)
(require 'gptel-session-constants)
(require 'gptel-session-logging)
(require 'gptel-session-filesystem)
(require 'gptel-session-registry)
(require 'gptel-session-metadata)

;; Optional dependency - checked at runtime
(defvar activities-ext--slugify)
#+end_src

* Configuration Variables

#+begin_src emacs-lisp
(defgroup jf-gptel-activities nil
  "Integration between gptel sessions and activities."
  :group 'gptel
  :prefix "jf/gptel-activities-")

(defcustom jf/gptel-activities-auto-open-on-resume t
  "Automatically open gptel session buffer when resuming activity."
  :type 'boolean
  :group 'jf-gptel-activities)

(defcustom jf/gptel-activities-create-scope-plan t
  "Create default deny-all scope plan for activity sessions."
  :type 'boolean
  :group 'jf-gptel-activities)
#+end_src

* Eager Session Creation

Create persistent session immediately with all resources.

#+begin_src emacs-lisp
(defun jf/gptel-session-create-persistent (activity-name &optional backend model preset-name org-file)
  "Create persistent gptel session immediately for ACTIVITY-NAME.

Unlike lazy initialization, this creates all resources upfront:
- Session directory (~/gptel-sessions/ACTIVITY-NAME-TIMESTAMP/)
- scope.yml with file access permissions (from preset scope profile)
- metadata.yml with session metadata and preset reference
- session.md file for buffer to visit
- Registers in global registry

BACKEND and MODEL default to current gptel-backend and gptel-model.
PRESET-NAME is a symbol naming a registered preset in `gptel--known-presets'
  (default: `executor').
ORG-FILE is optional path to activity org file (for worktree parsing).

Returns plist: (:session-id ... :session-dir ... :buffer-name ... :session-file ...)"
  (unless (and (fboundp 'jf/gptel--read-session-metadata)
               (fboundp 'jf/gptel--register-session))
    (error "GPTEL session registry not available"))

  (let* ((slug (if (fboundp 'activities-ext--slugify)
                   (activities-ext--slugify activity-name)
                 (replace-regexp-in-string "[^a-z0-9-]" "-"
                                          (downcase activity-name))))
         (timestamp (format-time-string "%Y%m%d%H%M%S"))
         ;; Session ID is activity slug + timestamp
         (session-id (format "%s-%s" slug timestamp))
         ;; Use the provided directory directly (caller has already set it up)
         (session-dir (expand-file-name jf/gptel-sessions-directory))
         (backend (or backend gptel-backend))
         (model (or model gptel-model))
         (backend-name (gptel-backend-name backend))
         (preset-name (or preset-name 'executor))
         ;; Parse worktree paths from org-roam documentation
         ;; Ensure file is saved before parsing
         (raw-paths (jf/gptel-activities--parse-worktree-paths activity-name org-file))
         ;; Convert raw worktree paths to scope plist format
         (worktree-scope
          (when raw-paths
            (list :paths (list :read raw-paths
                               :write raw-paths
                               :deny '("**/.git/**" "**/runtime/**" "**/.env" "**/node_modules/**"))))))

    ;; Create session directory structure using core helper
    ;; This creates branches/main/, scope.yml, metadata.yml, session.md, and current symlink
    (let* ((session-info (jf/gptel--create-session-core
                          session-id
                          session-dir
                          preset-name
                          "###\n"          ; Minimal initial content
                          worktree-scope   ; Scope plist (or nil)
                          nil))            ; No project-root
           (branch-dir (plist-get session-info :branch-dir))
           (session-file (plist-get session-info :session-file)))

      ;; Store worktree paths in session file as file-local variable
      (when raw-paths
        (with-temp-buffer
          (insert-file-contents session-file)
          (goto-char (point-max))
          ;; Add file-local variable block if not already present
          (unless (search-backward "<!-- gptel-activity-worktrees:" nil t)
            (insert (format "\n<!-- gptel-activity-worktrees: %S -->\n"
                           raw-paths))
            (write-region (point-min) (point-max) session-file nil 'silent))
          (jf/gptel--log 'info "Stored %d worktree path(s) in session metadata"
                        (length raw-paths))))

      ;; Register in global registry
      (jf/gptel--log 'info "Registering session: %s" session-id)
      (jf/gptel--register-session session-dir (current-buffer) session-id "main" branch-dir)

      ;; Return session info for buffer creation
      (list :session-id session-id
            :session-dir session-dir   ; Session directory (parent of branches/)
            :branch-dir branch-dir     ; Branch directory (branches/main/)
            :branch-name "main"        ; Activities integration uses main branch
            :buffer-name (format "*gptel-%s*" slug)
            :session-file session-file
            :backend backend-name
            :model (if (symbolp model) (symbol-name model) model)))))
#+end_src

* Worktree Path Discovery

** Overview

When creating an activity with gptel session, worktree paths must be discovered and passed downstream to configure the session's scope plan. The org-roam document is the **source of truth** for activity configuration.

** Data Flow

1. Activity creation writes org-roam document with =PROJECT_WORKTREE= properties
2. Org file path passed to =jf/gptel-session-create-persistent= as =org-file= parameter
3. Parser function =jf/gptel-activities--parse-worktree-paths= called with org file path
4. Worktree paths extracted from org properties using =org-map-entries=
5. Paths returned as list and passed to =jf/gptel--create-session-core=
6. Scope plan generated with worktree paths in allowed patterns

** Org Document Structure

Worktree information stored in project headline property drawers:

#+begin_example
* Projects
** Project: my-repository
:PROPERTIES:
:PROJECT_PATH: ~/code/my-repository/
:PROJECT_NAME: my-repository
:PROJECT_BRANCH: feature-branch
:PROJECT_WORKTREE: /Users/user/emacs-activities/activity-name/worktrees/my-repository
:END:
#+end_example

The =:PROJECT_WORKTREE:= property contains the absolute path to the git worktree created for this activity.

** Parsing Strategy

The parser uses an efficient buffer-reuse strategy:

1. *Check for existing buffer*: Uses =get-file-buffer= to see if org file already open
2. *Reuse if available*: If activity creation just opened the org document, use that buffer
3. *Open temporarily if needed*: Falls back to =find-file-noselect= with NOWARN flag
4. *Parse with org-map-entries*: Iterate headlines and extract =PROJECT_WORKTREE= properties
5. *Clean up conditionally*: Only kill buffer if we opened it (preserves user's open buffers)

** Why =find-file-noselect= instead of =with-temp-buffer=?

The =org-map-entries= function requires =buffer-file-name= to be set to work correctly. Using =find-file-noselect=:
- Automatically sets =buffer-file-name= to the file path
- Properly initializes org-mode with file-visiting semantics
- Enables org-mode's element cache and parsing
- Avoids buffer modification prompts (file loaded, not modified)

Using =with-temp-buffer= + =insert-file-contents= would require manual =buffer-file-name= setup and =set-buffer-modified-p= workarounds.

** Implementation

#+begin_src emacs-lisp
(defun jf/gptel-activities--parse-worktree-paths (activity-name &optional org-file)
  "Parse worktree paths from org document for ACTIVITY-NAME.

If ORG-FILE is provided, uses that path directly (preferred approach).
Otherwise searches for saved org file with title \"Activity: ACTIVITY-NAME\" in org-roam-directory.

Convention: The org file MUST exist on disk before calling this function.

Returns list of absolute, expanded worktree paths.
Returns nil if org document not found or no worktrees defined.

This uses the org documentation as source of truth for activity configuration,
following documentation-first architecture. Uses only standard org-mode functions."
  (condition-case err
      (let* ((activity-file
              (if org-file
                  ;; Explicit file path provided - use it directly
                  (progn
                    (jf/gptel--log 'debug "Using provided org file: %s" org-file)
                    (expand-file-name org-file))
                ;; No file provided - search for it on disk
                (let* ((org-dir (if (boundp 'org-roam-directory)
                                   org-roam-directory
                                 "~/org/roam"))
                       (org-dir-expanded (expand-file-name org-dir))
                       (expected-title (format "Activity: %s" activity-name))
                       (org-files (directory-files org-dir-expanded t "\\.org$"))
                       (found-file nil))
                  (jf/gptel--log 'debug "Searching for activity '%s' in %s (%d .org files)"
                                activity-name org-dir-expanded (length org-files))
                  (dolist (file org-files)
                    (when (and (file-regular-p file) (not found-file))
                      (with-temp-buffer
                        (insert-file-contents file nil 0 500)
                        (goto-char (point-min))
                        (when (re-search-forward (concat "^#\\+title: " (regexp-quote expected-title)) nil t)
                          (jf/gptel--log 'debug "Found activity file: %s" file)
                          (setq found-file file)))))
                  found-file))))

        (if (not (and activity-file (file-exists-p activity-file)))
            (progn
              (jf/gptel--log 'warn "No org document found for activity: %s (file must exist on disk)" activity-name)
              nil)
          ;; Parse the org file for PROJECT_WORKTREE properties
          (jf/gptel--log 'debug "Parsing PROJECT_WORKTREE properties from: %s" activity-file)
          ;; Use existing buffer if file is already open, otherwise open temporarily
          (let* ((existing-buf (get-file-buffer activity-file))
                 (buf (or existing-buf (find-file-noselect activity-file t))))
            (unwind-protect
                (with-current-buffer buf
                  (let ((worktree-paths '())
                        (entry-count 0))
                    (org-map-entries
                     (lambda ()
                       (cl-incf entry-count)
                       (when-let ((worktree (org-entry-get nil "PROJECT_WORKTREE")))
                         (let ((expanded (expand-file-name worktree)))
                           (jf/gptel--log 'debug "Found PROJECT_WORKTREE: %s" expanded)
                           ;; Always append /** suffix for full glob pattern
                           (push (concat expanded "/**") worktree-paths))))
                     nil 'file)
                    (jf/gptel--log 'debug "Scanned %d org entries, found %d worktree(s)"
                                  entry-count (length worktree-paths))
                    (when worktree-paths
                      (jf/gptel--log 'info "Found %d worktree path(s) for activity %s"
                                    (length worktree-paths) activity-name))
                    (nreverse worktree-paths)))
              ;; Only kill buffer if we opened it ourselves
              (unless existing-buf
                (kill-buffer buf))))))
    (error
     (jf/gptel--log 'error "Error parsing worktree paths for %s: %s"
                   activity-name (error-message-string err))
     nil)))
#+end_src

* Buffer Creation and Association

Create gptel buffer that visits the session file.

#+begin_src emacs-lisp
(defun jf/gptel-session--create-buffer (session-info)
  "Create gptel buffer associated with session file.
SESSION-INFO is plist from jf/gptel-session-create-persistent.

The find-file-hook (`jf/gptel--auto-init-session-buffer') handles
preset application and gptel-mode initialization automatically
when the session file is opened."
  (let* ((buffer-name (plist-get session-info :buffer-name))
         (session-file (plist-get session-info :session-file)))
    ;; Open session file — find-file-hook handles auto-initialization
    (let ((buffer (find-file-noselect session-file)))
      (with-current-buffer buffer
        ;; Rename buffer to expected name
        (rename-buffer buffer-name t)
        (jf/gptel--log 'info "Created buffer: %s (session: %s)"
                      buffer-name (plist-get session-info :session-id))
        buffer))))
#+end_src

* Resume Existing Session

Open existing session from file and restore state.

#+begin_src emacs-lisp
(defun jf/gptel-session--open-existing (session-file)
  "Open existing gptel session from SESSION-FILE.
The find-file-hook handles auto-initialization and state restoration.
Returns the buffer visiting the session file."
  (unless (file-exists-p session-file)
    (error "Session file does not exist: %s" session-file))
  (let ((buffer (find-file-noselect session-file)))
    (jf/gptel--log 'info "Opened session: %s" session-file)
    buffer))
#+end_src

* Feature Provision

#+begin_src emacs-lisp
(provide 'jf-gptel-activities-integration)
;;; activities-integration.el ends here
#+end_src
