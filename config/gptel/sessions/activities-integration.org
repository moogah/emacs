#+title: GPTEL Sessions Activities Integration
#+property: header-args:emacs-lisp :tangle activities-integration.el
#+auto_tangle: y

* Overview

This module integrates persistent gptel sessions with the activities-extensions package.

** Features
- Activity-aware persistent sessions
- Immediate resource creation (directories, files, scope plans)
- File-backed buffers from creation
- Default deny-all scope plans
- Resume/suspend integration

** Dependencies
- activities-extensions (optional - checked at runtime)
- jf-gptel-scope-core (scope plan creation)
- gptel session modules (registry, metadata)

* Dependencies and Requirements

#+begin_src emacs-lisp
;;; activities-integration.el --- GPTEL Sessions Activities Integration -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;; This file integrates persistent gptel sessions with activities-extensions.

;;; Code:

(require 'gptel nil t)
(require 'gptel-session-constants)
(require 'gptel-session-logging)
(require 'gptel-session-filesystem)
(require 'gptel-session-registry)
(require 'gptel-session-metadata)
(require 'jf-gptel-scope-core nil t)
(require 'jf-gptel-scope-commands nil t)  ; For jf/gptel-scope--template-deny-all

;; Optional dependency - checked at runtime
(defvar activities-ext--slugify)
#+end_src

* Configuration Variables

#+begin_src emacs-lisp
(defgroup jf-gptel-activities nil
  "Integration between gptel sessions and activities."
  :group 'gptel
  :prefix "jf/gptel-activities-")

(defcustom jf/gptel-activities-auto-open-on-resume t
  "Automatically open gptel session buffer when resuming activity."
  :type 'boolean
  :group 'jf-gptel-activities)

(defcustom jf/gptel-activities-create-scope-plan t
  "Create default deny-all scope plan for activity sessions."
  :type 'boolean
  :group 'jf-gptel-activities)
#+end_src

* Eager Session Creation

Create persistent session immediately with all resources.

#+begin_src emacs-lisp
(defun jf/gptel-session-create-persistent (activity-name &optional backend model preset-template)
  "Create persistent gptel session immediately for ACTIVITY-NAME.

Unlike lazy initialization, this creates all resources upfront:
- Session directory (~/gptel-sessions/ACTIVITY-NAME-TIMESTAMP/)
- scope-plan.yml with session metadata and deny-all permissions
- preset.md with backend and model configuration (from template)
- session.org file for buffer to visit
- Registers in global registry

BACKEND and MODEL default to current gptel-backend and gptel-model.
PRESET-TEMPLATE specifies template name (default: \"programming-assistant\").

Returns plist: (:session-id ... :session-dir ... :buffer-name ... :session-file ...)"
  (unless (and (fboundp 'jf/gptel--read-session-metadata)
               (fboundp 'jf/gptel--register-session))
    (error "GPTEL session registry not available"))

  (let* ((slug (if (fboundp 'activities-ext--slugify)
                   (activities-ext--slugify activity-name)
                 (replace-regexp-in-string "[^a-z0-9-]" "-"
                                          (downcase activity-name))))
         (timestamp (format-time-string "%Y%m%d%H%M%S"))
         ;; Session ID is activity slug + timestamp
         (session-id (format "%s-%s" slug timestamp))
         ;; Use the provided directory directly (caller has already set it up)
         (session-dir (expand-file-name jf/gptel-sessions-directory))
         (backend (or backend gptel-backend))
         (model (or model gptel-model))
         (backend-name (gptel-backend-name backend))
         (preset-template (or preset-template "programming-assistant")))

    ;; Create session directory structure using core helper
    ;; This creates branches/main/, preset.md, scope-plan.yml, session.md, and current symlink
    (let* ((session-info (jf/gptel--create-session-core
                          session-id
                          session-dir
                          preset-template
                          'deny-all    ; Activities integration uses deny-all scope by default
                          nil          ; No projects
                          "###\n"))    ; Minimal initial content
           (branch-dir (plist-get session-info :branch-dir))
           (session-file (plist-get session-info :session-file)))

      ;; Register in global registry
      (jf/gptel--log 'info "Registering session: %s" session-id)
      (jf/gptel--register-session session-dir (current-buffer) session-id "main" branch-dir)

      ;; Return session info for buffer creation
      (list :session-id session-id
            :session-dir branch-dir    ; Use branch directory for consistency
            :branch-name "main"        ; Activities integration uses main branch
            :buffer-name (format "*gptel-%s*" slug)
            :session-file session-file
            :backend backend-name
            :model (if (symbolp model) (symbol-name model) model)))))
#+end_src

* Buffer Creation and Association

Create gptel buffer that visits the session file.

#+begin_src emacs-lisp
(defun jf/gptel-session--create-buffer (session-info)
  "Create gptel buffer associated with session file.
SESSION-INFO is plist from jf/gptel-session-create-persistent."
  (let* ((buffer-name (plist-get session-info :buffer-name))
         (session-file (plist-get session-info :session-file))
         (session-id (plist-get session-info :session-id))
         (backend-name (plist-get session-info :backend))
         (model-name (plist-get session-info :model))
         (model (if (stringp model-name) (intern model-name) model-name)))

    ;; Open session.org file in buffer
    (let ((buffer (find-file-noselect session-file)))
      (with-current-buffer buffer
        ;; Rename buffer to expected name
        (rename-buffer buffer-name t)

        ;; Enable gptel-mode if not already active
        (unless gptel-mode
          (gptel-mode 1))

        ;; Set buffer-local session variables
        (setq-local jf/gptel--session-id session-id)
        (setq-local jf/gptel--session-dir (plist-get session-info :session-dir))
        (setq-local jf/gptel--branch-name (or (plist-get session-info :branch-name) "main"))

        ;; Load and apply preset from file (includes backend, model, system, tools, etc.)
        (when (fboundp 'jf/gptel--load-preset-from-file)
          (condition-case err
              (let ((preset-plist (jf/gptel--load-preset-from-file
                                  (plist-get session-info :session-dir))))
                (when (and preset-plist (fboundp 'jf/gptel--apply-session-preset))
                  (jf/gptel--apply-session-preset preset-plist)
                  (jf/gptel--log 'info "Applied preset to buffer: %s" buffer-name)))
            (error
             (jf/gptel--log 'warn "Failed to load preset, falling back to basic config: %s"
                           (error-message-string err))
             ;; Fallback: Set basic backend and model
             (setq-local gptel-backend (alist-get backend-name gptel--known-backends
                                                  nil nil #'equal))
             (setq-local gptel-model model))))

        ;; Force autosave enabled for this buffer
        (setq-local jf/gptel-autosave-enabled t)

        (jf/gptel--log 'info "Created buffer: %s (session: %s)" buffer-name session-id)
        buffer))))
#+end_src

* Resume Existing Session

Open existing session from file and restore state.

#+begin_src emacs-lisp
(defun jf/gptel-session--open-existing (session-file)
  "Open existing gptel session from SESSION-FILE.
Restores session-id and other state from file properties.
Returns the buffer visiting the session file."
  (unless (file-exists-p session-file)
    (error "Session file does not exist: %s" session-file))

  (let ((buffer (find-file-noselect session-file)))
    (with-current-buffer buffer
      ;; Parse org properties to get session-id
      (org-with-point-at (point-min)
        (let ((session-id (org-entry-get nil "session_id")))
          (if (not session-id)
              (progn
                (jf/gptel--log 'warn "No session_id found in %s" session-file)
                buffer)

            ;; Find session in registry or disk
            (if-let ((session (and (fboundp 'jf/gptel-session-find)
                                  (jf/gptel-session-find session-id "main"))))
                (progn
                  ;; Set buffer-local variables
                  (setq-local jf/gptel--session-id session-id)
                  (setq-local jf/gptel--session-dir (plist-get session :session-dir))
                  (setq-local jf/gptel--branch-name (plist-get session :branch-name))

                  ;; Enable gptel-mode if not already
                  (unless gptel-mode
                    (gptel-mode 1))

                  ;; Force autosave
                  (setq-local jf/gptel-autosave-enabled t)

                  ;; Restore backend/model from preset metadata on disk
                  (let ((preset-meta (jf/gptel--read-preset-metadata (plist-get session :session-dir))))
                    (when-let ((backend-name (plist-get preset-meta :backend)))
                      (setq-local gptel-backend (alist-get backend-name gptel--known-backends
                                                           nil nil #'equal)))
                    (when-let ((model-name (plist-get preset-meta :model)))
                      (setq-local gptel-model (if (stringp model-name)
                                                 (intern model-name)
                                               model-name))))

                  (jf/gptel--log 'info "Opened existing session: %s" session-id)
                  buffer)

              ;; Session not found in registry
              (jf/gptel--log 'warn "Session %s not found in registry" session-id)
              buffer)))))))
#+end_src

* Feature Provision

#+begin_src emacs-lisp
(provide 'jf-gptel-activities-integration)
;;; activities-integration.el ends here
#+end_src
