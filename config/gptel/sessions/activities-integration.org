#+title: GPTEL Sessions Activities Integration
#+property: header-args:emacs-lisp :tangle activities-integration.el
#+auto_tangle: y

* Overview

This module integrates persistent gptel sessions with the activities-extensions package,
providing the *primary workflow* for creating and managing persistent gptel sessions.

** Why Activities Integration?

Activities integration provides the best experience for persistent gptel sessions:
- *Automatic organization*: Sessions stored alongside activity resources (worktrees, docs)
- *Lifecycle management*: Sessions open automatically on resume, saved on suspend
- *Context preservation*: Activity metadata links sessions to projects and documentation
- *Directory isolation*: Each activity gets its own =session/= directory
- *Zero friction*: Create session and activity in one transient UI flow

** Features
- Activity-aware persistent sessions
- Immediate resource creation (directories, files, scope plans)
- File-backed buffers from creation
- Default deny-all scope plans for security
- Resume/suspend integration with automatic buffer management
- Optional preset template selection via transient UI
- Integration with org-roam documentation and projectile worktrees

** User Workflow

*** Creating an Activity with gptel Session

1. Run =M-x activities-ext-create= (or =C-x C-a C-e=)
2. Enter an activity name (e.g., "implement-auth-system")
3. In the transient menu:
   - *Select projects* (optional): Toggle projects with letter keys (a-z)
   - *Choose gptel preset*: Select template with number keys (1-9)
   - *Toggle options*: Use =-G= to skip gptel session (on by default)
   - Press *RET* to create

Result:
- Activity created at =~/emacs-activities/<activity-slug-date>/=
- gptel session in =session/branches/main/session.md=
- Session buffer opened in split window (right side)
- Org-roam doc opened in left window (if not skipped)

*** Resuming Activities

When you resume an activity (=M-x activities-resume=):
- gptel session buffer opens automatically if one exists
- Conversation history fully restored from =session.md=
- Backend, model, and tool configuration preserved
- Scope plan remains active for file access controls

*** Session Directory Structure

#+begin_example
~/emacs-activities/
└── implement-auth-20260130/
    ├── session/
    │   ├── branches/
    │   │   └── main/
    │   │       ├── session.md        # Your conversation
    │   │       ├── preset.md         # Model/backend config
    │   │       └── scope-plan.yml    # File access permissions
    │   ├── current -> branches/main  # Symlink to active branch
    │   └── gptel-logs.txt            # Debug logs
    └── worktrees/
        └── my-project/               # Git worktrees (if using projectile)
#+end_example

*** Customization

*Disable gptel session creation by default*:
#+begin_src emacs-lisp
;; In init.org or config/local/machine.el
(setq activities-ext-create-gptel-by-default nil)
#+end_src

*Default preset template*:
#+begin_src emacs-lisp
(setq activities-ext-default-gptel-preset "programming-assistant")
#+end_src

** Dependencies
- activities-extensions (optional - checked at runtime)
- jf-gptel-scope-core (scope plan creation)
- gptel session modules (registry, metadata)

* Dependencies and Requirements

#+begin_src emacs-lisp
;;; activities-integration.el --- GPTEL Sessions Activities Integration -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;; This file integrates persistent gptel sessions with activities-extensions.

;;; Code:

(require 'gptel nil t)
(require 'gptel-session-constants)
(require 'gptel-session-logging)
(require 'gptel-session-filesystem)
(require 'gptel-session-registry)
(require 'gptel-session-metadata)
(require 'jf-gptel-scope-core nil t)
(require 'jf-gptel-scope-commands nil t)  ; For jf/gptel-scope--template-deny-all

;; Optional dependency - checked at runtime
(defvar activities-ext--slugify)
#+end_src

* Configuration Variables

#+begin_src emacs-lisp
(defgroup jf-gptel-activities nil
  "Integration between gptel sessions and activities."
  :group 'gptel
  :prefix "jf/gptel-activities-")

(defcustom jf/gptel-activities-auto-open-on-resume t
  "Automatically open gptel session buffer when resuming activity."
  :type 'boolean
  :group 'jf-gptel-activities)

(defcustom jf/gptel-activities-create-scope-plan t
  "Create default deny-all scope plan for activity sessions."
  :type 'boolean
  :group 'jf-gptel-activities)
#+end_src

* Eager Session Creation

Create persistent session immediately with all resources.

#+begin_src emacs-lisp
(defun jf/gptel-session-create-persistent (activity-name &optional backend model preset-template org-file)
  "Create persistent gptel session immediately for ACTIVITY-NAME.

Unlike lazy initialization, this creates all resources upfront:
- Session directory (~/gptel-sessions/ACTIVITY-NAME-TIMESTAMP/)
- scope-plan.yml with session metadata and deny-all permissions
- preset.md with backend and model configuration (from template)
- session.org file for buffer to visit
- Registers in global registry

BACKEND and MODEL default to current gptel-backend and gptel-model.
PRESET-TEMPLATE specifies template name (default: \"programming-assistant\").
ORG-FILE is optional path to activity org file (for worktree parsing).

Returns plist: (:session-id ... :session-dir ... :buffer-name ... :session-file ...)"
  (unless (and (fboundp 'jf/gptel--read-session-metadata)
               (fboundp 'jf/gptel--register-session))
    (error "GPTEL session registry not available"))

  (let* ((slug (if (fboundp 'activities-ext--slugify)
                   (activities-ext--slugify activity-name)
                 (replace-regexp-in-string "[^a-z0-9-]" "-"
                                          (downcase activity-name))))
         (timestamp (format-time-string "%Y%m%d%H%M%S"))
         ;; Session ID is activity slug + timestamp
         (session-id (format "%s-%s" slug timestamp))
         ;; Use the provided directory directly (caller has already set it up)
         (session-dir (expand-file-name jf/gptel-sessions-directory))
         (backend (or backend gptel-backend))
         (model (or model gptel-model))
         (backend-name (gptel-backend-name backend))
         (preset-template (or preset-template "programming-assistant"))
         ;; Parse worktree paths from org-roam documentation
         ;; Ensure file is saved before parsing
         (worktree-paths (jf/gptel-activities--parse-worktree-paths activity-name org-file)))

    ;; Create session directory structure using core helper
    ;; This creates branches/main/, preset.md, scope-plan.yml, session.md, and current symlink
    (let* ((session-info (jf/gptel--create-session-core
                          session-id
                          session-dir
                          preset-template
                          'deny-all    ; Activities integration uses deny-all scope by default
                          nil          ; No projects
                          "###\n"      ; Minimal initial content
                          worktree-paths)) ; Pass worktree paths for scope generation
           (branch-dir (plist-get session-info :branch-dir))
           (session-file (plist-get session-info :session-file)))

      ;; Store worktree paths in session file as file-local variable
      (when worktree-paths
        (with-temp-buffer
          (insert-file-contents session-file)
          (goto-char (point-max))
          ;; Add file-local variable block if not already present
          (unless (search-backward "<!-- gptel-activity-worktrees:" nil t)
            (insert (format "\n<!-- gptel-activity-worktrees: %S -->\n"
                           worktree-paths))
            (write-region (point-min) (point-max) session-file nil 'silent))
          (jf/gptel--log 'info "Stored %d worktree path(s) in session metadata"
                        (length worktree-paths))))

      ;; Register in global registry
      (jf/gptel--log 'info "Registering session: %s" session-id)
      (jf/gptel--register-session session-dir (current-buffer) session-id "main" branch-dir)

      ;; Return session info for buffer creation
      (list :session-id session-id
            :session-dir session-dir   ; Session directory (parent of branches/)
            :branch-dir branch-dir     ; Branch directory (branches/main/)
            :branch-name "main"        ; Activities integration uses main branch
            :buffer-name (format "*gptel-%s*" slug)
            :session-file session-file
            :backend backend-name
            :model (if (symbolp model) (symbol-name model) model)))))
#+end_src

* Worktree Path Discovery

** Overview

When creating an activity with gptel session, worktree paths must be discovered and passed downstream to configure the session's scope plan. The org-roam document is the **source of truth** for activity configuration.

** Data Flow

1. Activity creation writes org-roam document with =PROJECT_WORKTREE= properties
2. Org file path passed to =jf/gptel-session-create-persistent= as =org-file= parameter
3. Parser function =jf/gptel-activities--parse-worktree-paths= called with org file path
4. Worktree paths extracted from org properties using =org-map-entries=
5. Paths returned as list and passed to =jf/gptel--create-session-core=
6. Scope plan generated with worktree paths in allowed patterns

** Org Document Structure

Worktree information stored in project headline property drawers:

#+begin_example
* Projects
** Project: my-repository
:PROPERTIES:
:PROJECT_PATH: ~/code/my-repository/
:PROJECT_NAME: my-repository
:PROJECT_BRANCH: feature-branch
:PROJECT_WORKTREE: /Users/user/emacs-activities/activity-name/worktrees/my-repository
:END:
#+end_example

The =:PROJECT_WORKTREE:= property contains the absolute path to the git worktree created for this activity.

** Parsing Strategy

The parser uses an efficient buffer-reuse strategy:

1. *Check for existing buffer*: Uses =get-file-buffer= to see if org file already open
2. *Reuse if available*: If activity creation just opened the org document, use that buffer
3. *Open temporarily if needed*: Falls back to =find-file-noselect= with NOWARN flag
4. *Parse with org-map-entries*: Iterate headlines and extract =PROJECT_WORKTREE= properties
5. *Clean up conditionally*: Only kill buffer if we opened it (preserves user's open buffers)

** Why =find-file-noselect= instead of =with-temp-buffer=?

The =org-map-entries= function requires =buffer-file-name= to be set to work correctly. Using =find-file-noselect=:
- Automatically sets =buffer-file-name= to the file path
- Properly initializes org-mode with file-visiting semantics
- Enables org-mode's element cache and parsing
- Avoids buffer modification prompts (file loaded, not modified)

Using =with-temp-buffer= + =insert-file-contents= would require manual =buffer-file-name= setup and =set-buffer-modified-p= workarounds.

** Implementation

#+begin_src emacs-lisp
(defun jf/gptel-activities--parse-worktree-paths (activity-name &optional org-file)
  "Parse worktree paths from org document for ACTIVITY-NAME.

If ORG-FILE is provided, uses that path directly (preferred approach).
Otherwise searches for saved org file with title \"Activity: ACTIVITY-NAME\" in org-roam-directory.

Convention: The org file MUST exist on disk before calling this function.

Returns list of absolute, expanded worktree paths.
Returns nil if org document not found or no worktrees defined.

This uses the org documentation as source of truth for activity configuration,
following documentation-first architecture. Uses only standard org-mode functions."
  (condition-case err
      (let* ((activity-file
              (if org-file
                  ;; Explicit file path provided - use it directly
                  (progn
                    (jf/gptel--log 'debug "Using provided org file: %s" org-file)
                    (expand-file-name org-file))
                ;; No file provided - search for it on disk
                (let* ((org-dir (if (boundp 'org-roam-directory)
                                   org-roam-directory
                                 "~/org/roam"))
                       (org-dir-expanded (expand-file-name org-dir))
                       (expected-title (format "Activity: %s" activity-name))
                       (org-files (directory-files org-dir-expanded t "\\.org$"))
                       (found-file nil))
                  (jf/gptel--log 'debug "Searching for activity '%s' in %s (%d .org files)"
                                activity-name org-dir-expanded (length org-files))
                  (dolist (file org-files)
                    (when (and (file-regular-p file) (not found-file))
                      (with-temp-buffer
                        (insert-file-contents file nil 0 500)
                        (goto-char (point-min))
                        (when (re-search-forward (concat "^#\\+title: " (regexp-quote expected-title)) nil t)
                          (jf/gptel--log 'debug "Found activity file: %s" file)
                          (setq found-file file)))))
                  found-file))))

        (if (not (and activity-file (file-exists-p activity-file)))
            (progn
              (jf/gptel--log 'warn "No org document found for activity: %s (file must exist on disk)" activity-name)
              nil)
          ;; Parse the org file for PROJECT_WORKTREE properties
          (jf/gptel--log 'debug "Parsing PROJECT_WORKTREE properties from: %s" activity-file)
          ;; Use existing buffer if file is already open, otherwise open temporarily
          (let* ((existing-buf (get-file-buffer activity-file))
                 (buf (or existing-buf (find-file-noselect activity-file t))))
            (unwind-protect
                (with-current-buffer buf
                  (let ((worktree-paths '())
                        (entry-count 0))
                    (org-map-entries
                     (lambda ()
                       (cl-incf entry-count)
                       (when-let ((worktree (org-entry-get nil "PROJECT_WORKTREE")))
                         (let ((expanded (expand-file-name worktree)))
                           (jf/gptel--log 'debug "Found PROJECT_WORKTREE: %s" expanded)
                           (push expanded worktree-paths))))
                     nil 'file)
                    (jf/gptel--log 'debug "Scanned %d org entries, found %d worktree(s)"
                                  entry-count (length worktree-paths))
                    (when worktree-paths
                      (jf/gptel--log 'info "Found %d worktree path(s) for activity %s"
                                    (length worktree-paths) activity-name))
                    (nreverse worktree-paths)))
              ;; Only kill buffer if we opened it ourselves
              (unless existing-buf
                (kill-buffer buf))))))
    (error
     (jf/gptel--log 'error "Error parsing worktree paths for %s: %s"
                   activity-name (error-message-string err))
     nil)))
#+end_src

* Buffer Creation and Association

Create gptel buffer that visits the session file.

#+begin_src emacs-lisp
(defun jf/gptel-session--create-buffer (session-info)
  "Create gptel buffer associated with session file.
SESSION-INFO is plist from jf/gptel-session-create-persistent."
  (let* ((buffer-name (plist-get session-info :buffer-name))
         (session-file (plist-get session-info :session-file))
         (session-id (plist-get session-info :session-id))
         (backend-name (plist-get session-info :backend))
         (model-name (plist-get session-info :model))
         (model (if (stringp model-name) (intern model-name) model-name)))

    ;; Open session.org file in buffer
    (let ((buffer (find-file-noselect session-file)))
      (with-current-buffer buffer
        ;; Rename buffer to expected name
        (rename-buffer buffer-name t)

        ;; Enable gptel-mode if not already active
        (unless gptel-mode
          (gptel-mode 1))

        ;; Set buffer-local session variables
        (setq-local jf/gptel--session-id session-id)
        (setq-local jf/gptel--session-dir (plist-get session-info :session-dir))
        (setq-local jf/gptel--branch-name (or (plist-get session-info :branch-name) "main"))

        ;; Load and apply preset from file (includes backend, model, system, tools, etc.)
        (when (fboundp 'jf/gptel--load-preset-from-file)
          (condition-case err
              (let ((preset-plist (jf/gptel--load-preset-from-file
                                  (or (plist-get session-info :branch-dir)
                                      (plist-get session-info :session-dir)))))
                (when (and preset-plist (fboundp 'jf/gptel--apply-session-preset))
                  (jf/gptel--apply-session-preset preset-plist)
                  (jf/gptel--log 'info "Applied preset to buffer: %s" buffer-name)))
            (error
             (jf/gptel--log 'warn "Failed to load preset, falling back to basic config: %s"
                           (error-message-string err))
             ;; Fallback: Set basic backend and model
             (setq-local gptel-backend (alist-get backend-name gptel--known-backends
                                                  nil nil #'equal))
             (setq-local gptel-model model))))

        ;; Force autosave enabled for this buffer
        (setq-local jf/gptel-autosave-enabled t)

        (jf/gptel--log 'info "Created buffer: %s (session: %s)" buffer-name session-id)
        buffer))))
#+end_src

* Resume Existing Session

Open existing session from file and restore state.

#+begin_src emacs-lisp
(defun jf/gptel-session--open-existing (session-file)
  "Open existing gptel session from SESSION-FILE.
Restores session-id and other state from file properties.
Returns the buffer visiting the session file."
  (unless (file-exists-p session-file)
    (error "Session file does not exist: %s" session-file))

  (let ((buffer (find-file-noselect session-file)))
    (with-current-buffer buffer
      ;; Parse org properties to get session-id
      (org-with-point-at (point-min)
        (let ((session-id (org-entry-get nil "session_id")))
          (if (not session-id)
              (progn
                (jf/gptel--log 'warn "No session_id found in %s" session-file)
                buffer)

            ;; Find session in registry or disk
            (if-let ((session (and (fboundp 'jf/gptel-session-find)
                                  (jf/gptel-session-find session-id "main"))))
                (progn
                  ;; Set buffer-local variables
                  (setq-local jf/gptel--session-id session-id)
                  (setq-local jf/gptel--session-dir (plist-get session :session-dir))
                  (setq-local jf/gptel--branch-name (plist-get session :branch-name))

                  ;; Enable gptel-mode if not already
                  (unless gptel-mode
                    (gptel-mode 1))

                  ;; Force autosave
                  (setq-local jf/gptel-autosave-enabled t)

                  ;; Restore backend/model from preset metadata on disk
                  (let ((preset-meta (jf/gptel--read-preset-metadata (plist-get session :session-dir))))
                    (when-let ((backend-name (plist-get preset-meta :backend)))
                      (setq-local gptel-backend (alist-get backend-name gptel--known-backends
                                                           nil nil #'equal)))
                    (when-let ((model-name (plist-get preset-meta :model)))
                      (setq-local gptel-model (if (stringp model-name)
                                                 (intern model-name)
                                               model-name))))

                  (jf/gptel--log 'info "Opened existing session: %s" session-id)
                  buffer)

              ;; Session not found in registry
              (jf/gptel--log 'warn "Session %s not found in registry" session-id)
              buffer)))))))
#+end_src

* Feature Provision

#+begin_src emacs-lisp
(provide 'jf-gptel-activities-integration)
;;; activities-integration.el ends here
#+end_src
