#+title: GPTEL Session Commands
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle commands.el
#+auto_tangle: y

* Introduction

User-facing commands for creating and managing gptel persistent sessions.

** Primary Workflow: Activities Integration

The *recommended workflow* for creating persistent gptel sessions is through the
=activities-extensions= package. When you create a new activity using the transient
UI (=M-x activities-ext-create=), you can optionally create a persistent gptel session
that is automatically integrated with the activity.

*** Creating an Activity with gptel Session

1. Run =M-x activities-ext-create= (or =C-x C-a C-e=)
2. Enter an activity name when prompted
3. In the transient menu:
   - Select projectile projects (optional)
   - Choose a gptel preset template (defaults to =programming-assistant=)
   - Ensure "Skip gptel session" (=-G=) is *not* toggled (gptel session created by default)
   - Press =RET= to create the activity

The gptel session will be:
- Created at =~/emacs-activities/<activity-slug-date>/session/=
- Configured with branch-based structure (=branches/main/= by default)
- Protected with deny-all scope plan for security
- Automatically opened in a split window alongside your org-roam document
- Stored in activity metadata for automatic resume

*** Resuming Activities with gptel Sessions

When you resume an activity (=M-x activities-resume=), the gptel session buffer is
automatically opened if one exists. The session state is restored from disk with
all conversation history preserved.

*** Session Directory Structure (Activities)

#+begin_example
~/emacs-activities/
└── my-feature-20260130/
    ├── session/
    │   ├── branches/
    │   │   └── main/
    │   │       ├── session.md        # Conversation history
    │   │       ├── preset.md         # Model/backend configuration
    │   │       └── scope-plan.yml    # File access permissions
    │   ├── current -> branches/main
    │   └── gptel-logs.txt
    └── worktrees/
        └── project-name/             # Git worktrees (if using projectile)
#+end_example

** Alternative: Standalone Sessions

For sessions *outside* of activities, use =M-x jf/gptel-persistent-session=.
This is useful when you:
- Want a quick session without activity overhead
- Need a session not tied to a specific activity context
- Are working on ad-hoc tasks or experiments

Standalone sessions are stored in =~/.gptel/sessions/= by default.

See [[*Create Persistent Session][Create Persistent Session]] section below for details.

* Lexical Binding

#+begin_src emacs-lisp
;;; commands.el --- GPTEL Session Commands -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;;; Commentary:

;; Interactive commands for gptel session management.
;;
;; BREAKING CHANGE: Manual resume commands removed as of 2026-01-25
;; Sessions now auto-initialize when opened via find-file-hook
;; Users should open session files directly (C-x C-f, dired, recentf, etc.)
;; The jf/gptel-resume-session, jf/gptel-list-sessions, and jf/gptel-resume-agent
;; commands have been removed. Use standard Emacs file navigation instead.
;;
;; ARCHITECTURE NOTE: Preset files are templates used at session creation.
;; Once created, gptel's Local Variables are the source of truth for settings.
;; Presets are NOT reapplied on resume - they may become stale as sessions evolve.
;;
;; SYSTEM MESSAGE HANDLING: System messages are managed via preset files, not
;; Local Variables. This prevents duplicate Local Variables blocks when system
;; messages exceed ~4000 characters. Buffer-local advice on gptel--save-state
;; prevents gptel from persisting system messages to Local Variables.

;;; Code:

(require 'cl-lib)
(require 'gptel)
(require 'gptel-session-constants)
(require 'gptel-session-logging)
(require 'gptel-session-filesystem)
(require 'gptel-session-registry)
(require 'gptel-session-metadata)
(require 'jf-gptel-scope-commands)
#+end_src

* Diagnostic and Maintenance Functions

Functions for debugging persistence issues and maintaining session health.

** Check for Duplicate Save Hooks

#+begin_src emacs-lisp
(defun jf/gptel--check-duplicate-hooks ()
  "Check if before-save-hook has duplicate gptel--save-state entries.
Returns the count of gptel--save-state hooks found."
  (interactive)
  (let* ((hooks (buffer-local-value 'before-save-hook (current-buffer)))
         (save-state-count (cl-count 'gptel--save-state hooks)))
    (message "before-save-hook has %d entries, %d are gptel--save-state"
             (length hooks) save-state-count)
    (when (> save-state-count 1)
      (warn "DUPLICATE HOOK DETECTED: gptel--save-state appears %d times!"
            save-state-count)
      (with-current-buffer (get-buffer-create "*Hook Duplicates*")
        (erase-buffer)
        (insert (format "Duplicate hooks detected in buffer: %s\n\n"
                        (buffer-name)))
        (insert (format "before-save-hook entries (%d total):\n" (length hooks)))
        (dolist (hook hooks)
          (insert (format "  - %s\n" hook)))
        (display-buffer (current-buffer))))
    save-state-count))
#+end_src

** Ensure gptel-mode Enabled Once

#+begin_src emacs-lisp
(defun jf/gptel--ensure-mode-once ()
  "Ensure gptel-mode is enabled exactly once with correct hooks.
Prevents duplicate before-save-hook entries that cause duplicate Local Variables."
  (unless gptel-mode
    (gptel-mode 1))

  ;; Defensive: Remove any duplicate hooks that might have accumulated
  (let ((hooks (buffer-local-value 'before-save-hook (current-buffer)))
        (count (cl-count 'gptel--save-state
                        (buffer-local-value 'before-save-hook (current-buffer)))))
    (when (> count 1)
      (jf/gptel--log 'warn "Removing %d duplicate gptel--save-state hooks" (1- count))
      ;; Remove all instances and re-add once
      (remove-hook 'before-save-hook #'gptel--save-state t)
      (add-hook 'before-save-hook #'gptel--save-state nil t))))
#+end_src

** Clean Duplicate Local Variables

#+begin_src emacs-lisp
(defun jf/gptel--clean-duplicate-local-vars ()
  "Remove all but the last Local Variables block in current buffer.
Useful for cleaning up files with duplicate blocks from previous bugs."
  (interactive)
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (let ((blocks nil)
            (changes 0))
        ;; Find all Local Variables blocks
        (while (re-search-forward "^<!-- Local Variables: -->$" nil t)
          (let ((start (match-beginning 0)))
            (when (re-search-forward "^<!-- End: -->$" nil t)
              (push (cons start (match-end 0)) blocks))))

        ;; If more than one block, delete all but the last
        (when (> (length blocks) 1)
          (setq blocks (nreverse blocks))  ; oldest first
          (dolist (block (butlast blocks))  ; all except last
            (delete-region (car block) (cdr block))
            (delete-blank-lines)
            (cl-incf changes))
          (message "Removed %d duplicate Local Variables block(s)" changes)
          (set-buffer-modified-p t)
          changes)))))
#+end_src

** Batch Clean All Session Files

#+begin_src emacs-lisp
(defun jf/gptel--batch-clean-sessions ()
  "Clean duplicate Local Variables from all session files.
Scans all sessions and removes duplicate blocks without opening buffers."
  (interactive)
  (let ((sessions (jf/gptel--find-all-sessions-recursive))
        (cleaned 0)
        (total 0))
    (dolist (session sessions)
      (let* ((session-dir (plist-get session :path))
             (session-file (jf/gptel--context-file-path session-dir)))
        (when (file-exists-p session-file)
          (cl-incf total)
          (with-temp-buffer
            (insert-file-contents session-file)
            (goto-char (point-min))
            (let ((block-count 0))
              (while (re-search-forward "^<!-- Local Variables: -->$" nil t)
                (cl-incf block-count))
              (when (> block-count 1)
                (erase-buffer)
                (insert-file-contents session-file)
                (goto-char (point-min))
                (let ((blocks nil))
                  (while (re-search-forward "^<!-- Local Variables: -->$" nil t)
                    (let ((start (match-beginning 0)))
                      (when (re-search-forward "^<!-- End: -->$" nil t)
                        (push (cons start (match-end 0)) blocks))))
                  (when (> (length blocks) 1)
                    (setq blocks (nreverse blocks))
                    (dolist (block (butlast blocks))
                      (delete-region (car block) (cdr block))
                      (delete-blank-lines))
                    (write-region (point-min) (point-max) session-file)
                    (cl-incf cleaned)
                    (jf/gptel--log 'info "Cleaned duplicates from: %s" session-file)))))))))
    (message "Cleaned %d of %d session files" cleaned total)))
#+end_src

* Auto-Initialization Hook

Function that detects and auto-initializes session files when opened via any method
(find-file, dired, recentf, etc.). This eliminates the need for manual resume commands.

** Auto-Initialize Session Buffer

#+begin_src emacs-lisp
(defun jf/gptel--auto-init-session-buffer ()
  "Auto-initialize gptel session if current buffer is a branch session file.
Detects session files by path pattern: sessions/<session-id>/branches/<branch-name>/session.md
Handles both new sessions (no Local Variables yet) and existing sessions
(Local Variables already loaded by Emacs).
This runs on every file open via find-file-hook, so performance is critical."
  ;; Fast path guards (performance critical - runs on every file open)
  (when (and (buffer-file-name)                      ; Has file? (fast)
             (not (bound-and-true-p jf/gptel--session-id)) ; Not already initialized? (fast)
             (string-suffix-p ".md" (buffer-file-name)))   ; Is .md file? (fast)
    (let* ((file-path (expand-file-name (buffer-file-name)))
           (file-name (file-name-nondirectory file-path)))
      ;; Branch session file detection: path must match */branches/*/session.md
      ;; Works for both ~/.gptel/sessions/<id>/branches/<branch>/session.md
      ;; and ~/emacs-activities/<name>/session/branches/<branch>/session.md
      (when (and (string= file-name "session.md")
                 (string-match "/branches/\\([^/]+\\)/session\\.md$" file-path))
        (let* ((branch-name (match-string 1 file-path))
               (branch-dir (file-name-directory file-path))
               (session-dir (expand-file-name "../.." branch-dir))
               ;; Extract session-id from session-dir
               (session-id (jf/gptel--session-id-from-directory session-dir)))
          ;; Validate session and branch directories
          (when (and (jf/gptel--valid-session-directory-p session-dir)
                    (jf/gptel--valid-branch-directory-p branch-dir))
            ;; Initialization (inline - no separate helper function)
            (condition-case err
                (let (;; Detect scenario: check if gptel-backend is buffer-local
                      ;; If Local Variables exist, Emacs has already loaded them
                      (has-local-vars (local-variable-p 'gptel-backend)))

                  (if has-local-vars
                      ;; SCENARIO 2: Existing session with Local Variables
                      ;; Local Variables were already loaded by Emacs before hook ran
                      (progn
                        (jf/gptel--log 'debug "Existing branch session detected (has Local Variables): %s/%s"
                                      session-id branch-name)
                        ;; Enable gptel-mode (gptel--restore-state will use existing vars)
                        (jf/gptel--ensure-mode-once)
                        ;; Load system message from preset (not in Local Variables)
                        (when-let ((preset-plist (jf/gptel--load-preset-from-file branch-dir))
                                   (system-message (plist-get preset-plist :system)))
                          (jf/gptel--set-session-system-message system-message)))

                    ;; SCENARIO 1: New session without Local Variables
                    ;; Apply preset settings BEFORE enabling gptel-mode
                    (progn
                      (jf/gptel--log 'debug "New branch session detected (no Local Variables): %s/%s"
                                    session-id branch-name)
                      ;; Load and apply preset settings (includes system message with save-prevention)
                      (let ((preset-plist (jf/gptel--load-preset-from-file branch-dir)))
                        (jf/gptel--apply-session-preset preset-plist))
                      ;; Now enable gptel-mode (will see the buffer-local settings we just applied)
                      (jf/gptel--ensure-mode-once)))

                  ;; Common steps for both scenarios
                  (setq-local jf/gptel--session-id session-id)
                  (setq-local jf/gptel--session-dir session-dir)
                  (setq-local jf/gptel--branch-name branch-name)
                  (setq-local jf/gptel--branch-dir branch-dir)
                  (jf/gptel--register-session session-dir (current-buffer) session-id branch-name branch-dir)
                  (setq-local jf/gptel-autosave-enabled t)

                  ;; Load activity worktree paths if present (for activity-scoped sessions)
                  ;; This makes worktree paths available to tools like list_activity_worktrees
                  (when (local-variable-p 'gptel-activity-worktrees)
                    (jf/gptel--log 'debug "Loaded %d activity worktree path(s)"
                                  (length gptel-activity-worktrees)))

                  ;; Update current symlink to point to this branch
                  (jf/gptel--update-current-symlink session-dir branch-name)

                  (jf/gptel--log 'info "Auto-initialized %s branch session: %s/%s"
                                (if has-local-vars "existing" "new")
                                session-id branch-name)
                  (message "Session initialized: %s (branch: %s)" session-id branch-name))
              (error
               (jf/gptel--log 'error "Failed to auto-initialize branch session: %s"
                              (error-message-string err))
               (message "Warning: Session auto-init failed. File opened in basic mode.")))))))))
#+end_src

* System Message Management

Functions for handling system messages in session buffers without triggering
gptel's Local Variables persistence. System messages are managed via preset
files to avoid duplicate Local Variables blocks when messages are >4000 chars.

** Advice: Skip System Message Save

#+begin_src emacs-lisp
(defun jf/gptel--skip-system-message-save-advice (orig-fun)
  "Prevent gptel from saving system message for session buffers.
Session system messages are managed via preset files, not Local Variables.
This advice temporarily removes the buffer-local binding during save,
preventing gptel from detecting a difference from default value."
  (if (and (boundp 'jf/gptel--session-dir) jf/gptel--session-dir
           (boundp 'gptel--system-message)
           (local-variable-p 'gptel--system-message))
      ;; Temporarily kill buffer-local binding so gptel won't save it
      (let ((saved-system-msg gptel--system-message))
        (kill-local-variable 'gptel--system-message)
        (unwind-protect
            (funcall orig-fun)
          ;; Restore buffer-local binding after save
          (setq-local gptel--system-message saved-system-msg)))
    ;; Not a session buffer or no buffer-local system message, use default behavior
    (funcall orig-fun)))
#+end_src

** Helper: Set Session System Message

#+begin_src emacs-lisp
(defun jf/gptel--set-session-system-message (system-message)
  "Set system message for session buffer without triggering Local Variables save.
System message is managed via preset files, not gptel's Local Variables persistence.
Installs buffer-local advice to prevent gptel--save-state from saving it."
  (when system-message
    ;; Set the system message in the buffer
    (setq-local gptel--system-message system-message)

    ;; Install buffer-local advice to prevent gptel from saving it
    (advice-add 'gptel--save-state :around
                #'jf/gptel--skip-system-message-save-advice
                '((local)))

    (jf/gptel--log 'debug "Set session system message (%d chars) with save-prevention"
                  (length system-message))))
#+end_src

* Preset Management Helpers

Helper functions for creating, loading, and applying session presets.

NOTE: Preset files are templates used at session creation. Once a session
is created and saved, gptel's Local Variables become the authoritative
source for settings. Presets are NOT reapplied on resume.

** Template Discovery and Selection

Helper functions for discovering and copying preset templates.

#+begin_src emacs-lisp
(defun jf/gptel--list-preset-templates ()
  "List available preset template files in jf/gptel-presets-directory.
Returns list of template names (without extensions)."
  (let* ((preset-dir (expand-file-name jf/gptel-presets-directory))
         (files (directory-files preset-dir nil "\\.\\(md\\|org\\)$")))
    (mapcar (lambda (f) (file-name-sans-extension f)) files)))

(defun jf/gptel--resolve-preset-template (template-name)
  "Resolve TEMPLATE-NAME to full path.
Checks for both .md and .org extensions.
Returns nil if template doesn't exist."
  (let* ((preset-dir (expand-file-name jf/gptel-presets-directory))
         (md-file (expand-file-name (concat template-name ".md") preset-dir))
         (org-file (expand-file-name (concat template-name ".org") preset-dir)))
    (cond
     ((file-exists-p md-file) md-file)
     ((file-exists-p org-file) org-file)
     (t nil))))

(defun jf/gptel--select-preset-template ()
  "Prompt user to select a preset template.
Returns template name (without extension)."
  (let ((templates (jf/gptel--list-preset-templates)))
    (if (null templates)
        (error "No preset templates found in %s" jf/gptel-presets-directory)
      (completing-read "Select preset template: " templates nil t nil nil "programming-assistant"))))

(defun jf/gptel--copy-preset-template (template-name session-dir)
  "Copy preset template TEMPLATE-NAME to SESSION-DIR.
Copies as preset.md or preset.org depending on source format.
Signals error if template doesn't exist."
  (let ((template-path (jf/gptel--resolve-preset-template template-name)))
    (unless template-path
      (error "Preset template not found: %s (checked .md and .org)" template-name))
    (let* ((template-ext (file-name-extension template-path))
           (dest-file (expand-file-name (concat "preset." template-ext) session-dir)))
      (when (file-exists-p dest-file)
        (jf/gptel--log 'warn "Overwriting existing preset file: %s" dest-file))
      (copy-file template-path dest-file t)
      (jf/gptel--log 'info "Copied preset template %s to %s" template-name dest-file)
      dest-file)))
#+end_src

** Normalize Preset for Serialization

Helper function to convert preset plist to serializable form.

#+begin_src emacs-lisp
(defun jf/gptel--normalize-preset-for-serialization (preset-plist)
  "Convert PRESET-PLIST to serializable form.
Backend objects → names, model symbols → strings, tools → names."
  (let* ((backend (plist-get preset-plist :backend))
         (backend-name (if (gptel-backend-p backend)
                          (gptel-backend-name backend)
                        backend))
         (model (plist-get preset-plist :model))
         (model-name (if (symbolp model) (symbol-name model) model))
         (tools (plist-get preset-plist :tools))
         (tool-names (when tools
                      (mapcar (lambda (tool)
                               (if (stringp tool) tool (gptel-tool-name tool)))
                             tools))))
    (list :backend backend-name
          :model model-name
          :tools tool-names
          :description (plist-get preset-plist :description)
          :system (plist-get preset-plist :system)
          :temperature (plist-get preset-plist :temperature)
          :include-tool-results (plist-get preset-plist :include-tool-results))))
#+end_src

** Write Preset to Markdown File

#+begin_src emacs-lisp
(defun jf/gptel--write-preset-md (session-dir preset-plist)
  "Write PRESET-PLIST as preset.md in SESSION-DIR.
Converts backend/model objects to names, tools to name strings."
  (let* ((normalized (jf/gptel--normalize-preset-for-serialization preset-plist))
         (backend-name (plist-get normalized :backend))
         (model-name (plist-get normalized :model))
         (system (plist-get normalized :system))
         (temperature (plist-get normalized :temperature))
         (include-tool-results (plist-get normalized :include-tool-results))
         (tool-names (plist-get normalized :tools))
         (preset-file (expand-file-name "preset.md" session-dir)))
    (with-temp-file preset-file
      (insert "---\n")
      (insert (format "description: %s\n" (plist-get normalized :description)))
      (insert (format "backend: %s\n" backend-name))
      (insert (format "model: %s\n" model-name))
      (insert (format "temperature: %s\n" temperature))
      (insert (format "include-tool-results: %s\n" include-tool-results))
      (when tool-names
        (insert "tools:\n")
        (dolist (tool-name tool-names)
          (insert (format "  - %s\n" tool-name))))
      (insert "---\n\n")
      (when system
        (insert system)))
    (jf/gptel--log 'info "Created preset.md: %s" preset-file)))
#+end_src

** Write Preset to Org File

#+begin_src emacs-lisp
(defun jf/gptel--write-preset-org (session-dir preset-plist)
  "Write PRESET-PLIST as preset.org in SESSION-DIR.
Converts backend/model objects to names, tools to space-separated string."
  (let* ((normalized (jf/gptel--normalize-preset-for-serialization preset-plist))
         (backend-name (plist-get normalized :backend))
         (model-name (plist-get normalized :model))
         (system (plist-get normalized :system))
         (temperature (plist-get normalized :temperature))
         (include-tool-results (plist-get normalized :include-tool-results))
         (tool-names (plist-get normalized :tools))
         (preset-file (expand-file-name "preset.org" session-dir)))
    (with-temp-file preset-file
      (insert ":PROPERTIES:\n")
      (insert (format ":description: %s\n" (plist-get normalized :description)))
      (insert (format ":backend: %s\n" backend-name))
      (insert (format ":model: %s\n" model-name))
      (insert (format ":temperature: %s\n" temperature))
      (insert (format ":include-tool-results: %s\n" include-tool-results))
      (when tool-names
        (let ((tools-str (mapconcat #'identity tool-names " ")))
          (insert (format ":tools: %s\n" tools-str))))
      (insert ":END:\n\n")
      (when system
        (insert system)))
    (jf/gptel--log 'info "Created preset.org: %s" preset-file)))
#+end_src

** Write Preset File (Dispatcher)

#+begin_src emacs-lisp
(defun jf/gptel--write-preset-file (session-dir preset-plist &optional format)
  "Write PRESET-PLIST to preset file in SESSION-DIR.
FORMAT can be 'md (markdown) or 'org (default: 'md).
Converts backend objects to names, tools to name strings."
  (let ((format (or format 'md)))
    (pcase format
      ('md (jf/gptel--write-preset-md session-dir preset-plist))
      ('org (jf/gptel--write-preset-org session-dir preset-plist))
      (_ (error "Unsupported preset format: %s (expected 'md or 'org)" format)))))
#+end_src

** Load Preset from File

NOTE: This function is kept for potential future use (e.g., creating new
sessions from existing presets), but is NOT used during session resume.

#+begin_src emacs-lisp
(defun jf/gptel--load-preset-from-file (session-dir)
  "Load preset for session in SESSION-DIR.
Supports .md and .org formats only.

Priority order:
1. session-dir/preset.md
2. session-dir/preset.org

Returns preset plist with keys :description, :backend, :model, :system,
:temperature, :include-tool-results, :tools.

NOTE: This is a template loader, not used during session resume."
  (let* ((md-file (expand-file-name "preset.md" session-dir))
         (org-file (expand-file-name "preset.org" session-dir))
         (preset-path (cond
                       ((file-exists-p md-file) md-file)
                       ((file-exists-p org-file) org-file)
                       (t (error "No preset file found in %s (expected preset.md or preset.org)" session-dir))))
         (ext (file-name-extension preset-path)))
    (unless (member ext '("md" "org"))
      (error "Unsupported preset file format: %s (expected .md or .org)" ext))
    ;; Load using gptel-agent parser
    (require 'gptel-agent)
    ;; Pass non-nil templates to trigger :system extraction (empty list '() is nil in elisp!)
    (let* ((preset-data (gptel-agent-read-file preset-path '((dummy . dummy))))
           (preset-plist (cdr preset-data))
           ;; Convert tool names to tool objects if needed
           (tools (plist-get preset-plist :tools))
           (resolved-tools
            (when tools
              (if (listp tools)
                  tools  ; Already a list
                (split-string tools)))))  ; Space-separated string from org
      ;; Update tools in plist
      (when resolved-tools
        (plist-put preset-plist :tools resolved-tools))
      ;; Convert backend name to object
      (when-let ((backend-name (plist-get preset-plist :backend)))
        (plist-put preset-plist :backend
                   (alist-get backend-name gptel--known-backends nil nil #'equal)))
      ;; Convert model name to symbol
      (when-let ((model-name (plist-get preset-plist :model)))
        (plist-put preset-plist :model
                   (if (symbolp model-name) model-name (intern model-name))))
      preset-plist)))
#+end_src

** Apply Session Preset

#+begin_src emacs-lisp
(defun jf/gptel--apply-session-preset (preset-plist)
  "Apply PRESET-PLIST to current buffer buffer-locally.
Includes tools from preset and gptel-include-tool-results for native tool persistence.

NOTE: This should only be called ONCE at session creation.
After the first save, gptel's Local Variables become the source of truth.

IMPORTANT: Sets system message with save-prevention advice to prevent gptel
from saving it to Local Variables (which causes duplicate blocks with long
messages >4000 chars). System message is managed via preset files."
  (let ((backend (plist-get preset-plist :backend))
        (model (plist-get preset-plist :model))
        (system (plist-get preset-plist :system))
        (temperature (plist-get preset-plist :temperature))
        (include-tool-results (plist-get preset-plist :include-tool-results))
        (tools (plist-get preset-plist :tools)))
    (when backend
      (setq-local gptel-backend backend))
    (when model
      (setq-local gptel-model model))
    ;; Set system message with save-prevention (so it's active from session start)
    (when system
      (jf/gptel--set-session-system-message system))
    (when temperature
      (setq-local gptel-temperature temperature))
    (when (not (null include-tool-results))
      (setq-local gptel-include-tool-results include-tool-results))
    ;; Apply tools from preset
    (when tools
      (let ((resolved-tools
             (cl-loop for tool-name in tools
                      for tool = (gptel-get-tool tool-name)
                      when tool collect tool
                      else do (jf/gptel--log 'warn "Tool not found: %s" tool-name))))
        (when resolved-tools
          (setq-local gptel-tools resolved-tools)
          (jf/gptel--log 'info "Applied %d tools from preset" (length resolved-tools)))))
    (jf/gptel--log 'info "Applied session preset as initial template (system message with save-prevention)")))
#+end_src

* Core Session Creation

Core helper function for creating session directory structure.
Shared by both jf/gptel-persistent-session and activities integration.

#+begin_src emacs-lisp
(defun jf/gptel--create-session-core (session-id session-dir preset-template scope-type &optional projects initial-content worktree-paths)
  "Create session directory structure with branching support.

SESSION-ID - unique session identifier
SESSION-DIR - parent directory for session (will contain branches/)
PRESET-TEMPLATE - name of preset template to copy
SCOPE-TYPE - symbol 'project-aware or 'deny-all
PROJECTS - optional list for project-aware scope plans
INITIAL-CONTENT - optional initial content for session.md (default: \"###\\n\")
WORKTREE-PATHS - optional list of worktree paths for activity isolation

Creates:
- SESSION-DIR/branches/main/ directory structure
- preset.md (copied from template)
- scope-plan.yml (project-aware or deny-all, optionally with worktree paths)
- session.md (with initial content)
- current symlink pointing to main branch

Returns plist with:
  :session-id - session identifier
  :session-dir - session directory path
  :branch-dir - main branch directory path
  :branch-name - \"main\"
  :session-file - path to session.md"

  (let* (;; Create branches/main/ directory
         (main-branch-dir (jf/gptel--create-branch-directory session-dir "main"))
         (session-file (jf/gptel--context-file-path main-branch-dir))
         (initial-content (or initial-content "###\n")))

    ;; Create scope plan in main branch
    (let ((scope-yaml (if (eq scope-type 'project-aware)
                         (jf/gptel--generate-scope-plan-yaml
                          session-id "project-aware" projects main-branch-dir worktree-paths)
                       (jf/gptel--generate-scope-plan-yaml session-id "deny-all" nil main-branch-dir worktree-paths)))
          (scope-file (jf/gptel--scope-plan-file-path main-branch-dir)))
      (with-temp-file scope-file
        (insert scope-yaml))
      (jf/gptel--log 'info "Created scope plan: %s" scope-file))

    ;; Copy preset template to main branch directory
    (jf/gptel--copy-preset-template preset-template main-branch-dir)

    ;; Create current symlink pointing to main
    (jf/gptel--update-current-symlink session-dir "main")

    ;; Create session file with initial content
    (with-temp-file session-file
      (insert initial-content))
    (jf/gptel--log 'info "Created session file: %s" session-file)

    ;; Return paths as plist
    (list :session-id session-id
          :session-dir session-dir
          :branch-dir main-branch-dir
          :branch-name "main"
          :session-file session-file)))
#+end_src

* Create Persistent Session (Standalone)

Interactive command to create a new *standalone* persistent programming session with scoped tools
and projectile integration. This is an alternative to the activities-based workflow described above.

Use this command when:
- You need a quick session without activity overhead
- The session is not tied to a specific activity context
- You're working on ad-hoc tasks or experiments

Uses programming assistant preset template which includes:
- Claude Opus 4.5 model
- Scoped filesystem tools (read, write, edit)
- Projectile navigation tools
- Scope management tools (inspect, request expansion)
- Detailed system prompt for programming assistance

Standalone sessions are stored in =~/.gptel/sessions/= by default.

** Workflow

1. Prompts for session name
2. Optionally prompts to select projectile projects (y-or-n-p)
3. If projects selected: Multi-select from =projectile-known-projects=
4. Creates session directory structure
5. Stores selected projects in metadata (=:projects=, =:project-names= fields)
6. Creates scope plan:
   - *With projects*: project-aware template (scoped read/write/edit to selected projects)
   - *Without projects*: deny-all template (secure default)
7. Creates preset.md as template (ONE TIME USE)
8. Applies preset settings to buffer (ONE TIME)
9. Opens session buffer
10. After first save, gptel's Local Variables become source of truth

** Projectile Integration

When projects are selected:
- Session metadata includes =:projects= (full paths) and =:project-names= (display names)
- Scope plan restricts all operations to selected project directories
- Git-safe editing enforced: =edit_file_in_scope= only allows git-tracked files
- Prevents accidental modification of ignored files (node_modules/, build artifacts, etc.)

#+begin_src emacs-lisp
(defun jf/gptel-persistent-session (session-name &optional backend model preset-template)
  "Create a new persistent gptel session named SESSION-NAME.

Optional BACKEND and MODEL default to Claude Opus 4.5.
Optional PRESET-TEMPLATE specifies template name (default: \"programming-assistant\").
With prefix argument (C-u), prompts to select template interactively.

Prompts user to select projectile projects (0 or more).
If projects selected, creates project-aware scope plan.
Otherwise creates deny-all scope plan.

Creates session with branches/main/ structure and current symlink.
The session auto-initializes when opened (via find-file-hook).

To open existing sessions: Just use find-file (C-x C-f) or dired on ~/.gptel/sessions/
No special resume command needed - sessions auto-initialize when opened.

The session will auto-save to ~/.gptel/sessions/SESSION-NAME-TIMESTAMP/branches/main/session.md"
  (interactive
   (let ((name (read-string "Session name: "))
         (template (if current-prefix-arg
                       (jf/gptel--select-preset-template)
                     "programming-assistant")))
     (list name nil nil template)))
  (let* ((session-id (jf/gptel--generate-session-id session-name))
         (session-dir (jf/gptel--create-session-directory session-id))
         (preset-template (or preset-template "programming-assistant"))
         ;; Project selection
         (selected-projects (when (y-or-n-p "Select projectile projects for this session? ")
                             (jf/gptel--select-projects)))
         (project-names (when selected-projects
                         (mapcar #'jf/gptel--project-display-name selected-projects)))
         (scope-type (if selected-projects 'project-aware 'deny-all))
         (initial-content (format "# %s\n\n" session-name)))

    ;; Create session structure using core helper
    (let* ((session-info (jf/gptel--create-session-core
                         session-id
                         session-dir
                         preset-template
                         scope-type
                         selected-projects
                         initial-content))
           (session-file (plist-get session-info :session-file)))

      ;; Open session file - auto-initialization hook will handle the rest
      (let ((buffer (find-file session-file)))
        (jf/gptel--log 'info "Created session: %s%s"
                      session-id
                      (if selected-projects
                          (format " with %d project(s)" (length selected-projects))
                        ""))
        (message "Created session: %s\nDirectory: %s\nBranch: main\nTemplate: %s%s\n\nSession will auto-initialize when opened."
                 session-name
                 session-dir
                 preset-template
                 (if project-names
                     (format "\nProjects: %s" (string-join project-names ", "))
                   ""))
        buffer))))
#+end_src

* Initialize Registry

Command to initialize/refresh the session registry.

#+begin_src emacs-lisp
(defun jf/gptel-refresh-sessions ()
  "Refresh the session registry by scanning session directories.
Useful if sessions were created outside Emacs or after startup."
  (interactive)
  (jf/gptel--init-registry)
  (message "Refreshed session registry: %d sessions found"
          (jf/gptel--session-count)))
#+end_src

* Session Diagnostics

Check session state and advice installation.

#+begin_src emacs-lisp
(defun jf/gptel-session-diagnostics ()
  "Show diagnostic information about current session and advice installation."
  (interactive)
  (with-current-buffer (get-buffer-create "*GPTEL Session Diagnostics*")
    (erase-buffer)
    (insert "GPTEL Session Diagnostics\n")
    (insert "=========================\n\n")

    ;; Current buffer info
    (insert "Current Buffer:\n")
    (insert (format "  Name: %s\n" (buffer-name)))
    (insert (format "  Session ID: %s\n" (or jf/gptel--session-id "NOT SET")))
    (insert (format "  Session Dir: %s\n" (or jf/gptel--session-dir "NOT SET")))
    (insert (format "  GPTel Mode: %s\n" (if (bound-and-true-p gptel-mode) "enabled" "disabled")))
    (insert (format "  Auto-save: %s\n" (if jf/gptel-autosave-enabled "enabled" "disabled")))
    (insert "\n")

    ;; Hook diagnostics
    (insert "Save Hook Status:\n")
    (let* ((hooks (buffer-local-value 'before-save-hook (current-buffer)))
           (count (cl-count 'gptel--save-state hooks)))
      (insert (format "  Total before-save-hook entries: %d\n" (length hooks)))
      (insert (format "  gptel--save-state hooks: %d\n" count))
      (when (> count 1)
        (insert (format "  WARNING: Duplicate hooks detected!\n"))))
    (insert "\n")

    ;; Advice installation
    (insert "Advice Installation:\n")
    (insert (format "  gptel--fsm-transition (tool logging): %s\n"
                    (if (advice-member-p #'jf/gptel--advice-log-fsm-transition 'gptel--fsm-transition)
                        "INSTALLED"
                      "NOT INSTALLED")))
    (insert (format "  gptel--set-with-scope (system prompt): %s\n"
                    (if (and (fboundp 'gptel--set-with-scope)
                            (advice-member-p #'jf/gptel--advice-track-system-prompt 'gptel--set-with-scope))
                        "INSTALLED"
                      "NOT INSTALLED")))
    (insert "\n")

    ;; Log level
    (insert "Configuration:\n")
    (insert (format "  Log Level: %s\n" jf/gptel-log-level))
    (insert (format "  Sessions Directory: %s\n" jf/gptel-sessions-directory))
    (insert (format "  Registry Count: %d\n" (jf/gptel--session-count)))

    (goto-char (point-min))
    (display-buffer (current-buffer))))
#+end_src

* Branch Session Command

User-facing command to branch the current session. Implementation is in branching.el.

#+begin_src emacs-lisp
;; Branch session command is provided by branching.el
;; This is just a forward declaration for documentation
(declare-function jf/gptel-branch-session "branching" (&optional branch-name))
#+end_src

* Hook Installation

Install find-file-hook for automatic session initialization.

#+begin_src emacs-lisp
;; Auto-initialize sessions when opened via find-file, dired, recentf, etc.
(add-hook 'find-file-hook #'jf/gptel--auto-init-session-buffer)
#+end_src

* Provide Feature

#+begin_src emacs-lisp
(provide 'gptel-session-commands)
;;; commands.el ends here
#+end_src
