#+title: GPTEL Agent Tracing
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle tracing.el
#+auto_tangle: y

* Introduction

Agent tracing captures the complete execution flow of subagents, including:
- Task delegation (which agent was called, with what prompt)
- Streaming LLM responses (real-time capture of response chunks)
- Tool calls (which tools were invoked with what arguments)
- Results (what the agent returned)
- Timing and hierarchy (parent/child relationships, depth)

All traces are stored both in the global registry (for active session access)
and on disk (for persistence and later analysis).

This module provides:
- Trace creation and completion
- Tool call recording

* Tool Usage Capture Feature

** Overview

The tool usage capture feature extends gptel session saving to record complete
information about every tool invocation during agent execution. This provides
a detailed audit trail of:

- Which tools were called (tool names)
- What arguments were provided (serialized as Lisp plists)
- What results were returned (previews for small results, separate files for large)
- When tools were invoked (timestamps)
- Which agent invoked them (trace association)

This data is captured for subagents (explorer, planner, etc.) running in hidden
buffers and enables session replay, debugging, and analysis of agent behavior.

** What Gets Captured

*** Subagent Tool Calls (✅ Fully Captured)
All tool invocations within subagent execution are captured with:
- API-provided tool use IDs (e.g., ~toolu_01ABC...~ from Claude, ~call_XYZ...~ from OpenAI)
- Tool name (e.g., "Read", "Glob", "Grep")
- Arguments as Lisp plist strings (e.g., ~(:file_path "~/file.txt")~)
- Results:
  - Small results (<1KB): Stored inline as ~result_preview~
  - Large results (≥1KB): Saved to ~jf/gptel-session-trace-tool-results-dirname/TOOL_ID.txt~, preview truncated to 200 chars
- Timestamp of tool invocation
- Error status (if tool call failed)

*** Main Conversation Tool Calls (⚠️ Not Currently Captured)
Tool calls in the main conversation (e.g., the Agent tool itself) are NOT captured
in structured form because:
- Main conversation uses gptel's stream processor, not callback-based tool handling
- Wrapping callbacks breaks streaming (responses wouldn't appear in buffer)
- Tool usage is visible in response content but not as structured metadata

The Agent tool invocation is visible in the response markdown but not in ~session_tool_calls~.

** Reading Session Files

*** Session Directory Structure

#+begin_example
~/gptel-sessions/SESSION_ID/
├── metadata.json              # Session-level metadata with tool calls
├── message-N.md               # User messages
├── response-N.md              # LLM responses
├── jf/gptel-session-trace-tool-results-dirname/              # Large tool results from main conversation
│   └── TOOL_ID.txt
└── traces/                    # Subagent execution traces
    └── trace-N/
        ├── metadata.json      # Trace-level metadata with tool calls
        ├── prompt.txt         # Subagent initial prompt
        ├── response-N.txt     # Streaming response chunks
        ├── result.txt         # Final subagent result
        └── jf/gptel-session-trace-tool-results-dirname/      # Large tool results from this trace
            └── TOOL_ID.txt
#+end_example

*** Session Metadata Format

The ~metadata.json~ file contains:

#+begin_src json
{
  "session_id": "20260118-180624-gpt-4o",
  "model": "gpt-4o",
  "created": "2026-01-18T18:06:24Z",
  "tree": { /* conversation tree */ },
  "agent_traces": [
    {
      "trace_id": "trace-1",
      "agent_type": "explorer",
      "description": "Read Brewfile",
      "prompt_preview": "Locate the Brewfile...",
      "timestamp_start": "2026-01-18T18:06:26Z",
      "timestamp_end": "2026-01-18T18:07:04Z",
      "status": "completed",
      "parent_trace_id": null,
      "depth": 0,
      "tool_calls": [
        {
          "tool_use_id": "toolu_016Jk7BpspkjSBQNt2Xi4bn4",
          "tool_name": "Glob",
          "timestamp": "2026-01-18T18:06:30Z",
          "args_str": "(:pattern \"Brewfile\" :path \"~\")",
          "result_preview": "error Error: Executable 'tree' not found",
          "result_file": null,
          "error": null
        },
        {
          "tool_use_id": "toolu_015UwcuikDaZYowa5nkiDk4H",
          "tool_name": "Read",
          "timestamp": "2026-01-18T18:06:40Z",
          "args_str": "(:file_path \"~/Brewfile\")",
          "result_preview": "tap \"hashicorp/tap\"...",
          "result_file": "toolu_015UwcuikDaZYowa5nkiDk4H.txt",
          "error": null
        }
      ],
      "associated_nodes": ["message-1", "response-1"]
    }
  ]
}
#+end_src

*** Tool Call Fields

- ~tool_use_id~: Unique identifier from the LLM API (stable, not generated by us)
- ~tool_name~: Name of the tool that was invoked
- ~timestamp~: When the tool was called (ISO 8601 format)
- ~args_str~: Tool arguments serialized as Lisp plist string using ~prin1-to-string~
- ~result_preview~: First 200-500 chars of result (or full result if small)
- ~result_file~: Filename in ~jf/gptel-session-trace-tool-results-dirname/~ directory (only for large results)
- ~error~: Error message if tool call failed (usually null)

*** Trace Metadata Format

Each trace directory contains its own ~metadata.json~:

#+begin_src json
{
  "trace_id": "trace-1",
  "messages": [
    {"id": "prompt.txt", "file": "prompt.txt", "timestamp": "...", "tokens": 0},
    {"id": "response-0.txt", "file": "response-0.txt", "timestamp": "...", "tokens": 0},
    {"id": "result.txt", "file": "result.txt", "timestamp": "...", "tokens": 0}
  ],
  "tool_calls": [ /* Same format as session metadata */ ],
  "total_tokens": 0
}
#+end_src

This provides the same tool call data at trace level for local analysis.

** Implementation Architecture

*** Component Dependencies

#+begin_example
                         ┌──────────────────────┐
                         │   gptel-request      │
                         │ (streaming & tools)  │
                         └──────────┬───────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    │               │               │
            ┌───────▼──────┐ ┌─────▼──────┐ ┌─────▼──────┐
            │ gptel-agent  │ │   Main     │ │   FSM      │
            │   --task     │ │Conversation│ │  :tool-use │
            └───────┬──────┘ └─────┬──────┘ └─────┬──────┘
                    │               │               │
         ┌──────────▼───────────────▼───────────────▼─────────┐
         │           hooks.el (Advice Layer)                   │
         │  ┌────────────────────────────────────────────┐   │
         │  │ jf/gptel--trace-agent-task                 │   │
         │  │  - Wraps agent task creation               │   │
         │  │  - Creates trace in registry               │   │
         │  │  - Wraps completion callback               │   │
         │  └────────────────────────────────────────────┘   │
         │  ┌────────────────────────────────────────────┐   │
         │  │ jf/gptel--inject-session-context           │   │
         │  │  - Adds session-id to request context      │   │
         │  └────────────────────────────────────────────┘   │
         │  ┌────────────────────────────────────────────┐   │
         │  │ jf/gptel--capture-subagent-messages        │   │
         │  │  - Wraps callback (subagents only)         │   │
         │  │  - Intercepts 'tool-result events          │   │
         │  │  - Calls recording functions               │   │
         │  └─────────────────┬──────────────────────────┘   │
         └────────────────────┼───────────────────────────────┘
                              │
         ┌────────────────────▼───────────────────────────────┐
         │          tracing.el (Recording Layer)              │
         │  ┌────────────────────────────────────────────┐   │
         │  │ jf/gptel--record-complete-tool-call        │   │
         │  │  - Records tool call with all data         │   │
         │  │  - Writes to session metadata              │   │
         │  │  - Writes to trace metadata (alist)        │   │
         │  │  - Saves large results to files            │   │
         │  └────────────────────────────────────────────┘   │
         │  ┌────────────────────────────────────────────┐   │
         │  │ jf/gptel--save-trace-message               │   │
         │  │  - Saves streaming response chunks         │   │
         │  └────────────────────────────────────────────┘   │
         └────────────────────────────────────────────────────┘
                              │
         ┌────────────────────▼───────────────────────────────┐
         │         registry.el (State Management)             │
         │  - Session-id → session data mapping               │
         │  - Trace stack for hierarchy                       │
         │  - Buffer-local variables                          │
         └────────────────────────────────────────────────────┘
#+end_example

*** Data Flow for Tool Capture

#+begin_example
User invokes Agent tool in main conversation
    │
    ├─→ [Main Conversation - No callback wrapping]
    │   - Stream processor handles text insertion
    │   - No tool capture (maintains transparency)
    │   - Response appears normally in buffer
    │
    └─→ gptel-agent--task spawns subagent
            │
            ▼
        jf/gptel--trace-agent-task (advice)
            │
            ├─→ Create trace entry in registry
            │   - Generate trace-id
            │   - Push to trace stack
            │   - Record start time
            │
            ├─→ Inject session-id into context
            │   - Overlay property for subagents
            │
            └─→ Wrap callback
                    │
                    ▼
        Subagent makes API request
            │
            ├─→ jf/gptel--inject-session-context
            │   - Propagates session-id
            │
            └─→ jf/gptel--capture-subagent-messages
                    │
                    ├─→ Wrap callback (existing-callback present)
                    │   - Install response interceptor
                    │
                    └─→ Callback receives events:
                            │
                            ├─→ 'string → Save to trace
                            │
                            ├─→ 'tool-result → CAPTURE TOOLS
                            │   │
                            │   └─→ Extract from FSM info :tool-use
                            │       - Has :id, :name, :args, :result
                            │       - Call jf/gptel--record-complete-tool-call
                            │           │
                            │           ├─→ Convert plist to alist
                            │           │
                            │           ├─→ Check result size
                            │           │   - <1KB: inline preview
                            │           │   - ≥1KB: save to file
                            │           │
                            │           ├─→ Update session metadata
                            │           │   - agent_traces[N].tool_calls[]
                            │           │
                            │           └─→ Update trace metadata
                            │               - traces/trace-N/metadata.json
                            │
                            └─→ 'stream-end → Mark complete
                                    │
                                    └─→ jf/gptel--complete-trace
                                        - Pop trace stack
                                        - Set end time
#+end_example

*** Key Design Decisions

**** 1. Capture at 'tool-result Event

**Rationale**: Tool execution is asynchronous. The ~'tool-call~ event fires before
execution, but results aren't available yet. The ~'tool-result~ event fires AFTER
all tools complete, and the FSM info plist contains complete data including results.

**Implementation**: Extract tools from ~(plist-get info :tool-use)~ when callback
receives ~(cons 'tool-result ...)~ response.

**** 2. Use API-Provided Tool IDs

**Rationale**: LLM APIs provide stable tool use IDs (e.g., ~toolu_01ABC...~ from
Claude, ~call_XYZ...~ from OpenAI). These are better than generated IDs because:
- Stable across requests
- Traceable in API logs
- Match API billing/usage data
- Globally unique

**Implementation**: Extract ~:id~ field from tool-call plist.

**** 3. Serialize Arguments with prin1-to-string

**Rationale**: Initial implementation used ~json-encode~ but this failed on complex
Lisp data structures (special characters, nested structures). ~prin1-to-string~
handles any Lisp object correctly.

**Trade-off**: Output is Lisp syntax (harder to read in JSON) but always succeeds.

**** 4. Store Large Results in Separate Files

**Rationale**: Tool results can be very large (e.g., complete file contents). Storing
everything in metadata.json would make it unreadable and slow to parse.

**Implementation**: Results ≥1KB saved to ~jf/gptel-session-trace-tool-results-dirname/TOOL_ID.txt~, with 200-char
preview in metadata.

**** 5. Skip Callback Wrapping for Main Conversation

**Rationale**: Main conversation doesn't use ~:callback~ parameter - it uses gptel's
stream processor directly. Installing a callback breaks streaming (responses won't
appear in buffer).

**Implementation**: Check ~(and (not trace-id) (not existing-callback))~ and skip
wrapping entirely. This maintains complete transparency for main conversation.

**** 6. Dual Metadata Storage

**Rationale**: Tool calls are stored in BOTH session-level metadata (~metadata.json~)
and trace-level metadata (~traces/trace-N/metadata.json~) because:
- Session-level: Quick overview of all traces
- Trace-level: Self-contained trace analysis

**Implementation**: ~jf/gptel--record-complete-tool-call~ writes to both using alist
operations (JSON compatibility).

*** Error Handling

All tool capture code is wrapped in ~condition-case~ to prevent errors from breaking
the callback chain:

#+begin_src emacs-lisp :tangle no
(condition-case err
    (jf/gptel--record-complete-tool-call session-id trace-id tool-call)
  (error
   (message "ERROR capturing tool call: %s" (error-message-string err))))
#+end_src

If tool capture fails:
- Error logged to *Messages* buffer
- Original callback still runs
- Conversation continues normally
- Only tool metadata is lost (not the actual response)

** Known Limitations

*** 1. No Main Conversation Tool Capture

Agent tool invocations in the main conversation are not captured as structured
metadata. They're visible in response content but not in ~session_tool_calls~.

**Reason**: Preserving streaming transparency - wrapping callbacks breaks text insertion.

**Workaround**: Could parse response content in post-response hook (text parsing,
less reliable).

*** 2. No Millisecond-Precision Timestamps

Timestamps use ~format-time-string~ which provides second-level precision. Sub-second
timing data is not captured.

**Impact**: Can't measure tool execution time precisely.

**Workaround**: Would require using ~current-time~ and storing high-resolution timestamps.

*** 3. Alist/Plist Data Structure Mixing

Session metadata (from JSON) uses alists, but tool-call data starts as plists.
Must convert plists to alists before storing in trace metadata.

**Impact**: Implementation complexity, risk of format mismatch.

**Mitigation**: Explicit conversion in ~jf/gptel--record-complete-tool-call~.

*** 4. No Token Count Tracking

Tool results don't include token counts. The ~:tokens~ field in trace metadata
is always 0.

**Reason**: Token data not available in callback info plist.

**Impact**: Can't analyze token usage per tool call.

** Future Enhancements

*** Possible Improvements

1. **Main conversation tool capture**: Parse response content in post-response hook
2. **Token counting**: Extract from API response metadata if available
3. **High-resolution timestamps**: Use ~current-time~ for microsecond precision
4. **Tool execution timing**: Calculate duration from start/end timestamps
5. **Tool success/failure status**: Add explicit success field (not just error)
6. **Compressed storage**: Gzip large tool results automatically
7. **Query interface**: Emacs functions to search tool calls by name, time, trace

*** Non-Goals

1. **Real-time tool monitoring**: This is post-hoc analysis, not live debugging
2. **Tool result modification**: Capture only, no replay or editing capability
3. **Cross-session analysis**: Each session is independent, no aggregation

** Testing and Validation

*** Verification Checklist

After implementing tool capture, verify:

- [ ] Tool calls appear in ~metadata.json~ under ~agent_traces[N].tool_calls~
- [ ] Tool calls appear in ~traces/trace-N/metadata.json~ under ~tool_calls~
- [ ] Large results (>1KB) saved to ~jf/gptel-session-trace-tool-results-dirname/~ with correct TOOL_ID filename
- [ ] Small results (<1KB) stored inline in ~result_preview~
- [ ] API-provided tool IDs present (not synthetic)
- [ ] Arguments serialized correctly as Lisp plists
- [ ] Error results captured (e.g., "Executable 'tree' not found")
- [ ] Multiple tools in single request all captured
- [ ] Timestamps in ISO 8601 format
- [ ] Main conversation streaming works normally
- [ ] No errors in *Messages* buffer during capture

*** Example Test Session

#+begin_src emacs-lisp :tangle no
;; 1. Start fresh isolated Emacs instance
;; 2. Open gptel buffer: M-x gptel
;; 3. Use Agent tool: "Use explorer agent to read ~/Brewfile"
;; 4. Wait for completion
;; 5. Check session directory: ~/gptel-sessions/LATEST/
;; 6. Verify metadata.json has populated tool_calls arrays
;; 7. Verify trace-1/metadata.json matches
;; 8. Check jf/gptel-session-trace-tool-results-dirname/ directory for large results
#+end_src

** Related Documentation

- ~hooks.org~: Callback wrapping mechanism and advice installation
- ~registry.org~: Session state management and trace stack
- ~metadata.org~: Conversation tree and file management
- ~tracing.org~: This file - tool capture implementation
- Message storage (prompts, responses, results)
- Trace hierarchy management

* Lexical Binding

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(require 'cl-lib)
#+end_src

* Create Trace

#+begin_src emacs-lisp
(defun jf/gptel--create-trace (session-id agent-type description prompt &optional parent-trace-id)
  "Create new agent trace entry in session.
Looks up session from registry, updates metadata, returns trace-id."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata)))
    (let* ((trace-counter (plist-get session-data :trace-counter))
           (trace-id (format "%s%d" jf/gptel-session-node-prefix-trace (cl-incf trace-counter)))
           (trace-stack (plist-get session-data :trace-stack))
           (depth (length trace-stack))
           (trace (list :trace_id trace-id
                       :agent_type agent-type
                       :description description
                       :prompt_preview (substring prompt 0 (min 200 (length prompt)))
                       :timestamp_start (format-time-string "%Y-%m-%dT%H:%M:%SZ")
                       :timestamp_end nil
                       :status "running"
                       :parent_trace_id parent-trace-id
                       :depth depth
                       :tool_calls []
                       :associated_nodes nil)))
      ;; Update registry: increment counter, push to stack
      (jf/gptel--update-session-data session-id :trace-counter trace-counter)
      (jf/gptel--update-session-data session-id :trace-stack (cons trace-id trace-stack))

      ;; Add to metadata's agent_traces array
      (let ((traces (plist-get metadata :agent_traces)))
        (plist-put metadata :agent_traces
                   (vconcat traces (vector trace))))

      ;; Write metadata to disk (incremental)
      (let ((session-dir (plist-get session-data :directory)))
        (jf/gptel--write-metadata session-dir metadata))

      trace-id)))
#+end_src

* Complete Trace

#+begin_src emacs-lisp
(defun jf/gptel--complete-trace (session-id trace-id status)
  "Mark trace as completed, pop from stack."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata))
              (traces (plist-get metadata :agent_traces)))
    ;; Find and update the trace
    (let ((trace (cl-find-if (lambda (tr)
                              (equal (plist-get tr :trace_id) trace-id))
                            (append traces nil))))
      (when trace
        (plist-put trace :timestamp_end (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
        (plist-put trace :status status)

        ;; Pop from trace stack in registry
        (let ((trace-stack (plist-get session-data :trace-stack)))
          (jf/gptel--update-session-data session-id :trace-stack
                                        (remove trace-id trace-stack)))

        ;; Write metadata to disk
        (let ((session-dir (plist-get session-data :directory)))
          (jf/gptel--write-metadata session-dir metadata))))))
#+end_src

* Current Trace ID

#+begin_src emacs-lisp
(defun jf/gptel--current-trace-id (session-id)
  "Get current trace ID (top of stack) from session."
  (when-let ((session-data (jf/gptel--get-session-data session-id)))
    (car (plist-get session-data :trace-stack))))
#+end_src

* Tool Call Recording

** Generate Tool Use ID

#+begin_src emacs-lisp
(defun jf/gptel--generate-tool-use-id (tool-name)
  "Generate a tool use ID in Claude API format.
Returns format: toolu_TIMESTAMP_RANDOM."
  (format "toolu_%s_%04x"
          (format-time-string "%Y%m%d%H%M%S")
          (random 65536)))
#+end_src

** Record Complete Tool Call

This function captures a tool call after execution is complete, when we have
all information (ID, name, args, result) in one place.

#+begin_src emacs-lisp
(defun jf/gptel--record-complete-tool-call (session-id trace-id tool-call-plist)
  "Record a complete tool call with ID, name, args, and result.
TOOL-CALL-PLIST has :id, :name, :args, and :result from gptel.
If TRACE-ID is nil, records to session-level. Otherwise records to trace."
  (let* ((tool-id (plist-get tool-call-plist :id))
         (tool-name (plist-get tool-call-plist :name))
         (args (plist-get tool-call-plist :args))
         (result (plist-get tool-call-plist :result))
         (args-str (prin1-to-string args))
         (timestamp (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
         ;; Convert result to string
         (result-str (cond
                      ((stringp result) result)
                      ((listp result) (format "%S" result))
                      (t (format "%s" result))))
         ;; Create tool call entry
         (tool-call (list :tool_use_id tool-id
                         :tool_name tool-name
                         :timestamp timestamp
                         :args_str args-str
                         :result_preview nil
                         :result_file nil
                         :error nil)))

    ;; Decide storage strategy for result
    (if (< (length result-str) 1024)
        ;; Small result: store inline
        (plist-put tool-call :result_preview
                  (jf/gptel--preview-string result-str 500))
      ;; Large result: save to file
      (when-let* ((session-data (jf/gptel--get-session-data session-id))
                  (session-dir (plist-get session-data :directory)))
        (let* ((results-dir (if trace-id
                               (expand-file-name
                                (format "%s/%s/%s"
                                        jf/gptel-session-traces-dirname
                                        trace-id
                                        jf/gptel-session-trace-tool-results-dirname)
                                session-dir)
                             (expand-file-name jf/gptel-session-trace-tool-results-dirname session-dir)))
               (result-file (format "%s.txt" tool-id))
               (result-path (expand-file-name result-file results-dir)))
          (make-directory results-dir t)
          (with-temp-file result-path
            (insert result-str))
          (plist-put tool-call :result_preview
                    (jf/gptel--preview-string result-str 200))
          (plist-put tool-call :result_file result-file))))

    ;; Store in appropriate location
    (when-let* ((session-data (jf/gptel--get-session-data session-id))
                (metadata (plist-get session-data :metadata)))
      (if trace-id
          ;; Store in trace
          (when-let* ((traces (plist-get metadata :agent_traces))
                      (trace (cl-find-if (lambda (tr)
                                          (equal (plist-get tr :trace_id) trace-id))
                                        (append traces nil))))
            (let ((calls (plist-get trace :tool_calls)))
              (plist-put trace :tool_calls (vconcat calls (vector tool-call)))))
        ;; Store in session
        (let ((calls (or (plist-get metadata :session_tool_calls) [])))
          (plist-put metadata :session_tool_calls (vconcat calls (vector tool-call)))))

      ;; Write session metadata immediately
      (let ((session-dir (plist-get session-data :directory)))
        (jf/gptel--write-metadata session-dir metadata))

      ;; Also update trace directory metadata if this is a trace
      (when trace-id
        (when-let* ((session-dir (plist-get session-data :directory))
                    (trace-dir (expand-file-name (format "%s/%s" jf/gptel-session-traces-dirname trace-id) session-dir))
                    (metadata-file (expand-file-name jf/gptel-session-trace-metadata-filename trace-dir)))
          (let* ((trace-metadata (if (file-exists-p metadata-file)
                                    (with-temp-buffer
                                      (insert-file-contents metadata-file)
                                      (goto-char (point-min))
                                      (json-read))
                                  ;; Initial structure as alist (compatible with json-read output)
                                  (list (cons 'trace_id trace-id)
                                        (cons 'messages [])
                                        (cons 'tool_calls [])
                                        (cons 'total_tokens 0))))
                 ;; Use alist-get since json-read returns alist
                 (tool-calls (alist-get 'tool_calls trace-metadata))
                 ;; Convert tool-call plist to alist for JSON encoding
                 (tool-call-alist
                  (list (cons 'tool_use_id (plist-get tool-call :tool_use_id))
                        (cons 'tool_name (plist-get tool-call :tool_name))
                        (cons 'timestamp (plist-get tool-call :timestamp))
                        (cons 'args_str (plist-get tool-call :args_str))
                        (cons 'result_preview (plist-get tool-call :result_preview))
                        (cons 'result_file (plist-get tool-call :result_file))
                        (cons 'error (plist-get tool-call :error)))))
            ;; Update tool_calls in alist using setf
            (setf (alist-get 'tool_calls trace-metadata)
                  (vconcat tool-calls (vector tool-call-alist)))
            ;; Write updated trace metadata
            (make-directory trace-dir t)
            (with-temp-file metadata-file
              (let ((json-encoding-pretty-print t))
                (insert (json-encode trace-metadata))))))))))
#+end_src

** OLD: Record Initial Tool Call (Deprecated)

This two-phase approach is deprecated in favor of recording complete tool calls.
Kept for reference but should not be used.

#+begin_src emacs-lisp :tangle no
(defun jf/gptel--record-tool-call-initial (session-id trace-id tool args)
  "Record initial tool call (before execution).
TOOL is the tool object, ARGS is the arguments plist.
Captures tool name, ID, arguments, and timestamp."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata))
              (traces (plist-get metadata :agent_traces)))
    ;; Find the trace
    (let ((trace (cl-find-if (lambda (tr)
                              (equal (plist-get tr :trace_id) trace-id))
                            (append traces nil))))
      (when trace
        (let* ((tool-name (gptel-tool-name tool))
               (tool-use-id (jf/gptel--generate-tool-use-id tool-name))
               (args-str (prin1-to-string args))
               (tool-call (list :tool_use_id tool-use-id
                               :tool_name tool-name
                               :timestamp_call (format-time-string "%Y-%m-%dT%H:%M:%SZ")
                               :timestamp_result nil
                               :args_str args-str
                               :result_preview nil
                               :result_file nil
                               :error nil)))
          ;; Append to trace's tool_calls
          (let ((calls (plist-get trace :tool_calls)))
            (plist-put trace :tool_calls (vconcat calls (vector tool-call)))))

        ;; Write metadata immediately
        (let ((session-dir (plist-get session-data :directory)))
          (jf/gptel--write-metadata session-dir metadata))))))
#+end_src

** OLD: Record Tool Call Result (Deprecated)

#+begin_src emacs-lisp :tangle no
(defun jf/gptel--record-tool-call-result (session-id trace-id tool-name args result)
  "Update tool call with result after execution.
Finds matching tool call by TOOL-NAME and ARGS, updates with RESULT."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata))
              (traces (plist-get metadata :agent_traces)))
    (let ((trace (cl-find-if (lambda (tr)
                              (equal (plist-get tr :trace_id) trace-id))
                            (append traces nil))))
      (when trace
        (let* ((tool-calls (plist-get trace :tool_calls))
               (args-str (prin1-to-string args))
               ;; Find matching tool call (by name, args, and null result)
               (tool-call (cl-find-if
                          (lambda (tc)
                            (and (equal (plist-get tc :tool_name) tool-name)
                                 (equal (plist-get tc :args_str) args-str)
                                 (null (plist-get tc :timestamp_result))))
                          (append tool-calls nil))))
          (when tool-call
            ;; Convert result to string
            (let ((result-str (cond
                               ((stringp result) result)
                               ((listp result) (format "%S" result))
                               (t (format "%s" result)))))
              ;; Decide storage strategy based on result size
              (if (< (length result-str) 1024)
                  ;; Small result: store inline
                  (progn
                    (plist-put tool-call :result_preview
                              (jf/gptel--preview-string result-str 500))
                    (plist-put tool-call :result_file nil))
                ;; Large result: save to file
                (let* ((session-dir (plist-get session-data :directory))
                       (trace-dir (expand-file-name
                                  (format "%s/%s" jf/gptel-session-traces-dirname trace-id) session-dir))
                       (results-dir (expand-file-name jf/gptel-session-trace-tool-results-dirname trace-dir))
                       (tool-use-id (plist-get tool-call :tool_use_id))
                       (result-file (format "%s.txt" tool-use-id))
                       (result-path (expand-file-name result-file results-dir)))
                  ;; Create directory
                  (make-directory results-dir t)
                  ;; Save result to file
                  (with-temp-file result-path
                    (insert result-str))
                  ;; Update metadata
                  (plist-put tool-call :result_preview
                            (jf/gptel--preview-string result-str 200))
                  (plist-put tool-call :result_file result-file)))

              ;; Update timestamp
              (plist-put tool-call :timestamp_result
                        (format-time-string "%Y-%m-%dT%H:%M:%SZ"))))

          ;; Write metadata immediately
          (let ((session-dir (plist-get session-data :directory)))
            (jf/gptel--write-metadata session-dir metadata)))))))
#+end_src

** OLD: Record Tool Call Error (Deprecated)

#+begin_src emacs-lisp :tangle no
(defun jf/gptel--record-tool-call-error (session-id trace-id tool-name args error-msg)
  "Record tool call error.
Finds matching tool call and marks it with ERROR-MSG."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata))
              (traces (plist-get metadata :agent_traces)))
    (let ((trace (cl-find-if (lambda (tr)
                              (equal (plist-get tr :trace_id) trace-id))
                            (append traces nil))))
      (when trace
        (let* ((tool-calls (plist-get trace :tool_calls))
               (args-str (prin1-to-string args))
               (tool-call (cl-find-if
                          (lambda (tc)
                            (and (equal (plist-get tc :tool_name) tool-name)
                                 (equal (plist-get tc :args_str) args-str)
                                 (null (plist-get tc :timestamp_result))))
                          (append tool-calls nil))))
          (when tool-call
            (plist-put tool-call :error error-msg)
            (plist-put tool-call :timestamp_result
                      (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
            (let ((session-dir (plist-get session-data :directory)))
              (jf/gptel--write-metadata session-dir metadata))))))))
#+end_src

* OLD: Session-Level Tool Call Recording (Deprecated)

These functions are deprecated. Use jf/gptel--record-complete-tool-call instead.

** OLD: Record Initial Session Tool Call (Deprecated)

#+begin_src emacs-lisp :tangle no
(defun jf/gptel--record-session-tool-call-initial (session-id tool args)
  "Record tool call in main conversation (not a trace).
TOOL is the tool object, ARGS is the arguments plist."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata)))
    (let* ((tool-name (gptel-tool-name tool))
           (tool-use-id (jf/gptel--generate-tool-use-id tool-name))
           (args-str (prin1-to-string args))
           (tool-call (list :tool_use_id tool-use-id
                           :tool_name tool-name
                           :timestamp_call (format-time-string "%Y-%m-%dT%H:%M:%SZ")
                           :timestamp_result nil
                           :args_str args-str
                           :result_preview nil
                           :result_file nil
                           :error nil)))
      ;; Get or create session_tool_calls array
      (let ((calls (or (plist-get metadata :session_tool_calls) [])))
        (plist-put metadata :session_tool_calls (vconcat calls (vector tool-call))))

      ;; Write metadata immediately
      (let ((session-dir (plist-get session-data :directory)))
        (jf/gptel--write-metadata session-dir metadata)))))
#+end_src

** OLD: Record Session Tool Call Result (Deprecated)

#+begin_src emacs-lisp :tangle no
(defun jf/gptel--record-session-tool-call-result (session-id tool-name args result)
  "Update session-level tool call with result.
Finds matching tool call by TOOL-NAME and ARGS, updates with RESULT."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata)))
    (let* ((tool-calls (plist-get metadata :session_tool_calls))
           (args-str (prin1-to-string args))
           ;; Find matching tool call
           (tool-call (cl-find-if
                      (lambda (tc)
                        (and (equal (plist-get tc :tool_name) tool-name)
                             (equal (plist-get tc :args_str) args-str)
                             (null (plist-get tc :timestamp_result))))
                      (append tool-calls nil))))
      (when tool-call
        ;; Convert result to string
        (let ((result-str (cond
                           ((stringp result) result)
                           ((listp result) (format "%S" result))
                           (t (format "%s" result)))))
          ;; Decide storage strategy
          (if (< (length result-str) 1024)
              ;; Small result: store inline
              (progn
                (plist-put tool-call :result_preview
                          (jf/gptel--preview-string result-str 500))
                (plist-put tool-call :result_file nil))
            ;; Large result: save to file
            (let* ((session-dir (plist-get session-data :directory))
                   (results-dir (expand-file-name jf/gptel-session-trace-tool-results-dirname session-dir))
                   (tool-use-id (plist-get tool-call :tool_use_id))
                   (result-file (format "%s.txt" tool-use-id))
                   (result-path (expand-file-name result-file results-dir)))
              (make-directory results-dir t)
              (with-temp-file result-path
                (insert result-str))
              (plist-put tool-call :result_preview
                        (jf/gptel--preview-string result-str 200))
              (plist-put tool-call :result_file result-file)))

          ;; Update timestamp
          (plist-put tool-call :timestamp_result
                    (format-time-string "%Y-%m-%dT%H:%M:%SZ"))))

      ;; Write metadata immediately
      (let ((session-dir (plist-get session-data :directory)))
        (jf/gptel--write-metadata session-dir metadata)))))
#+end_src

** OLD: Record Session Tool Call Error (Deprecated)

#+begin_src emacs-lisp :tangle no
(defun jf/gptel--record-session-tool-call-error (session-id tool-name args error-msg)
  "Record session-level tool call error."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata)))
    (let* ((tool-calls (plist-get metadata :session_tool_calls))
           (args-str (prin1-to-string args))
           (tool-call (cl-find-if
                      (lambda (tc)
                        (and (equal (plist-get tc :tool_name) tool-name)
                             (equal (plist-get tc :args_str) args-str)
                             (null (plist-get tc :timestamp_result))))
                      (append tool-calls nil))))
      (when tool-call
        (plist-put tool-call :error error-msg)
        (plist-put tool-call :timestamp_result
                  (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
        (let ((session-dir (plist-get session-data :directory)))
          (jf/gptel--write-metadata session-dir metadata))))))
#+end_src

* Preview String

#+begin_src emacs-lisp
(defun jf/gptel--preview-string (obj &optional max-len)
  "Create preview string from OBJ (string, list, etc)."
  (let* ((max-len (or max-len 200))
         (str (cond
               ((stringp obj) obj)
               ((listp obj) (format "%S" obj))
               (t (format "%s" obj)))))
    (if (> (length str) max-len)
        (concat (substring str 0 max-len) "...")
      str)))
#+end_src

* Save Trace Message

#+begin_src emacs-lisp
(defun jf/gptel--save-trace-message (session-id trace-id message-type content &optional metadata)
  "Save a message to trace directory.
MESSAGE-TYPE is 'prompt', 'message', 'response', or 'result'.
CONTENT is the message text.
METADATA is optional plist with :timestamp, :tokens, :tool_calls, etc."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (session-dir (plist-get session-data :directory)))
    (let* ((trace-dir (expand-file-name (format "%s/%s" jf/gptel-session-traces-dirname trace-id) session-dir))
           (metadata-file (expand-file-name jf/gptel-session-trace-metadata-filename trace-dir))
           ;; Count existing message files to get next ID
           (message-files (when (file-directory-p trace-dir)
                           (directory-files trace-dir nil "^\\(message\\|response\\)-[0-9]+\\.txt$")))
           (next-id (if message-files (length message-files) 0))
           (file-name (pcase message-type
                       ('prompt "prompt.txt")
                       ('result "result.txt")
                       ('message (format "message-%d.txt" next-id))
                       ('response (format "response-%d.txt" next-id))))
           (file-path (expand-file-name file-name trace-dir)))

      ;; Create trace directory if needed
      (make-directory trace-dir t)

      ;; Save message content
      (with-temp-file file-path
        (insert content))

      ;; Update trace metadata
      (let* ((trace-metadata (if (file-exists-p metadata-file)
                                (with-temp-buffer
                                  (insert-file-contents metadata-file)
                                  (let ((json-object-type 'plist)
                                        (json-array-type 'vector)
                                        (json-key-type 'keyword))
                                    (json-read)))
                              ;; Initialize if doesn't exist
                              (list :trace_id trace-id
                                    :messages []
                                    :tool_calls []
                                    :total_tokens 0)))
             (messages (plist-get trace-metadata :messages))
             (new-message (list :id file-name
                               :file file-name
                               :timestamp (or (plist-get metadata :timestamp)
                                            (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
                               :tokens (or (plist-get metadata :tokens) 0))))
        ;; Add optional fields
        (when (plist-get metadata :tool_calls)
          (plist-put new-message :tool_calls (plist-get metadata :tool_calls)))

        ;; Append to messages array
        (plist-put trace-metadata :messages
                   (vconcat messages (vector new-message)))

        ;; Update total tokens
        (plist-put trace-metadata :total_tokens
                   (+ (or (plist-get trace-metadata :total_tokens) 0)
                      (or (plist-get metadata :tokens) 0)))

        ;; Write updated metadata
        (with-temp-file metadata-file
          (let ((json-encoding-pretty-print t))
            (insert (json-encode trace-metadata))))))))
#+end_src
