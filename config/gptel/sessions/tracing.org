#+title: GPTEL Agent Tracing
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle tracing.el
#+auto_tangle: y

* Introduction

Agent tracing captures the complete execution flow of subagents, including:
- Task delegation (which agent was called, with what prompt)
- Streaming LLM responses (real-time capture of response chunks)
- Tool calls (which tools were invoked with what arguments)
- Results (what the agent returned)
- Timing and hierarchy (parent/child relationships, depth)

All traces are stored both in the global registry (for active session access)
and on disk (for persistence and later analysis).

This module provides:
- Trace creation and completion
- Tool call recording
- Message storage (prompts, responses, results)
- Trace hierarchy management

* Lexical Binding

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(require 'cl-lib)
#+end_src

* Create Trace

#+begin_src emacs-lisp
(defun jf/gptel--create-trace (session-id agent-type description prompt &optional parent-trace-id)
  "Create new agent trace entry in session.
Looks up session from registry, updates metadata, returns trace-id."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata)))
    (let* ((trace-counter (plist-get session-data :trace-counter))
           (trace-id (format "trace-%d" (cl-incf trace-counter)))
           (trace-stack (plist-get session-data :trace-stack))
           (depth (length trace-stack))
           (trace (list :trace_id trace-id
                       :agent_type agent-type
                       :description description
                       :prompt_preview (substring prompt 0 (min 200 (length prompt)))
                       :timestamp_start (format-time-string "%Y-%m-%dT%H:%M:%SZ")
                       :timestamp_end nil
                       :status "running"
                       :parent_trace_id parent-trace-id
                       :depth depth
                       :tool_calls []
                       :associated_nodes nil)))
      ;; Update registry: increment counter, push to stack
      (jf/gptel--update-session-data session-id :trace-counter trace-counter)
      (jf/gptel--update-session-data session-id :trace-stack (cons trace-id trace-stack))

      ;; Add to metadata's agent_traces array
      (let ((traces (plist-get metadata :agent_traces)))
        (plist-put metadata :agent_traces
                   (vconcat traces (vector trace))))

      ;; Write metadata to disk (incremental)
      (let ((session-dir (plist-get session-data :directory)))
        (jf/gptel--write-metadata session-dir metadata))

      trace-id)))
#+end_src

* Complete Trace

#+begin_src emacs-lisp
(defun jf/gptel--complete-trace (session-id trace-id status)
  "Mark trace as completed, pop from stack."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata))
              (traces (plist-get metadata :agent_traces)))
    ;; Find and update the trace
    (let ((trace (cl-find-if (lambda (tr)
                              (equal (plist-get tr :trace_id) trace-id))
                            (append traces nil))))
      (when trace
        (plist-put trace :timestamp_end (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
        (plist-put trace :status status)

        ;; Pop from trace stack in registry
        (let ((trace-stack (plist-get session-data :trace-stack)))
          (jf/gptel--update-session-data session-id :trace-stack
                                        (remove trace-id trace-stack)))

        ;; Write metadata to disk
        (let ((session-dir (plist-get session-data :directory)))
          (jf/gptel--write-metadata session-dir metadata))))))
#+end_src

* Current Trace ID

#+begin_src emacs-lisp
(defun jf/gptel--current-trace-id (session-id)
  "Get current trace ID (top of stack) from session."
  (when-let ((session-data (jf/gptel--get-session-data session-id)))
    (car (plist-get session-data :trace-stack))))
#+end_src

* Tool Call Recording

** Generate Tool Use ID

#+begin_src emacs-lisp
(defun jf/gptel--generate-tool-use-id (tool-name)
  "Generate a tool use ID in Claude API format.
Returns format: toolu_TIMESTAMP_RANDOM."
  (format "toolu_%s_%04x"
          (format-time-string "%Y%m%d%H%M%S")
          (random 65536)))
#+end_src

** Record Initial Tool Call

#+begin_src emacs-lisp
(defun jf/gptel--record-tool-call-initial (session-id trace-id tool args)
  "Record initial tool call (before execution).
TOOL is the tool object, ARGS is the arguments plist.
Captures tool name, ID, arguments, and timestamp."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata))
              (traces (plist-get metadata :agent_traces)))
    ;; Find the trace
    (let ((trace (cl-find-if (lambda (tr)
                              (equal (plist-get tr :trace_id) trace-id))
                            (append traces nil))))
      (when trace
        (let* ((tool-name (gptel-tool-name tool))
               (tool-use-id (jf/gptel--generate-tool-use-id tool-name))
               (args-json (json-encode args))
               (tool-call (list :tool_use_id tool-use-id
                               :tool_name tool-name
                               :timestamp_call (format-time-string "%Y-%m-%dT%H:%M:%SZ")
                               :timestamp_result nil
                               :args_json args-json
                               :result_preview nil
                               :result_file nil
                               :error nil)))
          ;; Append to trace's tool_calls
          (let ((calls (plist-get trace :tool_calls)))
            (plist-put trace :tool_calls (vconcat calls (vector tool-call)))))

        ;; Write metadata immediately
        (let ((session-dir (plist-get session-data :directory)))
          (jf/gptel--write-metadata session-dir metadata))))))
#+end_src

** Record Tool Call Result

#+begin_src emacs-lisp
(defun jf/gptel--record-tool-call-result (session-id trace-id tool-name args result)
  "Update tool call with result after execution.
Finds matching tool call by TOOL-NAME and ARGS, updates with RESULT."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata))
              (traces (plist-get metadata :agent_traces)))
    (let ((trace (cl-find-if (lambda (tr)
                              (equal (plist-get tr :trace_id) trace-id))
                            (append traces nil))))
      (when trace
        (let* ((tool-calls (plist-get trace :tool_calls))
               (args-json (json-encode args))
               ;; Find matching tool call (by name, args, and null result)
               (tool-call (cl-find-if
                          (lambda (tc)
                            (and (equal (plist-get tc :tool_name) tool-name)
                                 (equal (plist-get tc :args_json) args-json)
                                 (null (plist-get tc :timestamp_result))))
                          (append tool-calls nil))))
          (when tool-call
            ;; Convert result to string
            (let ((result-str (cond
                               ((stringp result) result)
                               ((listp result) (format "%S" result))
                               (t (format "%s" result)))))
              ;; Decide storage strategy based on result size
              (if (< (length result-str) 1024)
                  ;; Small result: store inline
                  (progn
                    (plist-put tool-call :result_preview
                              (jf/gptel--preview-string result-str 500))
                    (plist-put tool-call :result_file nil))
                ;; Large result: save to file
                (let* ((session-dir (plist-get session-data :directory))
                       (trace-dir (expand-file-name
                                  (format "traces/%s" trace-id) session-dir))
                       (results-dir (expand-file-name "tool-results" trace-dir))
                       (tool-use-id (plist-get tool-call :tool_use_id))
                       (result-file (format "%s.txt" tool-use-id))
                       (result-path (expand-file-name result-file results-dir)))
                  ;; Create directory
                  (make-directory results-dir t)
                  ;; Save result to file
                  (with-temp-file result-path
                    (insert result-str))
                  ;; Update metadata
                  (plist-put tool-call :result_preview
                            (jf/gptel--preview-string result-str 200))
                  (plist-put tool-call :result_file result-file)))

              ;; Update timestamp
              (plist-put tool-call :timestamp_result
                        (format-time-string "%Y-%m-%dT%H:%M:%SZ"))))

          ;; Write metadata immediately
          (let ((session-dir (plist-get session-data :directory)))
            (jf/gptel--write-metadata session-dir metadata)))))))
#+end_src

** Record Tool Call Error

#+begin_src emacs-lisp
(defun jf/gptel--record-tool-call-error (session-id trace-id tool-name args error-msg)
  "Record tool call error.
Finds matching tool call and marks it with ERROR-MSG."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (metadata (plist-get session-data :metadata))
              (traces (plist-get metadata :agent_traces)))
    (let ((trace (cl-find-if (lambda (tr)
                              (equal (plist-get tr :trace_id) trace-id))
                            (append traces nil))))
      (when trace
        (let* ((tool-calls (plist-get trace :tool_calls))
               (args-json (json-encode args))
               (tool-call (cl-find-if
                          (lambda (tc)
                            (and (equal (plist-get tc :tool_name) tool-name)
                                 (equal (plist-get tc :args_json) args-json)
                                 (null (plist-get tc :timestamp_result))))
                          (append tool-calls nil))))
          (when tool-call
            (plist-put tool-call :error error-msg)
            (plist-put tool-call :timestamp_result
                      (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
            (let ((session-dir (plist-get session-data :directory)))
              (jf/gptel--write-metadata session-dir metadata))))))))
#+end_src

* Preview String

#+begin_src emacs-lisp
(defun jf/gptel--preview-string (obj &optional max-len)
  "Create preview string from OBJ (string, list, etc)."
  (let* ((max-len (or max-len 200))
         (str (cond
               ((stringp obj) obj)
               ((listp obj) (format "%S" obj))
               (t (format "%s" obj)))))
    (if (> (length str) max-len)
        (concat (substring str 0 max-len) "...")
      str)))
#+end_src

* Save Trace Message

#+begin_src emacs-lisp
(defun jf/gptel--save-trace-message (session-id trace-id message-type content &optional metadata)
  "Save a message to trace directory.
MESSAGE-TYPE is 'prompt', 'message', 'response', or 'result'.
CONTENT is the message text.
METADATA is optional plist with :timestamp, :tokens, :tool_calls, etc."
  (when-let* ((session-data (jf/gptel--get-session-data session-id))
              (session-dir (plist-get session-data :directory)))
    (let* ((trace-dir (expand-file-name (format "traces/%s" trace-id) session-dir))
           (metadata-file (expand-file-name "metadata.json" trace-dir))
           ;; Count existing message files to get next ID
           (message-files (when (file-directory-p trace-dir)
                           (directory-files trace-dir nil "^\\(message\\|response\\)-[0-9]+\\.txt$")))
           (next-id (if message-files (length message-files) 0))
           (file-name (pcase message-type
                       ('prompt "prompt.txt")
                       ('result "result.txt")
                       ('message (format "message-%d.txt" next-id))
                       ('response (format "response-%d.txt" next-id))))
           (file-path (expand-file-name file-name trace-dir)))

      ;; Create trace directory if needed
      (make-directory trace-dir t)

      ;; Save message content
      (with-temp-file file-path
        (insert content))

      ;; Update trace metadata
      (let* ((trace-metadata (if (file-exists-p metadata-file)
                                (with-temp-buffer
                                  (insert-file-contents metadata-file)
                                  (let ((json-object-type 'plist)
                                        (json-array-type 'vector)
                                        (json-key-type 'keyword))
                                    (json-read)))
                              ;; Initialize if doesn't exist
                              (list :trace_id trace-id
                                    :messages []
                                    :tool_calls []
                                    :total_tokens 0)))
             (messages (plist-get trace-metadata :messages))
             (new-message (list :id file-name
                               :file file-name
                               :timestamp (or (plist-get metadata :timestamp)
                                            (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
                               :tokens (or (plist-get metadata :tokens) 0))))
        ;; Add optional fields
        (when (plist-get metadata :tool_calls)
          (plist-put new-message :tool_calls (plist-get metadata :tool_calls)))

        ;; Append to messages array
        (plist-put trace-metadata :messages
                   (vconcat messages (vector new-message)))

        ;; Update total tokens
        (plist-put trace-metadata :total_tokens
                   (+ (or (plist-get trace-metadata :total_tokens) 0)
                      (or (plist-get metadata :tokens) 0)))

        ;; Write updated metadata
        (with-temp-file metadata-file
          (let ((json-encoding-pretty-print t))
            (insert (json-encode trace-metadata))))))))
#+end_src
