#+title: GPTEL Session Hooks
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle hooks.el
#+auto_tangle: y

* Introduction

Hooks and advice functions for gptel session auto-save and persistence.
Integrates with gptel's existing save/restore mechanism and adds real-time auto-save.

* Lexical Binding

#+begin_src emacs-lisp
;;; hooks.el --- GPTEL Session Hooks -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;;; Commentary:

;; Hooks and advice for gptel session management.
;; Provides auto-save, tool logging, and system prompt tracking.

;;; Code:

(require 'cl-lib)
(require 'gptel-session-constants)
(require 'gptel-session-logging)
(require 'gptel-session-filesystem)
(require 'gptel-session-registry)
(require 'gptel-session-metadata)
(require 'gptel-session-tracing)
#+end_src

* Auto-Save After Response

Save session buffers after each LLM response using gptel's post-response hook.

#+begin_src emacs-lisp
(defun jf/gptel--post-response-save (start end)
  "Save session buffer after response insertion.
START and END are the response positions (provided by gptel-post-response-functions)."
  (when (and jf/gptel--session-dir
             (buffer-modified-p))
    (save-buffer)
    (jf/gptel--log 'debug "Auto-saved session after response: %s"
                  jf/gptel--session-id)))

;; Add to gptel's post-response hook
(add-hook 'gptel-post-response-functions #'jf/gptel--post-response-save)
#+end_src

* Auto-Save Timer (Fallback)

Fallback auto-save using idle timer for changes outside request/response cycle.

#+begin_src emacs-lisp
(defvar-local jf/gptel--autosave-timer nil
  "Buffer-local timer for auto-saving session.")

(defun jf/gptel--schedule-autosave ()
  "Schedule auto-save for current buffer after idle time.
Only schedules if jf/gptel-autosave-enabled is non-nil."
  (when (and jf/gptel-autosave-enabled
             jf/gptel--session-dir
             (> jf/gptel-autosave-idle-time 0))
    ;; Cancel existing timer if present
    (when jf/gptel--autosave-timer
      (cancel-timer jf/gptel--autosave-timer))

    ;; Schedule new timer
    (setq jf/gptel--autosave-timer
          (run-with-idle-timer
           jf/gptel-autosave-idle-time
           nil
           (lambda (buffer)
             (when (buffer-live-p buffer)
               (with-current-buffer buffer
                 (when (and jf/gptel--session-dir
                           (buffer-modified-p))
                   (save-buffer)
                   (jf/gptel--log 'debug "Auto-saved session: %s"
                                 jf/gptel--session-id)))))
           (current-buffer)))))

(defun jf/gptel--enable-autosave ()
  "Enable auto-save for current buffer.
Adds after-change-functions hook to schedule saves."
  (add-hook 'after-change-functions
           (lambda (&rest _) (jf/gptel--schedule-autosave))
           nil t))

(defun jf/gptel--disable-autosave ()
  "Disable auto-save for current buffer."
  (when jf/gptel--autosave-timer
    (cancel-timer jf/gptel--autosave-timer)
    (setq jf/gptel--autosave-timer nil)))
#+end_src

* Tool Call Advice

Advice gptel FSM transition to log completed tool calls.

The approach: Hook `gptel--fsm-transition` and when transitioning FROM tool
state (when `:tool-success` is set), log all tool calls with results.

This works because:
1. Tools execute and populate results via async callbacks
2. When all tools complete, `:tool-success` flag is set
3. FSM transitions from TOOL â†’ WAIT
4. Our advice captures tools at this point when ALL results are available

#+begin_src emacs-lisp
(defun jf/gptel--advice-log-fsm-transition (fsm &optional new-state)
  "Advice for gptel--fsm-transition to log tool calls.
FSM is the finite state machine, NEW-STATE is optional forced state.
When transitioning from TOOL state with completed tools, logs all tool results.
Checks FSM info for :jf/session-dir first (for subagents), then buffer-local variable."
  (let* ((info (gptel-fsm-info fsm))
         ;; Check FSM info for session dir (subagents), fall back to buffer-local (parent)
         (fsm-session-dir (plist-get info :jf/session-dir))
         (session-dir (or fsm-session-dir
                         jf/gptel--session-dir)))
    (jf/gptel--log 'debug "FSM info has :jf/session-dir = %s, buffer-local = %s, using = %s"
                  fsm-session-dir jf/gptel--session-dir session-dir)
    (when session-dir
      (let* ((current-state (gptel-fsm-state fsm))
             (tool-success (plist-get info :tool-success))
             (tool-use (plist-get info :tool-use)))

        ;; Log when leaving TOOL state with successful tool execution
        (when (and (eq current-state 'TOOL)
                   tool-success
                   tool-use)
          (jf/gptel--log 'debug "FSM transitioning from TOOL state, logging %d tools to %s"
                        (length tool-use) session-dir)
          ;; Log each completed tool call
          (dolist (tool-call tool-use)
            (when-let* ((result (plist-get tool-call :result))
                        (tool-name (plist-get tool-call :name))
                        (args (plist-get tool-call :args)))
              (jf/gptel--log 'info "Logging completed tool: %s" tool-name)
              ;; Get subagent link if this is an Agent tool
              (let ((subagent-link
                     (when (and (fboundp 'jf/gptel--get-subagent-link-for-tool)
                               (equal tool-name "Agent"))
                       (jf/gptel--get-subagent-link-for-tool tool-name tool-call))))
                (jf/gptel--log-tool-call tool-name args result session-dir
                                        nil subagent-link)))))))))

;; Add advice to FSM transition (when gptel is loaded)
(with-eval-after-load 'gptel
  (when (fboundp 'gptel--fsm-transition)
    (advice-add 'gptel--fsm-transition :before
               #'jf/gptel--advice-log-fsm-transition)
    (jf/gptel--log 'info "Installed FSM transition tool logging advice")))
#+end_src

* System Prompt Change Advice

Track system prompt modifications.

#+begin_src emacs-lisp
(defvar jf/gptel--last-system-prompt nil
  "Buffer-local cache of last system prompt for change detection.")
(make-variable-buffer-local 'jf/gptel--last-system-prompt)

(defun jf/gptel--advice-track-system-prompt (&rest _args)
  "Advice function to track system prompt changes.
Should be added as :after advice to gptel--set-with-scope."
  (when (and jf/gptel--session-dir
             (boundp 'gptel--system-message))
    (let ((new-prompt gptel--system-message))
      (unless (equal new-prompt jf/gptel--last-system-prompt)
        (jf/gptel--log-system-prompt-change
         jf/gptel--last-system-prompt
         new-prompt
         jf/gptel--session-dir)
        (setq jf/gptel--last-system-prompt new-prompt)))))

;; Add advice when gptel is loaded
(with-eval-after-load 'gptel
  (when (fboundp 'gptel--set-with-scope)
    (advice-add 'gptel--set-with-scope :after
               #'jf/gptel--advice-track-system-prompt)))
#+end_src

* Session Buffer Initialization

Hook into gptel-mode to initialize session tracking.

#+begin_src emacs-lisp
(defun jf/gptel--maybe-init-session-buffer ()
  "Initialize session tracking for current buffer if session variables are set.
This is called when gptel-mode is enabled."
  (when (and jf/gptel--session-id
             jf/gptel--session-dir)
    ;; Update registry with this buffer
    (jf/gptel--update-session-buffer jf/gptel--session-id (current-buffer))

    ;; Enable auto-save if configured
    (when jf/gptel-autosave-enabled
      (jf/gptel--enable-autosave))

    ;; Initialize system prompt tracking
    (when (boundp 'gptel--system-message)
      (setq jf/gptel--last-system-prompt gptel--system-message))

    (jf/gptel--log 'info "Initialized session buffer: %s" jf/gptel--session-id)))

;; Add to gptel-mode-hook
(add-hook 'gptel-mode-hook #'jf/gptel--maybe-init-session-buffer)
#+end_src

* Session Cleanup

Clean up when buffers are killed.

#+begin_src emacs-lisp
(defun jf/gptel--cleanup-session-buffer ()
  "Clean up session tracking when buffer is killed."
  (when jf/gptel--session-id
    ;; Cancel autosave timer
    (jf/gptel--disable-autosave)

    ;; Save final state
    (when (and jf/gptel--session-dir (buffer-modified-p))
      (save-buffer))

    ;; Update registry to clear buffer reference
    (when-let ((session (jf/gptel-session-find jf/gptel--session-id)))
      (plist-put session :buffer nil)
      (puthash jf/gptel--session-id session jf/gptel--session-registry))

    (jf/gptel--log 'info "Cleaned up session buffer: %s" jf/gptel--session-id)))

;; Add to kill-buffer-hook
(add-hook 'kill-buffer-hook #'jf/gptel--cleanup-session-buffer)
#+end_src

* Provide Feature

#+begin_src emacs-lisp
(provide 'gptel-session-hooks)
;;; hooks.el ends here
#+end_src
