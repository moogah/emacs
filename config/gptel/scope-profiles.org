#+title: GPTEL Scope Profiles
#+property: header-args:emacs-lisp :tangle scope-profiles.el
#+auto_tangle: y

* Introduction

Scope profile templates for gptel sessions. Profiles define default permissions
(file paths, org-roam patterns, shell commands, bash tools) that can be associated with
presets. When a session starts, the profile is resolved, variables are expanded,
and the result is written as =scope.yml= into the session directory.

Profile templates live as YAML files in =config/gptel/scope-profiles/=.

** Scope Profile Sections

Profiles can include the following configuration sections:

1. *paths* - File access control (read, write, deny patterns)
2. *org-roam-patterns* - Org-roam node filtering (subdirectory, tags, node-ids)
3. *shell-commands* - Legacy shell command allow/deny lists (deprecated in favor of bash_tools)
4. *bash_tools* - Category-based bash command execution with directory scoping

** Bash Tools Configuration

The =bash_tools= section provides fine-grained control over shell command execution:

*** Structure

#+begin_example yaml
bash_tools:
  categories:
    read_only:
      commands: ["ls", "grep", "find", "cat", "head", "tail", "wc", "git log", "git diff"]
    safe_write:
      commands: ["mkdir", "touch", "echo", "git add", "git commit"]
    dangerous:
      commands: []
  deny:
    - "rm"
    - "mv"
    - "sudo"
    - "chmod"
#+end_example

*** Categories

Commands are grouped by operational impact:

- *read_only* - Commands that only read data (require paths.read OR paths.write)
- *safe_write* - Commands that create/modify safely (require paths.write)
- *dangerous* - Commands requiring explicit user approval (empty by default)
- *deny* - Commands never allowed, even with scope expansion

*** Directory Scope Binding

Each category binds to path scope requirements:

| Category   | Requires paths.read | Requires paths.write | Notes                      |
|------------|---------------------|----------------------|----------------------------|
| read_only  | ✓ (or write)        |                      | Write scope includes read  |
| safe_write |                     | ✓                    | More restrictive           |
| dangerous  | ✓                   | ✓                    | Plus explicit approval     |
| deny       | ✗                   | ✗                    | Never allowed              |

*** Variable Expansion

Like other scope sections, bash_tools configuration supports variable expansion:

#+begin_example yaml
bash_tools:
  categories:
    read_only:
      commands: ["ls", "cat", "grep"]
  deny:
    - "rm"
    - "${dangerous_command}"  # Variables expanded during session creation
#+end_example

*** Example: Complete Profile with Bash Tools

Here's a complete profile demonstrating all sections:

#+begin_example yaml
# File: config/gptel/scope-profiles/coding.yml
paths:
  read: ["/**"]
  write: ["${project_root}/**"]
  deny: ["**/.git/**", "**/runtime/**", "**/.env"]

org_roam_patterns:
  subdirectory: ["gptel/**"]
  tags: ["gptel"]
  node_ids: ["*"]

shell_commands:
  allow: ["ls", "find", "grep", "git"]
  deny: ["rm -rf", "sudo"]

bash_tools:
  categories:
    read_only:
      commands:
        - "ls"
        - "cat"
        - "grep"
        - "find"
        - "git log"
        - "git show"
        - "git diff"
        - "git status"
        - "pwd"
    safe_write:
      commands:
        - "mkdir"
        - "touch"
        - "git add"
        - "git commit"
    dangerous:
      commands: []
  deny:
    - "rm"
    - "rmdir"
    - "mv"
    - "cp"
    - "chmod"
    - "sudo"
#+end_example

See =config/gptel/tools/scope-shell-tools.org= for complete documentation on the =run_bash_command= tool.

* Lexical Binding

#+begin_src emacs-lisp
;;; scope-profiles.el --- GPTEL Scope Profiles -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;;; Commentary:

;; Scope profile templates for gptel sessions.
;; Loads YAML profile templates, resolves them for presets,
;; expands variables, and writes scope.yml into session directories.

;;; Code:

(require 'cl-lib)
(require 'yaml)
(require 'gptel-session-constants)
(require 'gptel-session-logging)
#+end_src

* Key Normalization Helpers

Convert between snake_case (YAML on-disk format) and kebab-case (Elisp plist format).

** Snake Case to Kebab Case

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--snake-to-kebab (key)
  "Convert KEY from snake_case keyword to kebab-case keyword.
E.g., :org_roam_patterns becomes :org-roam-patterns."
  (intern (replace-regexp-in-string "_" "-" (symbol-name key))))
#+end_src

** Kebab Case to Snake Case

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--kebab-to-snake (key)
  "Convert KEY from kebab-case keyword to snake_case keyword.
E.g., :org-roam-patterns becomes :org_roam_patterns."
  (intern (replace-regexp-in-string "-" "_" (symbol-name key))))
#+end_src

** Normalize Parsed YAML Plist

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--normalize-keys (parsed)
  "Normalize snake_case keys in PARSED plist to kebab-case.
Handles top-level keys only; nested structures (sub-plists) are
also normalized recursively."
  (let ((result nil))
    (cl-loop for (key val) on parsed by #'cddr
             do (let ((new-key (jf/gptel-scope-profile--snake-to-kebab key))
                      (new-val (if (and (listp val) (keywordp (car-safe val)))
                                   (jf/gptel-scope-profile--normalize-keys val)
                                 val)))
                  (setq result (plist-put result new-key new-val))))
    result))
#+end_src

* Load Profile from YAML File

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--load (profile-name)
  "Load scope profile PROFILE-NAME from the profiles directory.
PROFILE-NAME is the base name without .yml extension.
Returns a plist with :paths, :org-roam-patterns, :shell-commands, :bash-tools.
Returns nil and logs a warning if the file is missing or cannot be parsed."
  (let ((profile-file (expand-file-name
                       (concat profile-name ".yml")
                       jf/gptel--scope-profiles-directory)))
    (if (not (file-exists-p profile-file))
        (progn
          (jf/gptel--log 'warn "Scope profile file not found: %s" profile-file)
          nil)
      (condition-case err
          (with-temp-buffer
            (insert-file-contents profile-file)
            (let* ((parsed (yaml-parse-string (buffer-string) :object-type 'plist))
                   (normalized (jf/gptel-scope-profile--normalize-keys parsed)))
              (jf/gptel--log 'debug "Loaded scope profile: %s" profile-name)
              normalized))
        (error
         (jf/gptel--log 'warn "Failed to parse scope profile %s: %s"
                       profile-name (error-message-string err))
         nil)))))
#+end_src

* Resolve Profile for Preset

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--resolve (preset-name)
  "Resolve scope profile for PRESET-NAME.
Looks up `jf/gptel-preset--scope-defaults' for the preset.
Priority:
  1. Named profile via :scope-profile key -> load from file
  2. Inline scope defaults (plist with :paths etc.) -> return directly
  3. No scope defaults -> return nil

Returns a scope plist or nil."
  (let ((scope-config (alist-get preset-name jf/gptel-preset--scope-defaults)))
    (cond
     ;; No scope configuration for this preset
     ((null scope-config)
      (jf/gptel--log 'debug "No scope defaults for preset: %s" preset-name)
      nil)

     ;; Named profile reference
     ((plist-get scope-config :scope-profile)
      (let ((profile-name (plist-get scope-config :scope-profile)))
        (jf/gptel--log 'debug "Resolving named scope profile '%s' for preset: %s"
                      profile-name preset-name)
        (let ((loaded (jf/gptel-scope-profile--load profile-name)))
          (unless loaded
            (jf/gptel--log 'warn "Profile file missing for preset %s, profile: %s"
                          preset-name profile-name))
          loaded)))

     ;; Inline scope defaults (the plist itself is the scope config)
     (t
      (jf/gptel--log 'debug "Using inline scope defaults for preset: %s" preset-name)
      scope-config))))
#+end_src

* Variable Expansion

** Expand Variables in a String

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--expand-string (str project-root)
  "Expand ${project_root} in STR with PROJECT-ROOT.
If PROJECT-ROOT is nil and STR contains ${project_root}, return nil
to signal the pattern should be removed."
  (if (not (stringp str))
      str
    (if (string-match-p "\\${project_root}" str)
        (if project-root
            (replace-regexp-in-string "\\${project_root}" project-root str t t)
          nil)
      str)))
#+end_src

** Expand Variables in a List

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--expand-list (lst project-root)
  "Expand variables in all strings in LST.
Remove entries where expansion returns nil (unresolvable variables).
Returns a new list."
  (if (not (listp lst))
      lst
    (cl-remove nil (mapcar (lambda (item)
                             (jf/gptel-scope-profile--expand-string item project-root))
                           lst))))
#+end_src

** Expand Variables in Scope Plist

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--expand-variables (scope-plist project-root)
  "Expand ${project_root} in all string values within SCOPE-PLIST.
If PROJECT-ROOT is nil, patterns containing ${project_root} are removed
and a warning is logged.
Returns a new plist with expanded values."
  (when (and (null project-root)
             scope-plist)
    (jf/gptel--log 'warn "No project-root provided; patterns with ${project_root} will be removed"))
  (let ((result nil))
    (cl-loop for (key val) on scope-plist by #'cddr
             do (let ((expanded
                       (cond
                        ;; Nested plist (e.g., :paths has :read, :write, :deny)
                        ((and (listp val) (keywordp (car-safe val)))
                         (jf/gptel-scope-profile--expand-variables val project-root))
                        ;; List of strings (e.g., list of patterns)
                        ((and (listp val) (or (null val) (stringp (car-safe val))))
                         (jf/gptel-scope-profile--expand-list val project-root))
                        ;; Vector (yaml arrays sometimes parse as vectors)
                        ((vectorp val)
                         (jf/gptel-scope-profile--expand-list (append val nil) project-root))
                        ;; Single string
                        ((stringp val)
                         (or (jf/gptel-scope-profile--expand-string val project-root) ""))
                        ;; Anything else, pass through
                        (t val))))
                  (setq result (plist-put result key expanded))))
    result))
#+end_src

* Write Scope YAML

** Convert Plist to YAML String

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--plist-to-yaml (plist indent)
  "Convert PLIST to YAML string with INDENT level.
Converts kebab-case keys back to snake_case for on-disk format.
Handles nested plists and lists of strings."
  (let ((lines nil)
        (prefix (make-string (* indent 2) ?\s)))
    (cl-loop for (key val) on plist by #'cddr
             do (let ((yaml-key (substring
                                 (symbol-name
                                  (jf/gptel-scope-profile--kebab-to-snake key))
                                 1)))
                  (cond
                   ;; Nested plist
                   ((and (listp val) (keywordp (car-safe val)))
                    (push (format "%s%s:" prefix yaml-key) lines)
                    (push (jf/gptel-scope-profile--plist-to-yaml val (1+ indent)) lines))
                   ;; List of strings - inline YAML array
                   ((and (listp val) (or (null val) (stringp (car-safe val))))
                    (if (null val)
                        (push (format "%s%s: []" prefix yaml-key) lines)
                      (let ((items (mapconcat (lambda (s) (format "\"%s\"" s)) val ", ")))
                        (push (format "%s%s: [%s]" prefix yaml-key items) lines))))
                   ;; Single string
                   ((stringp val)
                    (push (format "%s%s: \"%s\"" prefix yaml-key val) lines))
                   ;; Nil
                   ((null val)
                    (push (format "%s%s: []" prefix yaml-key) lines))
                   ;; Anything else
                   (t
                    (push (format "%s%s: %s" prefix yaml-key val) lines)))))
    (string-join (nreverse lines) "\n")))
#+end_src

** Write Scope File

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--write-scope-yml (target-dir scope-plist)
  "Write SCOPE-PLIST as YAML to scope.yml in TARGET-DIR.
Uses `jf/gptel-session--scope-file' constant for the filename.
If SCOPE-PLIST is nil or empty, writes minimal YAML with empty sections."
  (let ((scope-file (expand-file-name jf/gptel-session--scope-file target-dir))
        (effective-plist (or scope-plist
                             (list :paths (list :read nil :write nil :deny nil)
                                   :org-roam-patterns (list :subdirectory nil :tags nil :node-ids nil)
                                   :shell-commands (list :allow nil :deny nil)
                                   :bash-tools (list :categories (list :read-only (list :commands nil)
                                                                       :safe-write (list :commands nil)
                                                                       :dangerous (list :commands nil))
                                                     :deny nil)))))
    (with-temp-file scope-file
      (insert (jf/gptel-scope-profile--plist-to-yaml effective-plist 0))
      (insert "\n"))
    (jf/gptel--log 'info "Wrote scope file: %s" scope-file)))
#+end_src

* High-Level Session Integration

#+begin_src emacs-lisp
(defun jf/gptel-scope-profile--create-for-session (preset-name target-dir &optional project-root worktree-paths)
  "Create scope.yml for a session in TARGET-DIR.
PRESET-NAME is used to resolve the scope profile.
PROJECT-ROOT is used for variable expansion.
WORKTREE-PATHS, if provided, bypasses profile resolution and writes
explicit paths directly (used by activities integration).

Flow:
  1. If WORKTREE-PATHS provided: write them directly as scope
  2. Otherwise: resolve profile for PRESET-NAME
  3. Expand variables with PROJECT-ROOT
  4. Write scope.yml to TARGET-DIR"
  (let ((scope-plist
         (cond
          ;; Explicit worktree paths bypass profile resolution
          (worktree-paths
           (jf/gptel--log 'info "Using explicit worktree paths for session scope")
           worktree-paths)

          ;; Resolve from preset's scope configuration
          (t
           (let ((resolved (jf/gptel-scope-profile--resolve preset-name)))
             (when resolved
               (jf/gptel-scope-profile--expand-variables resolved project-root)))))))
    (jf/gptel-scope-profile--write-scope-yml target-dir scope-plist)))
#+end_src

* Provide Feature

#+begin_src emacs-lisp
(provide 'gptel-scope-profiles)
;;; scope-profiles.el ends here
#+end_src
