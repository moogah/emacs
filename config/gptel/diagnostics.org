#+title: GPTEL Diagnostics
#+property: header-args:emacs-lisp :tangle diagnostics.el
#+auto_tangle: y

* Overview

This module provides diagnostic tools for debugging GPTEL session restoration issues,
particularly focusing on tool call serialization problems.

** Problem Statement

*Tool calls are not correctly restored when reopening a gptel session.*

After saving and closing a gptel session that contains tool calls, reopening the
session.md file and sending a new prompt results in an API error:

#+begin_example
Claude error: ((HTTP/2 400) invalid_request_error)
messages.1.content.0.tool_use.name: Input should be a valid string
#+end_example

The tool data is serialized as ="name": {}= and ="input": {}= instead of the actual
tool name and arguments, causing the API request to fail.

** Problem Context

When restoring a gptel session from =session.md=, tool calls fail to serialize correctly:
- Tool data shows as ="name": {}= and ="input": {}= instead of actual values
- The =gptel--bounds= variable changes after sending a prompt
- Initial bounds: =((tool (81 1347 "toolu_...")) ...)=
- After send: =((tool (38 1347 "toolu_...")) ...)= ← Position shifted
- When =gptel--parse-buffer= tries =(read (current-buffer))= at wrong position, it fails to read the tool-call sexp

** Root Cause Hypothesis

The tool property bound starts at the wrong buffer position (37 instead of 80),
causing =gptel--parse-buffer= to read from blank space instead of the tool call sexp.

** Findings

*** Root Cause: =gptel--inherit-stickiness= Interference

The bug is an *upstream gptel issue* in =gptel--inherit-stickiness= (gptel.el:698-706), which interferes
with property restoration.

*** How the Bug Happens

During =gptel--restore-props=, properties are restored in this order:

1. ✓ =add-text-properties(80 1346 tool)= - Sets tool property at position 80-1346
2. =add-text-properties(37 80 ignore)= - Attempts to set ignore property at 37-80
   - This triggers =after-change-functions= hook
   - =gptel--inherit-stickiness(37 80 43)= is called
   - It checks position 80 (END parameter) with =(get-text-property end 'gptel)=
   - Finds =(tool . "toolu_...")= already there from step 1!
   - Copies tool property to 37-80: =(add-text-properties beg end `(gptel ,val ...)=
   - ✗ *This overwrites the ignore property we just set!*
3. ✓ =add-text-properties(1346 1351 ignore)= - Sets ignore (no adjacent tool property)
4. ✓ =add-text-properties(1351 2903 response)= - Sets response
5. ✓ =add-text-properties(2917 2971 response)= - Sets response

Result: Position 37 has =tool= property instead of =ignore=, causing tool call parsing to fail.

*** Why It Happens

=gptel--inherit-stickiness= is designed to make text properties "sticky" during normal editing - when you
type adjacent to a response region, the new text inherits the same property. However, it should NOT be
active during restoration.

The function blindly copies whatever =gptel= property exists at position END to the entire BEG-END range,
without considering:
- Whether restoration is in progress
- Whether the adjacent property is compatible (tool vs ignore)
- Whether this overwrites an intentional property assignment

*** The Fix

*Upstream fix needed in gptel.el:* =gptel--restore-props= should temporarily remove
the =gptel--inherit-stickiness= hook during restoration to prevent interference.

**Original fix (TOO AGGRESSIVE):**
#+begin_src emacs-lisp
(defun gptel--restore-props (bounds-alist)
  "Restore text properties from BOUNDS-ALIST."
  (let ((modified (buffer-modified-p))
        (inhibit-modification-hooks t))  ; <-- Disables ALL modification hooks
    ;; ... existing restoration code ...
    (set-buffer-modified-p modified)))
#+end_src

**Problem:** =inhibit-modification-hooks t= disabled ALL modification hooks, which interfered
with buffer state management. After restoration and sending a new prompt, =gptel--bounds=
would lose all historical tool/ignore properties, keeping only the latest response.

**Improved fix (SURGICAL):**
#+begin_src emacs-lisp
(defun gptel--restore-props (bounds-alist)
  "Restore text properties from BOUNDS-ALIST."
  (let ((modified (buffer-modified-p))
        (had-inherit-hook (memq 'gptel--inherit-stickiness after-change-functions)))
    ;; Temporarily remove gptel--inherit-stickiness to prevent interference
    (remove-hook 'after-change-functions 'gptel--inherit-stickiness t)
    ;; ... existing restoration code ...
    ;; Restore the hook if it was present
    (when had-inherit-hook
      (add-hook 'after-change-functions 'gptel--inherit-stickiness nil t))
    (set-buffer-modified-p modified)))
#+end_src

**Why this is better:**
- Only disables the specific problematic hook
- Other modification hooks continue to work normally
- Text property machinery works correctly
- Buffer state is preserved across multiple save/restore cycles
- Hook is properly restored after property restoration completes

*Status:* Improved fix has been applied to local gptel installation at
=runtime/straight/repos/gptel/gptel.el:596-624=.

The change has been committed in the gptel repository with a detailed commit message
explaining the bug mechanism and fix. The patch will persist until gptel is rebuilt
or updated via straight.el.

To verify the fix is working:
1. Copy an uncorrupted session: =cp -r test-20260126142209 test-verify-fix=
2. Restart Emacs to load patched gptel
3. Open session.md and send a prompt
4. Check Local Variables show correct bounds: =(tool (80 1346 ...)) (ignore (37 80) ...)=
5. Diagnostic logs should show only 5 =add-text-properties= calls, not 6

*** Diagnostic Evidence

Full backtrace from test-restore-2 session shows:

#+begin_example
145:  add-text-properties(37 80 (gptel ignore))           ; gptel--restore-props call
144:  apply(#<subr add-text-properties> (37 80 (gptel ignore)))
143:  #<subr add-text-properties>(37 80 (gptel ignore) nil)
142:  gptel--inherit-stickiness(37 80 43)                 ; after-change-functions triggered
141:  add-text-properties(37 80 (gptel (tool . "toolu_..."))) ; overwrites ignore!
#+end_example

The backtrace confirms =gptel--inherit-stickiness= is called via =after-change-functions= and
overwrites the property being restored.

** Testing Methodology

To test session restoration without side effects, we copy an existing session directory to a new location before opening it:

#+begin_example
cp -r ~/.gptel/sessions/test-20260126142209 ~/.gptel/sessions/test-restore-N
#+end_example

This allows:
- Opening the copied session.md multiple times without corrupting the original
- Testing restoration behavior in isolation
- Comparing saved bounds vs restored bounds

** Test Session Details

Session =test-20260126142209= used for debugging has these characteristics:

- Tool call: =read_file= with filepath "~/Brewfile"
- Tool ID: ="toolu_01BUV8b8HrXnk2tVUKdZoBLj"=
- Saved bounds structure:
  #+begin_src elisp
  ((tool (80 1346 "toolu_01BUV8b8HrXnk2tVUKdZoBLj"))
   (ignore (37 80) (1346 1351))
   (response (1351 2903) (2917 2971)))
  #+end_src

- Position 37: Start of markdown code fence =``` tool=
- Position 80: Start of tool-call sexp =(:name "read_file" ...)=
- Position 1346: End of tool result
- Position 1351: End of closing code fence

The bug manifested as position 37 getting the =tool= property instead of =ignore= after restoration.

* Diagnostic Variables

#+begin_src emacs-lisp
(defvar jf/gptel--bounds-history nil
  "History of gptel--bounds changes for debugging.")

(defvar jf/gptel--parse-trace nil
  "Trace of tool parsing attempts.")

(defvar jf/gptel--diagnostic-file nil
  "Current diagnostic log file path. Auto-set to session dir or fallback.")

(defvar jf/gptel--diagnostic-fallback-file
  (expand-file-name "~/.gptel-diagnostics.log")
  "Fallback diagnostic file when not in a session.")
#+end_src

* Auto-Write Diagnostic Data

Automatically write diagnostic data to a file after each event.

#+begin_src emacs-lisp
(defun jf/gptel--get-diagnostic-file ()
  "Get the current diagnostic file path.
Uses session directory if in a gptel session, otherwise fallback."
  (or jf/gptel--diagnostic-file
      (setq jf/gptel--diagnostic-file
            (if (and (boundp 'jf/gptel--current-session-id)
                     jf/gptel--current-session-id)
                ;; We're in a session - write to session directory
                (expand-file-name "diagnostics.log"
                                 (expand-file-name
                                  jf/gptel--current-session-id
                                  jf/gptel-session-root-dir))
              ;; Not in a session - use fallback
              jf/gptel--diagnostic-fallback-file))))

(defun jf/gptel--write-diagnostic-entry (entry)
  "Write diagnostic ENTRY to the auto-log file immediately."
  (let ((log-file (jf/gptel--get-diagnostic-file))
        (timestamp (format-time-string "%Y-%m-%d %H:%M:%S.%3N")))
    (with-temp-buffer
      (insert (format "\n=== %s | %s ===\n"
                     timestamp
                     (plist-get entry :phase)))
      (insert (format "Buffer: %s\n" (plist-get entry :buffer)))
      (insert (format "Bounds: %S\n" (plist-get entry :bounds)))

      ;; If tool parses were captured, show them
      (when-let ((tool-parses (plist-get entry :tool-parses)))
        (insert "\nTool Parse Results:\n")
        (dolist (parse tool-parses)
          (if (plist-get parse :success)
              (insert (format "  ✓ Position %d: %s\n"
                             (plist-get parse :position)
                             (plist-get parse :name)))
            (insert (format "  ✗ Position %d: ERROR - %s\n"
                           (plist-get parse :position)
                           (plist-get parse :error))))))

      (insert "\n")

      ;; Append to file
      (append-to-file (point-min) (point-max) log-file))))

(defun jf/gptel--write-parse-entry (entry)
  "Write parse trace ENTRY to the auto-log file immediately."
  (let ((log-file (jf/gptel--get-diagnostic-file))
        (timestamp (format-time-string "%Y-%m-%d %H:%M:%S.%3N")))
    (with-temp-buffer
      (insert (format "\n=== %s | PARSE-BUFFER ===\n" timestamp))
      (insert (format "Buffer: %s\n" (plist-get entry :buffer)))
      (insert (format "API results: %d\n" (plist-get entry :num-results)))

      ;; Show tool scans
      (when-let ((tool-scans (plist-get entry :tool-scans)))
        (insert (format "Tool positions found: %d\n\n" (length tool-scans)))
        (dolist (scan tool-scans)
          (if (plist-get scan :success)
              (insert (format "  ✓ Position %d (line %d): %s\n"
                             (plist-get scan :position)
                             (plist-get scan :line)
                             (plist-get scan :name)))
            (insert (format "  ✗ Position %d (line %d): ERROR - %s\n"
                           (plist-get scan :position)
                           (plist-get scan :line)
                           (plist-get scan :error))))))

      (insert "\n")

      ;; Append to file
      (append-to-file (point-min) (point-max) log-file))))
#+end_src

* Diagnostic 1: Track Bounds Lifecycle

Monitor =gptel--bounds= variable at each critical transition point.

#+begin_src emacs-lisp
(defun jf/gptel--record-bounds (phase &optional extra-info)
  "Record current gptel--bounds value with PHASE label.
EXTRA-INFO can provide additional context about the recording.
Also captures what's actually at tool positions and what would be parsed."
  (when (boundp 'gptel--bounds)
    (let* ((timestamp (format-time-string "%H:%M:%S.%3N"))
           (bounds-value (if (local-variable-p 'gptel--bounds)
                            gptel--bounds
                          'not-buffer-local))
           (tool-parses nil)
           (entry (list :timestamp timestamp
                       :phase phase
                       :bounds bounds-value
                       :buffer (buffer-name)
                       :extra extra-info)))

      ;; For each tool bound, capture what would be parsed
      (when (and (listp bounds-value)
                 (not (eq bounds-value 'not-buffer-local)))
        (when-let ((tool-bounds (alist-get 'tool bounds-value)))
          (dolist (bound tool-bounds)
            (let* ((beg (nth 0 bound))
                   (end (nth 1 bound))
                   (id (nth 2 bound))
                   (parse-result nil))
              (save-excursion
                (goto-char beg)
                (setq parse-result
                      (condition-case err
                          (let* ((tool-call (read (current-buffer)))
                                 (name (plist-get tool-call :name))
                                 (args (plist-get tool-call :args)))
                            (list :success t
                                  :id id
                                  :position beg
                                  :name name
                                  :args args
                                  :full-sexp tool-call))
                        (error
                         (list :success nil
                               :id id
                               :position beg
                               :error (error-message-string err)
                               :buffer-content (buffer-substring-no-properties
                                               beg (min end (+ beg 100))))))))
              (push parse-result tool-parses)))))

      (when tool-parses
        (plist-put entry :tool-parses (nreverse tool-parses)))

      (push entry jf/gptel--bounds-history)

      ;; Auto-write to diagnostic file
      (jf/gptel--write-diagnostic-entry entry)

      (message "[BOUNDS] %s: %s (tools: %d)" phase bounds-value (length tool-parses)))))
#+end_src

* Diagnostic 2: Buffer Content at Critical Positions

Examine what's actually at the positions specified in bounds.

#+begin_src emacs-lisp
(defun jf/gptel--inspect-bounds-positions ()
  "Show buffer content at positions specified in gptel--bounds."
  (interactive)
  (unless (and (boundp 'gptel--bounds) gptel--bounds)
    (user-error "No gptel--bounds in current buffer"))

  (with-output-to-temp-buffer "*GPTEL Bounds Inspection*"
    (princ (format "Buffer: %s\n" (buffer-name)))
    (princ (format "gptel--bounds: %S\n\n" gptel--bounds))

    (dolist (prop-entry gptel--bounds)
      (let ((prop-type (car prop-entry))
            (bounds-list (cdr prop-entry)))
        (princ (format "=== Property: %s ===\n" prop-type))

        (dolist (bound bounds-list)
          (let* ((beg (nth 0 bound))
                 (end (nth 1 bound))
                 (val (nth 2 bound))
                 (text-prop (get-text-property beg 'gptel)))
            (princ (format "\nBound: %S\n" bound))
            (princ (format "  Position %d-%d" beg end))
            (when val (princ (format " (value: %s)" val)))
            (princ "\n")
            (princ (format "  Text property at %d: %S\n" beg text-prop))
            (princ (format "  Line at position %d: %d\n"
                          beg (line-number-at-pos beg)))
            (princ (format "  Content preview (50 chars from %d):\n" beg))
            (princ (format "    %S\n"
                          (buffer-substring-no-properties
                           beg (min end (+ beg 50)))))

            ;; For tool bounds, show if we can read a valid sexp
            (when (eq prop-type 'tool)
              (princ "  Attempting to read sexp from position:\n")
              (save-excursion
                (goto-char beg)
                (condition-case err
                    (let ((sexp (read (current-buffer))))
                      (princ (format "    SUCCESS: %S\n" sexp)))
                  (error
                   (princ (format "    ERROR: %s\n" err))))))))
        (princ "\n")))))
#+end_src

* Diagnostic 3: Tool Call Parsing Tracer

Trace what happens during =gptel--parse-buffer= when reading tool calls.

#+begin_src emacs-lisp
(defun jf/gptel--scan-tool-positions ()
  "Scan buffer for tool positions and attempt to parse them.
Returns list of parse attempts with results."
  (let ((tool-parses nil)
        (pt (point-max)))
    ;; Scan backwards like gptel--parse-buffer does
    (save-excursion
      (while (> pt (point-min))
        (let ((prop-val (get-char-property pt 'gptel)))
          (when (and (consp prop-val)
                     (eq (car prop-val) 'tool))
            (let* ((tool-id (cdr prop-val))
                   (line (line-number-at-pos pt))
                   (trace-entry (list :type "tool-scan"
                                     :position pt
                                     :line line
                                     :property prop-val
                                     :id tool-id)))
              (goto-char pt)
              (condition-case err
                  (let* ((tool-call (read (current-buffer)))
                         (name (plist-get tool-call :name))
                         (args (plist-get tool-call :args)))
                    (plist-put trace-entry :success t)
                    (plist-put trace-entry :sexp tool-call)
                    (plist-put trace-entry :name name)
                    (plist-put trace-entry :args args))
                (error
                 (plist-put trace-entry :success nil)
                 (plist-put trace-entry :error (error-message-string err))
                 (plist-put trace-entry :buffer-content
                           (buffer-substring-no-properties
                            pt (min (point-max) (+ pt 100))))))
              (push trace-entry tool-parses)))
          (setq pt (previous-single-char-property-change pt 'gptel nil (point-min))))))
    (nreverse tool-parses)))

(defun jf/gptel--trace-parse-buffer-advice (orig-fn backend &optional max-entries)
  "Trace gptel--parse-buffer execution for tool call parsing.
ORIG-FN is the original function, BACKEND is the gptel backend,
MAX-ENTRIES limits the number of entries to parse."
  ;; Capture tool positions BEFORE parsing
  (let* ((pre-parse-scan (jf/gptel--scan-tool-positions))
         (result (funcall orig-fn backend max-entries))
         (parse-entry (list :timestamp (format-time-string "%H:%M:%S.%3N")
                           :phase "parse-buffer-call"
                           :buffer (buffer-name)
                           :num-results (length result)
                           :tool-scans pre-parse-scan)))
    (push parse-entry jf/gptel--parse-trace)

    ;; Auto-write to diagnostic file
    (jf/gptel--write-parse-entry parse-entry)

    ;; Display trace window
    (with-temp-buffer-window "*GPTEL Parse Trace*" nil nil
      (princ (format "=== Parse Buffer Trace ===\n"))
      (princ (format "Buffer: %s\n" (buffer-name)))
      (princ (format "API entries generated: %d\n" (length result)))
      (princ (format "Tool positions found: %d\n\n" (length pre-parse-scan)))

      (dolist (scan pre-parse-scan)
        (princ (format "--- Tool at position %d (line %d) ---\n"
                      (plist-get scan :position)
                      (plist-get scan :line)))
        (princ (format "  ID: %s\n" (plist-get scan :id)))
        (if (plist-get scan :success)
            (progn
              (princ (format "  Name: %s\n" (plist-get scan :name)))
              (princ (format "  Args: %S\n" (plist-get scan :args))))
          (progn
            (princ (format "  ERROR: %s\n" (plist-get scan :error)))
            (when-let ((content (plist-get scan :buffer-content)))
              (princ (format "  Buffer content: %S\n" content)))))
        (princ "\n")))
    result))
#+end_src

* Diagnostic 4: Text Property Inspection

Show all gptel text properties in the buffer with their exact ranges.

#+begin_src emacs-lisp
(defun jf/gptel--show-all-text-properties ()
  "Display all gptel text properties in current buffer."
  (interactive)
  (let ((pt (point-min)))
    (with-output-to-temp-buffer "*GPTEL Text Properties*"
      (princ (format "=== GPTEL Text Properties in %s ===\n\n" (buffer-name)))

      (while (< pt (point-max))
        (let ((next-change (next-single-property-change pt 'gptel nil (point-max)))
              (prop-value (get-text-property pt 'gptel)))
          (when prop-value
            (let* ((line-start (line-number-at-pos pt))
                   (line-end (line-number-at-pos (or next-change (point-max))))
                   (content (buffer-substring-no-properties
                            pt (min (or next-change (point-max))
                                   (+ pt 60)))))
              (princ (format "Position %d-%s (lines %d-%d)\n"
                            pt (or next-change "END")
                            line-start line-end))
              (princ (format "  Property: %S\n" prop-value))
              (princ (format "  Content: %S%s\n\n"
                            content
                            (if (> (- (or next-change (point-max)) pt) 60)
                                "..." "")))))
          (setq pt (or next-change (point-max))))))))
#+end_src

* Diagnostic 5: Complete Session Lifecycle Management

Single comprehensive system capturing entire test flow.

#+begin_src emacs-lisp
(defun jf/gptel--start-diagnostic-session ()
  "Enable all diagnostics for a test session."
  (interactive)
  (setq jf/gptel--bounds-history nil)
  (setq jf/gptel--parse-trace nil)

  ;; Remove any existing advice first (in case of reload)
  (jf/gptel--stop-diagnostic-session)

  ;; Install all advice
  (advice-add 'gptel--restore-props :before
              (lambda (bounds-alist)
                (jf/gptel--record-bounds "BEFORE-restore-props")
                ;; Log the exact bounds-alist structure
                (let ((log-file (jf/gptel--get-diagnostic-file)))
                  (with-temp-buffer
                    (insert "\n=== BOUNDS-ALIST PASSED TO gptel--restore-props ===\n")
                    (pp bounds-alist (current-buffer))
                    (insert "\n")
                    (append-to-file (point-min) (point-max) log-file)))))

  ;; Trace what add-text-properties is called with during restoration
  (advice-add 'add-text-properties :before
              (lambda (beg end props &optional _)
                (when (and (listp props)
                           (memq 'gptel props)
                           (string-match-p "session\\.md" (or (buffer-file-name) "")))
                  (let ((log-file (jf/gptel--get-diagnostic-file))
                        (gptel-val (plist-get props 'gptel)))
                    (with-temp-buffer
                      (insert (format "add-text-properties called: %d-%d gptel=%S\n"
                                     beg end gptel-val))
                      ;; Capture FULL stack trace to see calling code
                      (insert "  Full Backtrace:\n")
                      (let ((standard-output (current-buffer)))
                        (backtrace))
                      (insert "\n")
                      (append-to-file (point-min) (point-max) log-file)))))
              '((name . gptel-diagnostics)))
  (advice-add 'gptel--restore-props :after
              (lambda (&rest _)
                (jf/gptel--record-bounds "AFTER-restore-props")
                ;; Also scan actual buffer properties to verify restoration
                (let* ((actual-tools (jf/gptel--scan-tool-positions))
                       (log-file (jf/gptel--get-diagnostic-file)))
                  (when actual-tools
                    (message "[BOUNDS] ACTUAL buffer properties after restore: %d tools found"
                             (length actual-tools))
                    ;; Write to log file
                    (with-temp-buffer
                      (insert (format "\n=== ACTUAL BUFFER PROPERTIES (after restore) ===\n"))
                      (insert (format "Found %d tool properties in buffer:\n" (length actual-tools)))
                      (dolist (tool actual-tools)
                        (let* ((pos (plist-get tool :position))
                               (gptel-prop (save-excursion
                                            (with-current-buffer (get-buffer "session.md")
                                              (get-text-property pos 'gptel))))
                               (text-sample (save-excursion
                                             (with-current-buffer (get-buffer "session.md")
                                               (buffer-substring-no-properties
                                                pos (min (point-max) (+ pos 20)))))))
                          (insert (format "  Position %d (line %d): name=%s\n"
                                         pos
                                         (plist-get tool :line)
                                         (or (plist-get tool :name) "nil")))
                          (insert (format "    Property value: %S\n" gptel-prop))
                          (insert (format "    Text at position: %S\n" text-sample))))
                      (insert "\n")
                      (append-to-file (point-min) (point-max) log-file))
                    (dolist (tool actual-tools)
                      (message "[BOUNDS]   Position %d: %s"
                               (plist-get tool :position)
                               (plist-get tool :name)))))))
  (advice-add 'gptel--get-buffer-bounds :around
              (lambda (orig-fn &rest args)
                (jf/gptel--record-bounds "BEFORE-get-buffer-bounds")
                (let ((result (apply orig-fn args)))
                  (jf/gptel--record-bounds "AFTER-get-buffer-bounds"
                                          (list :result result))
                  result)))
  (advice-add 'gptel--save-state :before
              (lambda (&rest _)
                (jf/gptel--record-bounds "BEFORE-save-state")))
  (advice-add 'gptel--save-state :after
              (lambda (&rest _)
                (jf/gptel--record-bounds "AFTER-save-state")))
  (advice-add 'jf/gptel--auto-init-session-buffer :before
              (lambda (&rest _)
                (jf/gptel--record-bounds "BEFORE-auto-init")))
  (advice-add 'jf/gptel--auto-init-session-buffer :after
              (lambda (&rest _)
                (jf/gptel--record-bounds "AFTER-auto-init")))
  (advice-add 'gptel--parse-buffer :around
              #'jf/gptel--trace-parse-buffer-advice)

  (message "Diagnostic session started. Run test flow, then call jf/gptel--dump-diagnostic-report"))
#+end_src

#+begin_src emacs-lisp
(defun jf/gptel--dump-diagnostic-report ()
  "Dump complete diagnostic report to a file."
  (interactive)
  (let ((report-file (expand-file-name
                     (format "gptel-diagnostic-%s.org"
                            (format-time-string "%Y%m%d-%H%M%S"))
                     "~/")))
    (with-temp-file report-file
      (insert "#+TITLE: GPTEL Diagnostic Report\n")
      (insert (format "#+DATE: %s\n\n" (format-time-string "%Y-%m-%d %H:%M:%S")))

      ;; Summary section
      (insert "* Summary\n\n")
      (insert "** Tool Parse Results by Phase\n\n")
      (dolist (entry (reverse jf/gptel--bounds-history))
        (when-let ((tool-parses (plist-get entry :tool-parses)))
          (insert (format "*** %s (%s)\n"
                         (plist-get entry :phase)
                         (plist-get entry :timestamp)))
          (dolist (parse tool-parses)
            (if (plist-get parse :success)
                (insert (format "- ✓ Position %d: ~%s~ with args\n"
                               (plist-get parse :position)
                               (plist-get parse :name)))
              (insert (format "- ✗ Position %d: ERROR - %s\n"
                             (plist-get parse :position)
                             (plist-get parse :error)))))
          (insert "\n")))

      (insert "** Parse Buffer Calls\n\n")
      (dolist (trace (reverse jf/gptel--parse-trace))
        (when (equal (plist-get trace :phase) "parse-buffer-call")
          (insert (format "*** %s - %d tools found\n"
                         (plist-get trace :timestamp)
                         (length (plist-get trace :tool-scans))))
          (dolist (scan (plist-get trace :tool-scans))
            (if (plist-get scan :success)
                (insert (format "- ✓ Position %d: ~%s~\n"
                               (plist-get scan :position)
                               (plist-get scan :name)))
              (insert (format "- ✗ Position %d: %s\n"
                             (plist-get scan :position)
                             (plist-get scan :error)))))
          (insert "\n")))

      ;; Raw data sections
      (insert "* Bounds History (Full Data)\n\n")
      (insert "#+BEGIN_SRC elisp\n")
      (pp jf/gptel--bounds-history (current-buffer))
      (insert "\n#+END_SRC\n\n")

      (insert "* Parse Trace (Full Data)\n\n")
      (insert "#+BEGIN_SRC elisp\n")
      (pp jf/gptel--parse-trace (current-buffer))
      (insert "\n#+END_SRC\n\n")

      (insert "* Current Buffer State\n\n")
      (when (buffer-live-p (get-buffer "session.md"))
        (with-current-buffer "session.md"
          (insert (format "** gptel--bounds\n\n"))
          (insert "#+BEGIN_SRC elisp\n")
          (when (boundp 'gptel--bounds)
            (pp gptel--bounds (current-buffer)))
          (insert "\n#+END_SRC\n\n"))))

    (message "Diagnostic report written to %s" report-file)
    (find-file report-file)))
#+end_src

#+begin_src emacs-lisp
(defun jf/gptel--stop-diagnostic-session ()
  "Disable all diagnostics and clean up.
Removes ALL advice from diagnostic functions, not just specific ones."
  (interactive)
  ;; Remove all advice from these functions
  (dolist (func '(gptel--restore-props
                  gptel--get-buffer-bounds
                  gptel--save-state
                  jf/gptel--auto-init-session-buffer
                  gptel--parse-buffer))
    (advice-mapc (lambda (advice props)
                   (advice-remove func advice))
                 func))

  ;; Remove named advice from add-text-properties
  (advice-remove 'add-text-properties 'gptel-diagnostics)

  (message "Diagnostic session stopped - all advice removed"))
#+end_src

* Usage Instructions

** Starting a Diagnostic Session

Diagnostics start automatically when gptel module loads on Emacs startup.

You should see these messages:
- ="GPTEL diagnostics auto-enabled - logging to ~/.gptel-diagnostics.log"=
- ="Session diagnostics will write to: <session-dir>/diagnostics.log"=

The diagnostic session captures all bounds changes and parse attempts, writing them:
- To =~/.gptel-diagnostics.log= for non-session buffers (fallback)
- To =<session-dir>/diagnostics.log= when working in a gptel session

** Running the Test Flow

1. Create new session with tool call
2. Inspect bounds: =M-x jf/gptel--inspect-bounds-positions=
3. Show properties: =M-x jf/gptel--show-all-text-properties=
4. Close and reopen buffer
5. Inspect again to compare
6. Send new prompt
7. Generate report: =M-x jf/gptel--dump-diagnostic-report=

** Cleanup

Stop diagnostics: =M-x jf/gptel--stop-diagnostic-session=

* Auto-Initialization

Automatically start the diagnostic session when this module is loaded.
This makes it "hot" immediately without requiring manual activation.

#+begin_src emacs-lisp
;; Auto-start diagnostics when this file is loaded
(jf/gptel--start-diagnostic-session)
(message "GPTEL diagnostics auto-enabled - logging to %s"
         jf/gptel--diagnostic-fallback-file)
(message "Session diagnostics will write to: <session-dir>/diagnostics.log")
#+end_src

* Provide Module

#+begin_src emacs-lisp
(provide 'jf-gptel-diagnostics)
#+end_src
