#+title: GPTEL Configuration
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle gptel.el
#+auto_tangle: y

* Introduction

This file configures various large language model (LLM) and AI integrations for Emacs,
including OpenAI GPT, Anthropic Claude, and Perplexity models. It sets up interactive
shells, buffers, and tools for working with these AI assistants.

The gptel configuration is modular:
- =gptel/= - Main loader (this file)
- =gptel/sessions/= - Session management (8 modules)
- =gptel/skills/= - Skills system (3 modules)
- =gptel/tools/= - Tool definitions (10 modules)
- =gptel/agents/= - Agent definitions (5 files)

* Basic Configuration

Setup lexical binding for better closures and variable scoping.

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(require 'cl-lib)
#+end_src

* ChatGPT Shell

Configure Xenodium's ChatGPT shell for a conversational interface with OpenAI models (currently disabled).

#+begin_src emacs-lisp
;;  (use-package shell-maker
;;    :straight (shell-maker :type git :host github :repo "xenodium/shell-maker" :files ("shell-maker.el")))
;;
;;  ; add :build (:not compile) if byte code has problems
;;  (use-package chatgpt-shell
;;    :requires shell-maker
;;    :straight (:host github :repo "xenodium/chatgpt-shell" :files ("*.el") :build (:not compile)))
;;
;;  (setq chatgpt-shell-openai-key
;;        (lambda ()
;;          (auth-source-pick-first-password :host "api.openai.com")))
;;
;;  ;;(setq chatgpt-shell-model-version "gpt-4o")
#+end_src

* GPTEL

Configure gptel, a versatile LLM client with support for multiple models and providers.

** Authentication Setup

This configuration uses =.authinfo.gpg= to securely store API keys. Create or edit
=~/.authinfo.gpg= with entries in the following format:

#+begin_example
machine api.openai.com login apikey password YOUR_OPENAI_API_KEY
machine api.anthropic.com login apikey password YOUR_ANTHROPIC_API_KEY
machine api.perplexity.ai login apikey password YOUR_PERPLEXITY_API_KEY
#+end_example

Notes:
- Each entry should be on a single line
- The =machine= field corresponds to the =:host= parameter in the config
- The =login= field can be any value (commonly "apikey" for API services)
- The =password= field contains your actual API key
- Save the file and GPG will encrypt it automatically if it has the =.gpg= extension
- You may need to enter your GPG passphrase when Emacs first accesses the file

** GPTEL Configuration

This configuration enables debug mode and prompt caching for easier testing and development:
- =gptel-log-level= set to ='debug= logs full request/response bodies, headers, and connection settings to the =*gptel-log*= buffer
- =gptel-cache= set to =t= enables prompt caching for all supported models (particularly Anthropic)
- =gptel-expert-commands= set to =t= enables advanced options in the gptel transient menu (=C-u C-c RET=)

These settings are useful for:
- Verifying prompt caching behavior (check =cache_control= blocks and cache hit/miss in response headers)
- Debugging API issues
- Inspecting system message structure (especially with gptel skills)

To view logs: =M-x gptel-view-log= or switch to the =*gptel-log*= buffer.

Note: =gptel-cache= can also be set to ='(system message)= to cache only specific parts, or ='(system)= to cache only system messages.

#+begin_src emacs-lisp
(use-package gptel
  :straight t
  :custom
  (gptel-model 'gpt-4o) ;; model is now a symbol, not a string
  (gptel-log-level 'debug) ;; Enable debug logging for testing
  :config
  ;; Enable prompt caching for Anthropic models
  (setq gptel-cache t)
  ;; Enable expert commands to show advanced options in transient menu
  (setq gptel-expert-commands t)
  ;; Configure Perplexity backend
  (gptel-make-perplexity "Perplexity"
    :key (lambda () (auth-source-pick-first-password :host "api.perplexity.ai"))
    :stream t)

  ;; Configure Anthropic backend with curated Claude 4.5 models
  ;; Includes lightweight (Haiku), balanced (Sonnet), and heavyweight (Opus) options
  (gptel-make-anthropic "Claude"
    :stream t
    :key (lambda () (auth-source-pick-first-password :host "api.anthropic.com"))
    :models '(claude-haiku-4-5-20251001      ; Fast & economical for simple tasks
              claude-sonnet-4-5-20250929     ; Balanced for most use cases
              claude-opus-4-5-20251101))     ; Most capable for complex reasoning

  ;; Configure Claude Sonnet 4.5 with extended thinking mode for complex problems
  ;; Thinking mode provides detailed reasoning before answering
  (gptel-make-anthropic "Claude-thinking"
    :key (lambda () (auth-source-pick-first-password :host "api.anthropic.com"))
    :stream t
    :models '(claude-sonnet-4-5-20250929)
    :header (lambda ()
              (let ((key (gptel--get-api-key
                          (lambda () (auth-source-pick-first-password :host "api.anthropic.com")))))
                `(("x-api-key" . ,key)
                  ("anthropic-version" . "2023-06-01")
                  ("anthropic-beta" . "pdfs-2024-09-25")
                  ("anthropic-beta" . "output-128k-2025-02-19")
                  ("anthropic-beta" . "prompt-caching-2024-07-31"))))
    :request-params '(:thinking (:type "enabled" :budget_tokens 2048)
                      :max_tokens 4096))

  ;; Configure ChatGPT/OpenAI backend
  (gptel-make-openai "ChatGPT"
    :key (lambda () (auth-source-pick-first-password :host "api.openai.com"))
    :stream t
    :models '(gpt-4o gpt-4o-mini gpt-4-turbo gpt-3.5-turbo)))
#+end_src

* GPTEL Skills System

Load the skills system modules that provide skill discovery, mention detection, and injection.

#+begin_src emacs-lisp
;; Load skills system (core, org-roam integration, transient UI)
(jf/load-module (expand-file-name "config/gptel/skills/skills-core.el" jf/emacs-dir))
(jf/load-module (expand-file-name "config/gptel/skills/skills-roam.el" jf/emacs-dir))
(jf/load-module (expand-file-name "config/gptel/skills/skills-transient.el" jf/emacs-dir))
#+end_src

* GPTEL Agent

Configure gptel-agent package for agent delegation with file-based agent definitions.

gptel-agent provides:
- Invisible agent execution (no buffer clutter)
- File-based agent definitions with YAML frontmatter
- "Agent" tool for delegating to specialized agents
- Robust FSM and callback handling

#+begin_src emacs-lisp
(use-package gptel-agent
  :straight t
  :after gptel
  :demand t
  :config
  ;; Add our custom agent directory to the scan path
  (add-to-list 'gptel-agent-dirs
               (expand-file-name "config/gptel/agents/" jf/emacs-dir))

  ;; Load scope-core FIRST (required by scope-controlled tools)
  (jf/load-module (expand-file-name "config/gptel/scope/scope-core.el" jf/emacs-dir))

  ;; Load custom tools BEFORE agent update so agents can reference them
  (jf/load-module (expand-file-name "config/gptel/tools/filesystem-tools.el" jf/emacs-dir))
  (jf/load-module (expand-file-name "config/gptel/tools/projectile-tools.el" jf/emacs-dir))
  (jf/load-module (expand-file-name "config/gptel/tools/ggtags-tools.el" jf/emacs-dir))
  (jf/load-module (expand-file-name "config/gptel/tools/treesitter-tools.el" jf/emacs-dir))
  (jf/load-module (expand-file-name "config/gptel/tools/org-roam-tools.el" jf/emacs-dir))
  (jf/load-module (expand-file-name "config/gptel/tools/sql-tools.el" jf/emacs-dir))
  (jf/load-module (expand-file-name "config/gptel/tools/meta-tools.el" jf/emacs-dir))
  (jf/load-module (expand-file-name "config/gptel/tools/community-tools.el" jf/emacs-dir))
  (jf/load-module (expand-file-name "config/gptel/tools/transient-tools.el" jf/emacs-dir))
  ;; Note: persistent-agent.el loaded later after session modules

  ;; Scan and register agents from all configured directories
  (gptel-agent-update)

  ;; Enable Agent tool by default for all gptel sessions
  ;; This allows the main LLM to delegate tasks to specialized agents
  (setq-default gptel-tools (list (gptel-get-tool "Agent"))))
#+end_src

** Agent Skills Integration

Allow agents to reference skills via =@mention= syntax in their system prompts.
Skills provide reusable knowledge modules that can be injected into agent contexts.

#+begin_src emacs-lisp
(defun jf/gptel-agent--expand-skills (system-text)
  "Expand @skill mentions in SYSTEM-TEXT using gptel-skills.
Returns updated system text with skill content injected.
If skills system not loaded or no mentions found, returns text unchanged."
  (if (and (fboundp 'jf/gptel-skills--detect-mentions)
           (boundp 'jf/gptel-skills--registry)
           (string-match-p "@" system-text))
      (with-temp-buffer
        (insert system-text)
        (let* ((mentions-data (jf/gptel-skills--detect-mentions (current-buffer)))
               (skill-names (mapcar #'car mentions-data)))
          (when skill-names
            ;; For each unique skill, replace @mention with content
            (dolist (skill-name (delete-dups skill-names))
              (let* ((metadata (gethash skill-name jf/gptel-skills--registry))
                     (skill-path (plist-get metadata :path))
                     (skill-content (when skill-path
                                     (jf/gptel-skills--parse-content skill-path))))
                (when skill-content
                  (goto-char (point-min))
                  (while (re-search-forward
                          (concat "@" (regexp-quote skill-name) "\\>")
                          nil t)
                    (replace-match skill-content t t))))))
          (buffer-string)))
    ;; No skills system or no mentions - return unchanged
    system-text))

(defun jf/gptel-agent--expand-all-agent-skills ()
  "Expand @skill mentions in all registered agent system prompts.
Run this after gptel-agent-update to inject skill content into agents."
  (when (and (boundp 'gptel-agent--agents)
             (fboundp 'jf/gptel-skills--discover))
    ;; Ensure skills are discovered first
    (jf/gptel-skills--discover)

    ;; Process each agent
    (dolist (agent-entry gptel-agent--agents)
      (let* ((agent-name (car agent-entry))
             (plist (cdr agent-entry))
             (system (plist-get plist :system)))
        (when (and system (stringp system))
          (let ((expanded (jf/gptel-agent--expand-skills system)))
            (unless (string= expanded system)
              (plist-put plist :system expanded)
              (when jf/gptel-skills-verbose
                (message "Expanded skills in agent: %s" agent-name)))))))))

;; Hook into gptel-agent-update to auto-expand skills
(with-eval-after-load 'gptel-agent
  (advice-add 'gptel-agent-update :after #'jf/gptel-agent--expand-all-agent-skills))

;; TEMPORARILY COMMENTED OUT: Testing cursor movement with confirmation enabled
;; ;; Disable confirmation for Agent tool (agent invocations)
;; ;; The Agent tool by default has :confirm t, but we trust our agents
;; (with-eval-after-load 'gptel-agent-tools
;;   (when-let ((agent-tool (gptel-get-tool "Agent")))
;;     (setf (gptel-tool-confirm agent-tool) nil)
;;     (message "Disabled confirmation for Agent tool")))
#+end_src

* GPTEL Session Management

Load session management modules in dependency order:
1. Constants - Centralized constants for magic strings
2. Logging - Leveled logging system (replaces 54+ debug messages)
3. Filesystem - Filesystem utilities for directory-based persistence
4. Registry - Global session registry and initialization
5. Metadata - Metadata persistence (simplified for filesystem format)
6. Tracing - Agent execution tracing
7. Hooks - Advice functions and auto-save (uses filesystem persistence)
8. Browser - Session browsing and reconstruction
9. Branching - Branch creation and management

#+begin_src emacs-lisp
;; Load foundational modules first (used by all other session modules)
(jf/load-module (expand-file-name "config/gptel/sessions/constants.el" jf/emacs-dir))
(jf/load-module (expand-file-name "config/gptel/sessions/logging.el" jf/emacs-dir))

;; Load filesystem utilities before other modules (registry and hooks depend on it)
(jf/load-module (expand-file-name "config/gptel/sessions/filesystem.el" jf/emacs-dir))

;;; Load session modules in dependency order
(jf/load-module (expand-file-name "config/gptel/sessions/registry.el" jf/emacs-dir))
(jf/load-module (expand-file-name "config/gptel/sessions/metadata.el" jf/emacs-dir))

;; Load agent integration (simplified - no longer hooks into FSM)
(jf/load-module (expand-file-name "config/gptel/sessions/agent-integration.el" jf/emacs-dir))

;; Load scope-core (needed by scope-commands)
(jf/load-module (expand-file-name "config/gptel/scope/scope-core.el" jf/emacs-dir))

;; Load scope-commands BEFORE session-commands (session-commands requires scope-commands)
(jf/load-module (expand-file-name "config/gptel/scope/scope-commands.el" jf/emacs-dir))

;; Load PersistentAgent tool (requires session modules to be loaded first)
(jf/load-module (expand-file-name "config/gptel/tools/persistent-agent.el" jf/emacs-dir))

;; Load user-facing commands
(jf/load-module (expand-file-name "config/gptel/sessions/commands.el" jf/emacs-dir))

;; Load remaining scope system modules (scope-core and scope-commands already loaded above)
;; Scope-aware tools check approved patterns internally and return
;; structured errors to LLM when operations are outside scope
(jf/load-module (expand-file-name "config/gptel/scope/scope-filesystem-tools.el" jf/emacs-dir))
(jf/load-module (expand-file-name "config/gptel/scope/scope-org-roam-tools.el" jf/emacs-dir))
(jf/load-module (expand-file-name "config/gptel/scope/scope-shell-tools.el" jf/emacs-dir))

;; Load activities integration (optional - only if activities package is loaded)
;; Enables creating persistent gptel sessions as part of activity creation
(when (featurep 'activities)
  (jf/load-module (expand-file-name "config/gptel/sessions/activities-integration.el" jf/emacs-dir)))
#+end_src

* GPTEL Session Launcher

Quick launcher function for starting dedicated gptel sessions with any configured model.
Uses completing-read to select from all available backends and models.

#+begin_src emacs-lisp
(defun jf/gptel-launcher ()
  "Launch gptel session with a selected backend and model.
Prompts for display method, then backend:model selection using
completing-read with all available options from gptel's configuration."
  (interactive)
  ;; First, ask where to display the buffer
  (let* ((display-options '(("Current window" . current)
                            ("New tab" . tab)
                            ("Split window" . split)))
         (display-choice (completing-read "Where to open? "
                                          (mapcar #'car display-options)
                                          nil t nil nil "Current window"))
         (display-method (cdr (assoc display-choice display-options)))
         ;; Build models-alist similar to gptel--infix-provider
         (models-alist
          (cl-loop
           for (name . backend) in gptel--known-backends
           nconc (cl-loop for model in (gptel-backend-models backend)
                          collect (list (concat name ":" (gptel--model-name model))
                                        backend model))))
         (selected (completing-read "Select model: "
                                     (mapcar #'car models-alist)
                                     nil t))
         (choice (assoc selected models-alist))
         (backend (nth 1 choice))
         (model (nth 2 choice))
         (buffer-name (format "*gptel-%s*" (replace-regexp-in-string ":" "-" selected)))
         ;; Create buffer without displaying it (pass nil for interactivep)
         ;; Note: When interactivep is t, gptel calls (display-buffer) with
         ;; gptel-display-buffer-action, which would display the buffer before
         ;; we can control where it goes. By passing nil, we handle all display
         ;; logic ourselves based on the user's selection.
         (buffer (gptel buffer-name nil nil nil)))
    ;; Display buffer based on user's choice
    (pcase display-method
      ('split (pop-to-buffer buffer))
      ('tab (tab-bar-new-tab)
            (switch-to-buffer buffer))
      ('current (switch-to-buffer buffer)))
    ;; Set backend and model as buffer-local
    (with-current-buffer buffer
      (setq-local gptel-backend backend)
      (setq-local gptel-model model))))

;; Keybinding for gptel launcher
;; Direct access with <SPC> l
(with-eval-after-load 'gptel
  (evil-define-key 'normal 'global (kbd "<SPC> l") 'jf/gptel-launcher))
#+end_src

** Usage

Launch a dedicated LLM session with =<SPC> l= or =M-x jf/gptel-launcher=.

The launcher will prompt you twice:
1. *Where to open?* - Choose display method:
   - =Current window= (default) - Replaces the current buffer
   - =New tab= - Opens in a new tab
   - =Split window= - Opens in a vertical split
2. *Select model:* - Choose from all configured backends and models

Models are displayed in the format =Backend:model-name= (e.g., =ChatGPT:gpt-4o=,
=Claude-thinking:claude-sonnet-4-5-20250929=, etc.). Each selection creates or
switches to a dedicated buffer named =*gptel-Backend-model*=, allowing multiple
concurrent sessions with different models.
