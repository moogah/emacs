#+title: GPTEL Scope Manager - Shell and Meta Tools
#+author: Jeff Farr
#+property: header-args:elisp :tangle scope-shell-tools.el :comments both

* Overview

This module provides scope-aware shell execution and meta tools for v3.0 preset-based permission management:

1. *Shell tool*: =run_approved_command= - Execute shell commands with pattern checking (v3.0)
2. *Meta tool*: =request_scope_expansion= - LLM requests user approval via transient menu (v3.0 async)

** Shell Command Scoping (v3.0)

The =run_approved_command= tool uses preset.md configuration:
- *shell_commands.allow*: Allowlist of command names (e.g., ["ls", "git", "npm"])
- *shell_commands.deny*: Denylist patterns (substring matching, e.g., ["rm -rf", "sudo"])

Deny patterns override allow patterns for security.
Validation handled by =jf/gptel-scope--validate-command-tool= in scope-core.org.

** Scope Expansion (v3.0)

The =request_scope_expansion= tool shows interactive transient menu with 3 choices:
- *Deny* - Reject the expansion request
- *Add to scope* - Permanently add patterns to preset.md
- *Allow once* - Temporarily allow for current turn only

Uses async tool pattern with callback for FSM coordination.
UI implemented in scope-expansion.org.

* File Header

#+begin_src elisp
;;; scope-shell-tools.el --- GPTEL Scope Shell and Meta Tools -*- lexical-binding: t; -*-

;; Copyright (C) 2024-2026 Jeff Farr

;;; Commentary:

;; Scope-aware shell execution and meta tools for v3.0 preset-based permission management.

;;; Code:
#+end_src

* Dependencies

#+begin_src elisp
(require 'cl-lib)
(require 'jf-gptel-scope-core)
(require 'jf-gptel-scope-expansion)  ; For jf/gptel-scope--prompt-expansion
#+end_src

* Bash Command Helper Functions

** Parse Command

Extract base command from complex shell strings with pipes, redirects, and command substitution.

#+begin_src elisp
(defun jf/gptel-bash--parse-command (cmd-string)
  "Extract base command from CMD-STRING.
Handles pipes, redirects, command substitution.
Examples:
  'grep foo | head' → 'grep'
  'ls -la > output.txt' → 'ls'
  'echo $(date)' → 'echo'"
  (let* ((trimmed (string-trim cmd-string))
         ;; Split on shell metacharacters
         (parts (split-string trimmed "[ |><;&]+" t))
         (base (car parts)))
    base))
#+end_src

** Categorize Command

Categorize command using bash_tools configuration section.

#+begin_src elisp
(defun jf/gptel-bash--categorize-command (command config)
  "Categorize COMMAND using CONFIG bash_tools section.
Returns: 'denied, 'read_only, 'safe_write, 'dangerous, or 'unknown."
  (let ((deny-list (plist-get config :deny))
        (read-only (plist-get (plist-get config :read_only) :commands))
        (safe-write (plist-get (plist-get config :safe_write) :commands))
        (dangerous (plist-get (plist-get config :dangerous) :commands)))
    (cond
     ((member command deny-list) 'denied)
     ((member command read-only) 'read_only)
     ((member command safe-write) 'safe_write)
     ((member command dangerous) 'dangerous)
     (t 'unknown))))
#+end_src

** Validate Directory for Category

Validate directory matches category's path scope requirement.

#+begin_src elisp
(defun jf/gptel-bash--validate-directory-for-category (directory category config)
  "Validate DIRECTORY matches CATEGORY's path scope requirement.
- read_only: must match paths.read OR paths.write
- safe_write: must match paths.write
- dangerous: always requires expansion (return error)

Returns (:allowed t) or (:allowed nil :reason ... :allowed-patterns ...)."
  (let ((read-paths (plist-get (plist-get config :paths) :read))
        (write-paths (plist-get (plist-get config :paths) :write))
        (deny-paths (plist-get (plist-get config :paths) :deny)))

    ;; Check deny first (deny takes precedence)
    (when (jf/gptel-scope--path-matches-any-pattern-p directory deny-paths)
      (cl-return-from jf/gptel-bash--validate-directory-for-category
        (list :allowed nil
              :reason (format "Directory %s matches deny pattern" directory))))

    (pcase category
      ('read_only
       ;; Read-only commands allowed in read OR write paths
       (if (or (jf/gptel-scope--path-matches-any-pattern-p directory read-paths)
               (jf/gptel-scope--path-matches-any-pattern-p directory write-paths))
           (list :allowed t)
         (list :allowed nil
               :reason (format "Directory %s not in read scope" directory)
               :required_scope "read"
               :allowed-patterns (append read-paths write-paths))))

      ('safe_write
       ;; Write commands require write paths
       (if (jf/gptel-scope--path-matches-any-pattern-p directory write-paths)
           (list :allowed t)
         (list :allowed nil
               :reason (format "Directory %s not in write scope" directory)
               :required_scope "write"
               :allowed-patterns write-paths)))

      ('dangerous
       ;; Dangerous commands always require explicit expansion
       (list :allowed nil
             :reason "Dangerous command requires explicit approval"
             :message "Use request_scope_expansion to request approval")))))
#+end_src

** Check Absolute Paths

Check if command contains absolute paths that bypass directory scoping.

#+begin_src elisp
(defun jf/gptel-bash--check-absolute-paths (command)
  "Check if COMMAND contains absolute paths.
Returns warning string if found, nil otherwise."
  (when (string-match "/[[:alnum:]_/-]+" command)
    "Warning: Command contains absolute path arguments. Directory scope may not protect these paths."))
#+end_src

** Execute Command

Execute command in directory with timeout and output truncation.

#+begin_src elisp
(defun jf/gptel-bash--execute-command (command directory)
  "Execute COMMAND in DIRECTORY with timeout and output truncation.
Returns (:success t :output ...) or (:success nil :error ...)."
  (let* ((default-directory (file-truename (expand-file-name directory)))
         (output nil)
         (exit-code nil)
         (max-output-chars 10000))

    (condition-case err
        (with-timeout (30)  ; 30-second timeout
          (setq output
                (with-temp-buffer
                  (setq exit-code
                        (call-process shell-file-name nil t nil
                                      shell-command-switch command))
                  (buffer-string))))
      (error
       (cl-return-from jf/gptel-bash--execute-command
         (list :success nil
               :error (format "Command timed out or failed: %s" err)))))

    ;; Truncate output if too long
    (when (> (length output) max-output-chars)
      (setq output
            (concat (substring output 0 max-output-chars)
                    (format "\n\n[Output truncated at %d chars. Use more specific filters like 'head', 'grep', or 'tail' to narrow results.]"
                            max-output-chars))))

    ;; Check for warnings
    (let ((path-warning (jf/gptel-bash--check-absolute-paths command)))
      (when path-warning
        (setq output (concat path-warning "\n\n" output))))

    (if (zerop exit-code)
        (list :success t :output output)
      (list :success nil :error output :exit_code exit-code))))
#+end_src

* Run Bash Command Tool (Scope-Aware, v3.0)

Execute bash commands in specified directory with category-based scope validation.

#+begin_src elisp
(gptel-make-scoped-tool
 "run_bash_command"
 "Execute shell command in specified directory with scope validation.

Commands are categorized:
- read_only: ls, grep, find, cat, head, tail, wc, file, git log, git show, git diff
- safe_write: mkdir, touch, echo, git add, git commit
- dangerous: (empty by default, requires explicit approval)

Directory must be in scope for command category:
- read_only commands: directory must match paths.read OR paths.write
- safe_write commands: directory must match paths.write

Shell composition allowed (pipes, redirects, command substitution), but only base command is validated.

Security features:
- 30-second timeout
- Output truncation at 10,000 chars
- Warnings for absolute paths in arguments
- Deny list blocks dangerous commands (rm, mv, chmod, sudo)

Examples:
  run_bash_command('ls -la', '/Users/jefffarr/emacs')
  run_bash_command('grep -r TODO . | head -20', '/Users/jefffarr/projects/myapp')
  run_bash_command('git log --oneline -10', '/Users/jefffarr/emacs')
  run_bash_command('mkdir scratch', '/tmp')"

 (list '(:name "command"
         :type string
         :description "Shell command to execute (pipes and redirects allowed)")
       '(:name "directory"
         :type string
         :description "Working directory (must be in scope for command category)"))

 "bash"

 ;; Tool body - executed only if validation passes
 (jf/gptel-bash--execute-command command directory))
#+end_src

* Request Scope Expansion Tool (Meta Tool, v3.0 Async)

LLM uses this tool to explicitly request user approval for expanding scope using transient menu.

#+begin_src elisp
(gptel-make-tool
 :name "request_scope_expansion"
 :async t  ; MUST be async for transient menu
 :description "Request user approval to expand scope with new patterns.

Displays interactive menu with 3 options:
1. Deny - Reject the expansion request
2. Add to scope - Permanently add patterns to preset.md
3. Allow once - Temporarily allow for current turn only

The user will see:
- Which tool needs access
- What patterns/resources you want to add
- Your justification for why access is needed

Returns:
- success: true if approved (add-to-scope or allow-once)
- success: false if denied
- allowed_once: true if temporary permission granted
- patterns_added: list of patterns if permanently added"
 :args (list '(:name "tool_name"
               :type string
               :description "Tool name (e.g., 'read_file', 'write_file_in_scope', 'run_approved_command')")
             '(:name "patterns"
               :type array
               :items (:type string)
               :description "Patterns to add (e.g., [\"/tmp/**\"] for files, [\"npm\"] for shell)")
             '(:name "justification"
               :type string
               :description "Explain why this access is needed. Be specific."))
 :category "scope"
 :function
 (lambda (callback tool_name patterns justification)  ; callback first!
   ;; Convert patterns from vector to list
   (when (vectorp patterns)
     (setq patterns (append patterns nil)))

   ;; Build violation info for transient menu
   (let* ((violation-info
           (list :tool tool_name
                 :resource (car patterns)  ; First pattern as resource
                 :reason justification
                 :validation-type (jf/gptel-scope--infer-validation-type tool_name)
                 :patterns patterns)))

     ;; Show transient menu - pass callback, patterns, tool_name directly in scope
     (jf/gptel-scope--prompt-expansion violation-info callback patterns tool_name))))
#+end_src

* Helper: Infer Validation Type

Helper to infer validation type from tool name using tool categories.

#+begin_src elisp
(defun jf/gptel-scope--infer-validation-type (tool-name)
  "Infer validation type from TOOL-NAME using tool categories."
  (let ((category (cdr (assoc tool-name jf/gptel-scope--tool-categories))))
    (plist-get category :validation)))
#+end_src

* Obsolete: inspect_scope_plan Tool (Removed in v3.0)

In v3.0, preset.md is a readable markdown file with YAML frontmatter.
LLM can use read_file("preset.md") to inspect scope configuration directly.
No dedicated inspection tool needed.

* Provide Feature

#+begin_src elisp
(provide 'jf-gptel-scope-shell-tools)
;;; scope-shell-tools.el ends here
#+end_src
