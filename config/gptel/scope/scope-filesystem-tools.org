#+title: GPTEL Scope Manager - Filesystem Tools
#+author: Jeff Farr
#+property: header-args:elisp :tangle scope-filesystem-tools.el :comments both

* Overview

This module provides scope-aware filesystem tools for gptel sessions. All tools use the =gptel-make-scoped-tool= macro which automatically handles:
- Session ID retrieval and plan loading
- Tool-specific permission validation
- Structured error formatting
- Exception handling

Tools are defined with minimal boilerplate - just the core logic.

** Key Principles

1. *Tool-level permissions*: Independent control for read_file, write_file_in_scope, and edit_file_in_scope
2. *Consistent interface*: All tools use =(filepath ...)= as first parameter
3. *Permissive reads*: Templates grant =/**= patterns for read_file by default
4. *Restricted writes*: write_file and edit_file require explicit pattern approval
5. *Structured errors*: Macro returns formatted errors automatically on scope violations

* Dependencies

#+begin_src elisp
(require 'cl-lib)
(require 'jf-gptel-scope-core)
#+end_src

* Helper Functions

** Git-Tracked File Validation

Check if a file is tracked by git. Used to enforce git-safe editing in project-aware sessions.

#+begin_src elisp
(defun jf/gptel--file-is-git-tracked-p (file)
  "Check if FILE is tracked by git.
Returns t if file is tracked, nil if untracked or ignored.
Returns nil if file is not in a git repository."
  (when-let* ((git-dir (locate-dominating-file file ".git")))
    (let ((default-directory git-dir)
          (relative-file (file-relative-name file git-dir)))
      (= 0 (call-process "git" nil nil nil "ls-files" "--error-unmatch" relative-file)))))
#+end_src

* Read File Tool (Scope-Aware)

Read file contents, checking scope patterns. Templates typically grant very permissive read access.

#+begin_src elisp
(gptel-make-scoped-tool
 "read_file"
 "Read contents of a file at the specified path.
Checks scope plan patterns before reading.
Most scope plans allow broad read access (e.g., all project files).
Use request_scope_expansion if you need to read files outside approved patterns."

 (list '(:name "filepath"
         :type string
         :description "Full path to file (can be relative or absolute)"))

 "filesystem"

 ;; Tool body - executed only if scope check passes
 (let ((full-path (expand-file-name filepath)))
   (if (file-exists-p full-path)
       (list :success t
             :content (with-temp-buffer
                       (insert-file-contents full-path)
                       (buffer-string))
             :full_path full-path)
     (list :success nil
           :error "file_not_found"
           :message (format "File not found: %s" full-path)))))
#+end_src

* Write File Tool (Scope-Aware)

Write content to a file, checking scope before execution.

#+begin_src elisp
(gptel-make-scoped-tool
 "write_file_in_scope"
 "Write content to a file, respecting scope plan.
Returns error if path is not in approved scope patterns.
Use request_scope_expansion tool to ask user for approval if needed.

Example error response:
{:success nil :error \"scope_violation\" :tool \"write_file_in_scope\"
 :resource \"/path/to/file\" :allowed_patterns [\"/approved/**/*.el\"]
 :message \"Tool denied. Use request_scope_expansion to ask user.\"}

When you receive a scope violation:
1. Check the allowed_patterns to see what IS approved
2. Try an alternative path that matches allowed patterns, OR
3. Use request_scope_expansion to ask user to add the path to scope"

 (list '(:name "filepath"
         :type string
         :description "Full path to file (can be relative or absolute)")
       '(:name "content"
         :type string
         :description "File contents to write"))

 "filesystem"

 ;; Tool body - executed only if scope check passes
 (let ((full-path (expand-file-name filepath)))
   ;; Ensure directory exists
   (let ((dir (file-name-directory full-path)))
     (unless (file-exists-p dir)
       (make-directory dir t)))
   ;; Write file
   (with-temp-file full-path
     (insert content))
   (list :success t
         :full_path full-path
         :message (format "File written: %s" full-path))))
#+end_src

* Edit File Tool (Scope-Aware)

Edit a file by replacing strings, checking scope before execution.

#+begin_src elisp
(gptel-make-scoped-tool
 "edit_file_in_scope"
 "Edit a file by replacing old_string with new_string, respecting scope plan.
Returns error if path is not in approved scope patterns.

GIT-SAFE EDITING: This tool only allows editing files tracked by git.
This prevents accidentally modifying ignored files like node_modules/, build artifacts, etc.
If you get a 'file_not_git_tracked' error, the file must be added to git first.

The file must already exist. Use write_file_in_scope to create new files.

Example usage:
- Replace function implementation
- Update variable values
- Modify configuration settings

Returns scope violation error if path not approved."

 (list '(:name "filepath"
         :type string
         :description "Full path to file (can be relative or absolute)")
       '(:name "old_string"
         :type string
         :description "Text to replace (must match exactly)")
       '(:name "new_string"
         :type string
         :description "Replacement text"))

 "filesystem"

 ;; Tool body - executed only if scope check passes
 (let ((full-path (expand-file-name filepath)))
   ;; Check if file exists
   (unless (file-exists-p full-path)
     (cl-return-from nil
       (list :success nil
             :error "file_not_found"
             :message (format "File does not exist: %s. Use write_file_in_scope to create new files." full-path))))

   ;; Check if file is git-tracked (git-safe editing)
   (unless (jf/gptel--file-is-git-tracked-p full-path)
     (cl-return-from nil
       (list :success nil
             :error "file_not_git_tracked"
             :message (format "Cannot edit file: %s is not tracked by git. This is a safety feature to prevent editing ignored files (node_modules, build artifacts, etc.). To edit this file, either: 1) Add it to git (git add %s), or 2) Use write_file_in_scope if you need to create/overwrite it." full-path filepath))))

   ;; Execute edit
   (let ((replaced nil))
     (with-temp-file full-path
       (insert-file-contents full-path)
       (goto-char (point-min))
       (if (search-forward old_string nil t)
           (progn
             (replace-match new_string t t)
             (setq replaced t))
         (cl-return-from nil
           (list :success nil
                 :error "string_not_found"
                 :message (format "String not found in file: '%s'" old_string)))))
     (when replaced
       (list :success t
             :full_path full-path
             :message "File edited successfully")))))
#+end_src

* Provide Feature

#+begin_src elisp
(provide 'jf-gptel-scope-filesystem-tools)
;;; scope-filesystem-tools.el ends here
#+end_src
