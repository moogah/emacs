#+title: GPTEL Scope Manager - Core Infrastructure
#+author: Jeff Farr
#+property: header-args:elisp :tangle scope-core.el :comments both

* Overview

This module provides the core infrastructure for scope-aware tools in gptel sessions. It implements:
- Generic =gptel-make-scoped-tool= macro that eliminates boilerplate
- Tool-specific validators for fine-grained permission control
- YAML plan parser/formatter for v2.0 tool-level permission format

** Architecture (v2.0)

The scope system uses YAML plan documents stored alongside context files:
- Location: Same directory as =session.md= (e.g., =~/.gptel/sessions/SESSION_ID/branches/main/scope-plan.yml=)
- Format: v2.0 YAML with tool-level permissions (write_file_in_scope, edit_file_in_scope, etc.)
- Default policy: Deny by default, explicit tool configuration required
- Convention: Filesystem is source of truth, no in-memory tracking needed

Example v2.0 structure:
#+begin_example yaml
version: "2.0"
tools:
  write_file_in_scope:
    allowed: true
    patterns: ["/project/**"]
    deny_patterns: ["**/.git/**"]

  read_file:
    allowed: true
    patterns: ["/**"]
    deny_patterns: ["**/.env"]
#+end_example

** Key Design Principles

1. *Tool-level permissions*: Each tool has independent configuration (write_file vs edit_file)
2. *Generic macro eliminates duplication*: =gptel-make-scoped-tool= handles all boilerplate
3. *Structured errors returned to LLM*: Tools return descriptive errors, not exceptions
4. *LLM mediates user communication*: No automatic prompts, LLM uses request_scope_expansion
5. *Read operations scope-controlled*: But templates grant permissive =/**= patterns by default

* Dependencies

#+begin_src elisp
(require 'cl-lib)
#+end_src

* Tool Categorization System

This section defines the mapping from tool names to validation strategies.

** Tool Category Constant

The core categorization system maps each tool to its validation strategy and operation type.

#+begin_src elisp
(defconst jf/gptel-scope--tool-categories
  '(;; Path-based: read operations
    ("read_file" . (:validation path :operation read))
    ("list_project_files" . (:validation path :operation read))
    ("list_project_directories" . (:validation path :operation read))
    ("search_project_content" . (:validation path :operation read))
    ("list_test_files" . (:validation path :operation read))
    ("find_related_test" . (:validation path :operation read))
    ("find_related_files" . (:validation path :operation read))
    ("check_ggtags_project" . (:validation path :operation read))
    ("find_definition" . (:validation path :operation read))
    ("find_references" . (:validation path :operation read))
    ("find_symbol" . (:validation path :operation read))
    ("get_node_at_position" . (:validation path :operation read))
    ("get_node_info" . (:validation path :operation read))
    ("get_node_context" . (:validation path :operation read))
    ("get_syntax_tree" . (:validation path :operation read))
    ("list_functions" . (:validation path :operation read))
    ("list_classes" . (:validation path :operation read))
    ("list_imports" . (:validation path :operation read))
    ("extract_definition" . (:validation path :operation read))
    ("query_nodes" . (:validation path :operation read))
    ("find_nodes_by_type" . (:validation path :operation read))
    ("find_nodes_in_range" . (:validation path :operation read))
    ("get_scope_structure" . (:validation path :operation read))
    ("explain_ggtags_indexing" . (:validation path :operation read))

    ;; Path-based: write operations
    ("write_file_in_scope" . (:validation path :operation write))
    ("edit_file_in_scope" . (:validation path :operation write))
    ("create_ggtags_project" . (:validation path :operation write))
    ("update_ggtags_project" . (:validation path :operation write))

    ;; Pattern-based: org-roam operations
    ("create_roam_node_in_scope" . (:validation pattern :operation write))
    ("add_roam_tags_in_scope" . (:validation pattern :operation write))
    ("link_roam_nodes_in_scope" . (:validation pattern :operation write))

    ;; Command-based: shell operations
    ("run_approved_command" . (:validation command :operation write))

    ;; Meta tools (always pass)
    ("PersistentAgent" . (:validation meta :operation delegate))
    ("request_scope_expansion" . (:validation meta :operation meta))
    ("inspect_scope_plan" . (:validation meta :operation meta)))
  "Tool â†’ validation strategy mapping.

Each tool maps to a plist with:
  :validation - Validation strategy (path, pattern, command, meta)
  :operation - Operation type (read, write, delegate, meta)

Validation strategies:
  path    - Validate against paths.read/write/deny lists
  pattern - Validate against org_roam_patterns
  command - Validate against shell_commands.allow/deny lists
  meta    - Always allowed (no validation)

Operation types:
  read     - Read-only access
  write    - Write/modify access
  delegate - Delegate to sub-agent
  meta     - Meta-operations (inspect scope, request expansion)")
#+end_src

* Tool Wrapper Macro

This section provides the generic wrapper macro that eliminates boilerplate code in scope-aware tools.

** Argument Normalization

Tool functions receive arguments as vectors (from JSON), but we need to work with lists internally.

#+begin_src elisp
(defun jf/gptel-scope--normalize-args (args)
  "Convert ARGS from vector to list if needed.
Tool functions receive vectors from JSON serialization."
  (if (vectorp args)
      (append args nil)
    args))
#+end_src

** Generic Scoped Tool Macro

This macro wraps the common pattern used by all scope-aware tools:
1. Get session ID
2. Load scope plan
3. Check plan exists
4. Validate tool permission
5. Execute tool body if allowed
6. Return formatted error if denied

#+begin_src elisp
(defmacro gptel-make-scoped-tool (name description args category &rest body)
  "Create a scope-aware gptel tool with automatic validation.

NAME: Tool name string (e.g., \"write_file_in_scope\")
DESCRIPTION: Tool description for LLM
ARGS: List of argument specs (same format as gptel-make-tool :args)
CATEGORY: Resource category (\"filesystem\", \"org_roam\", \"shell\")
BODY: Tool implementation - executed only if scope check passes

The macro automatically:
- Loads scope config from preset.md in current buffer's directory
- Checks tool permission using v3.0 validation
- Normalizes arguments (vector->list)
- Formats errors on scope violation
- Handles exceptions

BODY is executed with tool arguments available as variables and should
return the success result plist. The first argument in ARGS should be
the primary resource identifier (filepath, node-id, command, etc.)."
  (let* ((arg-names (mapcar (lambda (arg-spec)
                             (intern (plist-get arg-spec :name)))
                           (eval args)))
         (lambda-list arg-names))
    `(gptel-make-tool
      :name ,name
      :description ,description
      :args ,args
      :category ,category
      :function
      (lambda (&rest raw-args)
        (condition-case err
            (cl-block nil
              (let* ((normalized-args (jf/gptel-scope--normalize-args raw-args))
                   ,@(cl-mapcar (lambda (name idx)
                                 `(,name (nth ,idx normalized-args)))
                               arg-names
                               (number-sequence 0 (1- (length arg-names))))
                   (config (jf/gptel-scope--load-config)))

              ;; Check allow-once FIRST (before checking if config exists)
              ;; Allow-once permissions should work even if config loading fails
              (when (jf/gptel-scope--check-allow-once ,name normalized-args config)
                (cl-return-from nil (progn ,@body)))

              ;; Check config exists (only if allow-once didn't grant permission)
              (unless config
                (cl-return-from nil
                  (list :success nil
                        :error "no_scope_config"
                        :message "No scope configuration found in preset.md. Ensure preset.md has paths section.")))

              ;; Check tool permission
              (let ((check-result (jf/gptel-scope--check-tool-permission
                                  config ,name normalized-args)))
                (if (plist-get check-result :allowed)
                    ;; Execute tool body
                    (progn ,@body)

                  ;; Format and return error
                  ;; TODO: Trigger expansion UI instead of immediate return (Task #7)
                  (jf/gptel-scope--format-tool-error
                   ,name
                   (nth 0 normalized-args)  ; Primary resource (first arg)
                   check-result)))))

          ;; Handle unexpected errors
          (error
           (list :success nil
                 :error "tool_exception"
                 :message (format "Tool error: %s" (error-message-string err)))))))))
#+end_src

* Scope Configuration Location Convention

Tools locate scope configuration using a simple filesystem convention:

**Convention:** =preset.md= is always in the same directory as =session.md=

Scope configuration is stored in the YAML frontmatter of preset.md:
- =paths= section for filesystem/projectile/treesitter tools
- =org_roam_patterns= section for org-roam tools
- =shell_commands= section for shell command tools

This eliminates the need for complex lookups:
- No registry required
- No session ID tracking needed
- Filesystem is the source of truth

Tools execute in the context of the gptel buffer, which has the buffer-local variable
=jf/gptel--branch-dir= set during session initialization. The scope loading functions
use this to find the preset.md file in the same directory as the context file.

* Configuration Loading Functions

** Load Scope Configuration

Load and parse scope configuration from preset.md YAML frontmatter.

Convention: preset.md is always in the same directory as session.md.

#+begin_src elisp
(require 'yaml)  ; Emacs built-in YAML parser

(defun jf/gptel-scope--load-config ()
  "Load scope configuration from preset.md in current session directory.
Returns plist with:
  :paths-read - List of allowed read paths
  :paths-write - List of allowed write paths
  :paths-deny - List of denied paths
  :org-roam-patterns - Plist with :subdirectory, :tags, :node_ids
  :shell-commands - Plist with :allow and :deny lists

Uses buffer-local jf/gptel--branch-dir if available (set during session init),
otherwise falls back to buffer-file-name directory.

Returns nil if preset.md not found or can't be parsed."
  (condition-case err
      (let ((context-dir (or (and (boundp 'jf/gptel--branch-dir) jf/gptel--branch-dir)
                             (and (buffer-file-name)
                                  (file-name-directory (buffer-file-name))))))
        (when context-dir
          (let ((preset-file (expand-file-name "preset.md" context-dir)))
            (when (file-exists-p preset-file)
              (jf/gptel-scope--parse-preset-config preset-file)))))
    (error
     (message "Error loading scope config: %s" (error-message-string err))
     nil)))
#+end_src

** Parse Preset Configuration

Extract scope configuration from preset.md YAML frontmatter.

#+begin_src elisp
(defun jf/gptel-scope--parse-preset-config (preset-file)
  "Extract scope configuration from PRESET-FILE YAML frontmatter.
Returns plist with :paths-read, :paths-write, :paths-deny,
:org-roam-patterns, and :shell-commands."
  (with-temp-buffer
    (insert-file-contents preset-file)
    (goto-char (point-min))
    (when (re-search-forward "^---\n" nil t)
      (let ((yaml-start (point)))
        (when (re-search-forward "^---\n" nil t)
          (let* ((yaml-end (match-beginning 0))
                 (yaml-content (buffer-substring yaml-start yaml-end))
                 (parsed (yaml-parse-string yaml-content :object-type 'plist)))
            ;; Extract paths section
            (let ((paths (plist-get parsed :paths)))
              (list :paths-read (plist-get paths :read)
                    :paths-write (plist-get paths :write)
                    :paths-deny (plist-get paths :deny)
                    :org-roam-patterns (plist-get parsed :org_roam_patterns)
                    :shell-commands (plist-get parsed :shell_commands)))))))))
#+end_src

* Allow-Once Mechanism

Temporary permissions that last only for the current LLM response turn.

** Buffer-Local Allow-Once List

#+begin_src elisp
(defvar-local jf/gptel-scope--allow-once-list nil
  "List of (tool-name . resource) pairs allowed for current LLM turn.
Each entry grants temporary permission for one tool call to one resource.
Cleared automatically after LLM response completes via gptel-post-response-functions.")
#+end_src

** Check Allow-Once

#+begin_src elisp
(defun jf/gptel-scope--check-allow-once (tool-name args config)
  "Check if TOOL-NAME with ARGS is in allow-once list.
Extracts resource from ARGS based on tool category.
Returns t if found (and consumes the permission), nil otherwise.

CONFIG is the scope configuration (used to determine tool category)."
  (when jf/gptel-scope--allow-once-list
    (let* ((category (cdr (assoc tool-name jf/gptel-scope--tool-categories)))
           (validation-type (plist-get category :validation))
           (resource (pcase validation-type
                      ('path (expand-file-name (car args)))
                      ('pattern (format "%s:%s" tool-name (car args)))
                      ('command (car args))
                      (_ nil))))
      (when resource
        (when-let ((entry (assoc tool-name jf/gptel-scope--allow-once-list)))
          (when (equal (cdr entry) resource)
            ;; Consume permission (single-use)
            (setq jf/gptel-scope--allow-once-list
                  (delq entry jf/gptel-scope--allow-once-list))
            t))))))
#+end_src

** Add to Allow-Once List

#+begin_src elisp
(defun jf/gptel-scope--add-to-allow-once-list (tool-name resource)
  "Add TOOL-NAME and RESOURCE to allow-once list.
Permission is valid only for current LLM turn."
  (push (cons tool-name resource) jf/gptel-scope--allow-once-list))
#+end_src

** Clear Allow-Once After Response

#+begin_src elisp
(defun jf/gptel-scope--clear-allow-once (&rest _)
  "Clear allow-once list after LLM response completes.
Hooked into gptel-post-response-functions."
  (when (boundp 'jf/gptel-scope--allow-once-list)
    (setq-local jf/gptel-scope--allow-once-list nil)))

;; Hook into gptel response lifecycle
(add-hook 'gptel-post-response-functions #'jf/gptel-scope--clear-allow-once)
#+end_src

* Validation System (v3.0)

This section implements the v3.0 validation system with three strategies:
path-based, pattern-based, and command-based.

** Pattern Matching Helper

Check if a path matches any pattern in a list.

#+begin_src elisp
(defun jf/gptel-scope--matches-any-pattern (path patterns)
  "Check if PATH matches any pattern in PATTERNS list.
Returns t if any pattern matches, nil otherwise."
  (when patterns
    (cl-some (lambda (pattern)
              (jf/gptel-scope--matches-pattern path pattern))
            patterns)))
#+end_src

** Path-Based Validator

Validates filesystem, projectile, and treesitter tools against path lists.

#+begin_src elisp
(defun jf/gptel-scope--validate-path-tool (tool-name args category config)
  "Validate path-based tool against read/write/deny path lists.
TOOL-NAME is the tool being validated.
ARGS is the tool arguments list (first arg should be filepath).
CATEGORY is the tool category plist (:validation :operation).
CONFIG is the scope configuration plist.

Returns plist with:
  :allowed t/nil
  :reason STRING (if denied)
  :resource STRING (the filepath, if denied)
  :tool STRING (tool name, if denied)
  :allowed-patterns LIST (if denied for not matching)."
  (let* ((operation (plist-get category :operation))
         (filepath (car args))  ; First arg is always filepath
         (full-path (expand-file-name filepath))
         (read-paths (plist-get config :paths-read))
         (write-paths (plist-get config :paths-write))
         (deny-paths (plist-get config :paths-deny))
         (target-paths (if (eq operation 'read) read-paths write-paths)))

    ;; Check deny first (highest priority)
    (when (jf/gptel-scope--matches-any-pattern full-path deny-paths)
      (cl-return-from jf/gptel-scope--validate-path-tool
        (list :allowed nil
              :reason "denied-pattern"
              :resource full-path
              :tool tool-name)))

    ;; Check allow patterns
    (unless (jf/gptel-scope--matches-any-pattern full-path target-paths)
      (cl-return-from jf/gptel-scope--validate-path-tool
        (list :allowed nil
              :reason "not-in-scope"
              :resource full-path
              :tool tool-name
              :allowed-patterns target-paths)))

    ;; Passed
    (list :allowed t)))
#+end_src

** Pattern-Based Validator

Validates org-roam tools against org_roam_patterns section.

#+begin_src elisp
(defun jf/gptel-scope--validate-pattern-tool (tool-name args config)
  "Validate org-roam tool against org_roam_patterns section.
TOOL-NAME is the tool being validated.
ARGS is the tool arguments list (varies by tool).
CONFIG is the scope configuration plist.

Returns plist with:
  :allowed t/nil
  :reason STRING (if denied)
  :resource STRING (description of what was denied)
  :tool STRING (tool name, if denied)."
  (let ((org-roam-config (plist-get config :org-roam-patterns)))
    (pcase tool-name
      ("create_roam_node_in_scope"
       (let ((subdirectory (nth 1 args))  ; 2nd arg
             (tags (nth 2 args))          ; 3rd arg
             (allowed-subdirs (plist-get org-roam-config :subdirectory))
             (allowed-tags (plist-get org-roam-config :tags))
             (allowed nil))

         ;; Check subdirectory patterns (format: "gptel/**")
         (when (and subdirectory allowed-subdirs)
           (dolist (pattern allowed-subdirs)
             (when (string-match-p (jf/gptel-scope--glob-to-regex pattern)
                                 subdirectory)
               (setq allowed t))))

         ;; Check tag patterns (format: "gptel")
         (when (and tags allowed-tags)
           (dolist (tag tags)
             (when (member tag allowed-tags)
               (setq allowed t))))

         (if allowed
             (list :allowed t)
           (list :allowed nil
                 :reason "not-in-org-roam-patterns"
                 :resource (format "subdirectory:%s tags:%s"
                                 (or subdirectory "none")
                                 (or (mapconcat #'identity tags ",") "none"))
                 :tool tool-name))))

      ("add_roam_tags_in_scope"
       (let ((tags (nth 1 args))  ; 2nd arg
             (allowed-tags (plist-get org-roam-config :tags))
             (allowed nil))

         ;; Check tag patterns
         (when (and tags allowed-tags)
           (dolist (tag tags)
             (when (member tag allowed-tags)
               (setq allowed t))))

         (if allowed
             (list :allowed t)
           (list :allowed nil
                 :reason "not-in-org-roam-patterns"
                 :resource (format "tags:%s"
                                 (mapconcat #'identity tags ","))
                 :tool tool-name))))

      ("link_roam_nodes_in_scope"
       (let ((node-ids (plist-get org-roam-config :node_ids)))
         ;; Check if wildcard "*" is in allowed node_ids
         (if (member "*" node-ids)
             (list :allowed t)
           ;; Could extend to check specific node IDs here
           (list :allowed nil
                 :reason "not-in-org-roam-patterns"
                 :resource "node linking"
                 :tool tool-name))))

      (_
       ;; Unknown org-roam tool
       (list :allowed nil
             :reason "unknown-org-roam-tool"
             :resource tool-name
             :tool tool-name)))))
#+end_src

** Command-Based Validator

Validates shell commands against allowlist and denylist.

#+begin_src elisp
(defun jf/gptel-scope--validate-command-tool (tool-name args config)
  "Validate shell command against shell_commands allowlist/denylist.
TOOL-NAME is the tool being validated.
ARGS is the tool arguments list (first arg should be command string).
CONFIG is the scope configuration plist.

Returns plist with:
  :allowed t/nil
  :reason STRING (if denied)
  :resource STRING (the command, if denied)
  :tool STRING (tool name, if denied)
  :allowed-patterns LIST (allowlist, if denied for not matching)."
  (let* ((command-full (car args))
         (command-name (car (split-string command-full)))
         (shell-config (plist-get config :shell-commands))
         (allowed (plist-get shell-config :allow))
         (denied (plist-get shell-config :deny)))

    ;; Check deny patterns (substring matching)
    (when denied
      (dolist (deny-pattern denied)
        (when (string-match-p (regexp-quote deny-pattern) command-full)
          (cl-return-from jf/gptel-scope--validate-command-tool
            (list :allowed nil
                  :reason "denied-command"
                  :resource command-full
                  :tool tool-name)))))

    ;; Check allowlist (exact command name match or wildcard)
    (unless (or (member command-name allowed)
                (member "*" allowed))
      (cl-return-from jf/gptel-scope--validate-command-tool
        (list :allowed nil
              :reason "not-in-allowlist"
              :resource command-full
              :tool tool-name
              :allowed-patterns allowed)))

    ;; Passed
    (list :allowed t)))
#+end_src

** Tool Permission Dispatch

Central dispatcher that routes permission checks to tool-specific validators based on tool categories.

#+begin_src elisp
(defun jf/gptel-scope--check-tool-permission (config tool-name args)
  "Validate TOOL-NAME with ARGS against CONFIG.
CONFIG is the scope configuration plist from preset.md.
TOOL-NAME is the tool being validated.
ARGS is the tool arguments list.

Returns plist with:
  :allowed t/nil
  :reason STRING (if denied)
  :resource STRING (what was denied, if applicable)
  :tool STRING (tool name, if denied)
  :allowed-patterns LIST (if denied for not matching)."

  ;; Check allow-once first (highest priority)
  (when (jf/gptel-scope--check-allow-once tool-name args config)
    (cl-return-from jf/gptel-scope--check-tool-permission
      (list :allowed t :reason "allow-once")))

  ;; Lookup tool category
  (let* ((category (cdr (assoc tool-name jf/gptel-scope--tool-categories)))
         (validation-type (plist-get category :validation)))

    ;; Meta tools always pass
    (when (eq validation-type 'meta)
      (cl-return-from jf/gptel-scope--check-tool-permission
        (list :allowed t)))

    ;; Route to validator
    (pcase validation-type
      ('path (jf/gptel-scope--validate-path-tool tool-name args category config))
      ('pattern (jf/gptel-scope--validate-pattern-tool tool-name args config))
      ('command (jf/gptel-scope--validate-command-tool tool-name args config))
      (_
       ;; Unknown tool - deny by default
       (list :allowed nil
             :reason "unknown-tool"
             :resource tool-name
             :tool tool-name)))))
#+end_src



* Glob Pattern Matching

** Convert Glob to Regex

Convert glob patterns to regex, supporting =**=, =*=, and =?= wildcards.

#+begin_src elisp
(defun jf/gptel-scope--glob-to-regex (pattern)
  "Convert glob PATTERN to regex string.
Supports:
  ** - Match any characters including /
  *  - Match any characters except /
  ?  - Match single character"
  (let ((regex pattern))
    ;; Escape regex special characters (except * and ?)
    (setq regex (replace-regexp-in-string "[.+^$()\\[\\]{}|\\\\]" "\\\\\\&" regex))
    ;; Convert glob wildcards to regex
    (setq regex (replace-regexp-in-string "\\*\\*" "DOUBLESTAR" regex))
    (setq regex (replace-regexp-in-string "\\*" "[^/]*" regex))
    (setq regex (replace-regexp-in-string "DOUBLESTAR" ".*" regex))
    (setq regex (replace-regexp-in-string "\\?" "." regex))
    ;; Anchor pattern
    (concat "^" regex "$")))
#+end_src

** Test Path Against Pattern

Check if a path matches a glob pattern.

#+begin_src elisp
(defun jf/gptel-scope--matches-pattern (path pattern)
  "Check if PATH matches glob PATTERN.
Expands relative paths to absolute, resolves symlinks."
  (let* ((abs-path (expand-file-name path))
         (real-path (file-truename abs-path))
         (expanded-pattern (expand-file-name pattern))
         (regex (jf/gptel-scope--glob-to-regex expanded-pattern)))
    (or (string-match-p regex real-path)
        (string-match-p regex abs-path))))
#+end_src


* Error Formatting

** Format Tool Error

Create standardized error response for tool-level permission violations.

#+begin_src elisp
(defun jf/gptel-scope--format-tool-error (tool-name resource check-result)
  "Format tool permission error for LLM.
TOOL-NAME: Name of the tool that was denied
RESOURCE: The resource that was denied (path, node-id, command, etc.)
CHECK-RESULT: Plist from validator with :allowed, :patterns, :deny_patterns"
  (let ((patterns (plist-get check-result :patterns))
        (deny-patterns (plist-get check-result :deny_patterns))
        (error-type (or (plist-get check-result :error) "scope_violation"))
        (custom-message (plist-get check-result :message)))
    (list :success nil
          :error error-type
          :tool tool-name
          :resource resource
          :allowed_patterns patterns
          :deny_patterns deny-patterns
          :message (or custom-message
                      (format "Tool '%s' denied for resource '%s'. Use request_scope_expansion to ask user for approval."
                             tool-name
                             resource)))))
#+end_src

* Vector to List Conversion

Helper function to convert vectors to lists in parsed YAML structures.
YAML parser returns vectors for arrays, but elisp code expects lists.

#+begin_src elisp
(defun jf/gptel-scope--vectorp-to-list (obj)
  "Recursively convert vectors to lists in OBJ (plist or nested structure)."
  (cond
   ;; Vector: convert to list and recurse
   ((vectorp obj)
    (mapcar #'jf/gptel-scope--vectorp-to-list (append obj nil)))

   ;; List: recurse on each element
   ((listp obj)
    (mapcar #'jf/gptel-scope--vectorp-to-list obj))

   ;; Other: return as-is
   (t obj)))
#+end_src

* Preset Path Updater

Helper function for updating paths section in preset.md files.

#+begin_src elisp
(defun jf/gptel-scope--update-preset-paths (preset-file allowed-paths denied-paths)
  "Update paths section in PRESET-FILE with ALLOWED-PATHS and DENIED-PATHS.
PRESET-FILE is the path to a preset.md file.
ALLOWED-PATHS is a list of glob patterns for allowed file access.
DENIED-PATHS is a list of glob patterns to deny.

If ALLOWED-PATHS is nil or empty, creates deny-all configuration (empty path lists).

This function parses the YAML frontmatter, updates or adds the paths section,
and writes the modified content back to the file."
  (let ((content (with-temp-buffer
                   (insert-file-contents preset-file)
                   (buffer-string))))

    ;; Find the YAML frontmatter boundaries
    (with-temp-buffer
      (insert content)
      (goto-char (point-min))

      (unless (re-search-forward "^---\n" nil t)
        (error "No YAML frontmatter found in %s" preset-file))

      (let ((yaml-start (point)))
        (save-match-data
          (message "DEBUG: Found opening --- at position %d (line %d)" (point) (line-number-at-pos)))
        (unless (re-search-forward "^---\n" nil t)
          (error "No closing delimiter for YAML frontmatter in %s" preset-file))

        ;; CRITICAL: Save match positions BEFORE any message/logging that might clobber them
        (let* ((yaml-end (match-beginning 0))
               (post-yaml-start (match-end 0))
               (yaml-content (buffer-substring yaml-start yaml-end))
               (parsed (jf/gptel-scope--vectorp-to-list
                       (yaml-parse-string yaml-content :object-type 'plist)))
               (post-yaml (buffer-substring post-yaml-start (point-max))))
          (save-match-data
            (message "DEBUG: post-yaml extracted from %d, length=%d bytes" post-yaml-start (length post-yaml)))

          ;; Update or add paths section
          (setq parsed (plist-put parsed :paths
                                  (list :read (or allowed-paths '())
                                        :write '("/tmp/**")
                                        :deny (or denied-paths
                                                 '("**/.git/**"
                                                   "**/runtime/**"
                                                   "**/.env"
                                                   "**/node_modules/**")))))

          ;; Reconstruct the file
          (erase-buffer)
          (insert "---\n")

          ;; Write YAML frontmatter (simple plist serialization)
          (message "DEBUG: Serializing parsed plist keys: %S" (cl-loop for (k v) on parsed by #'cddr collect k))
          (cl-loop for (key value) on parsed by #'cddr
                   do (let ((key-name (substring (symbol-name key) 1)))
                        (message "DEBUG: Processing key=%s value-type=%s" key-name (type-of value))
                        (cond
                         ;; Handle paths specially (nested structure)
                         ((eq key :paths)
                          (insert (format "%s:\n" key-name))
                          (cl-loop for (subkey subvalue) on value by #'cddr
                                   do (let ((subkey-name (substring (symbol-name subkey) 1)))
                                        (insert (format "  %s:\n" subkey-name))
                                        (if subvalue
                                            (dolist (item subvalue)
                                              (insert (format "    - \"%s\"\n" item)))
                                          (insert "    []\n")))))

                         ;; Handle tools section (list or vector of tool names)
                         ((eq key :tools)
                          (insert (format "%s:\n" key-name))
                          ;; YAML parser returns vectors for lists, so check for both
                          ;; tools can be a list ("PersistentAgent" ...) or vector ["PersistentAgent" ...]
                          (if (and value (sequencep value) (not (stringp value)) (> (length value) 0))
                              (seq-do (lambda (tool-name)
                                        (when (stringp tool-name)
                                          (insert (format "  - %s\n" tool-name))))
                                      value)
                            ;; Empty or null tools - write empty list
                            (insert "  []\n")))

                         ;; Handle org_roam_patterns section
                         ((eq key :org_roam_patterns)
                          (insert (format "%s:\n" key-name))
                          (cl-loop for (subkey subvalue) on value by #'cddr
                                   do (let ((subkey-name (substring (symbol-name subkey) 1)))
                                        (insert (format "  %s:\n" subkey-name))
                                        (dolist (item subvalue)
                                          (insert (format "    - \"%s\"\n" item))))))

                         ;; Handle shell_commands section
                         ((eq key :shell_commands)
                          (insert (format "%s:\n" key-name))
                          (cl-loop for (subkey subvalue) on value by #'cddr
                                   do (let ((subkey-name (substring (symbol-name subkey) 1)))
                                        (insert (format "  %s:\n" subkey-name))
                                        (dolist (item subvalue)
                                          (insert (format "    - \"%s\"\n" item))))))

                         ;; Simple key-value pairs
                         ((stringp value)
                          (insert (format "%s: \"%s\"\n" key-name value)))
                         ((numberp value)
                          (insert (format "%s: %s\n" key-name value)))
                         ((symbolp value)
                          (insert (format "%s: %s\n" key-name value)))
                         ;; Simple lists (but not plists which are already handled above)
                         ((and (listp value) (not (keywordp (car-safe value))))
                          (insert (format "%s:\n" key-name))
                          (dolist (item value)
                            (insert (format "  - %s\n" item))))
                         ;; Skip anything else (already handled or unsupported)
                         (t nil))))

          (insert "---\n")
          (let ((before-post-yaml-size (- (point-max) (point-min))))
            (message "DEBUG: Buffer size before post-yaml=%d" before-post-yaml-size)
            (message "DEBUG: About to insert post-yaml, length=%d, first 100 chars: %S"
                     (length post-yaml)
                     (substring post-yaml 0 (min 100 (length post-yaml))))
            (insert post-yaml)
            (let ((final-size (- (point-max) (point-min))))
              (message "DEBUG: Final buffer size=%d (before=%d + post-yaml=%d = expected %d)"
                       final-size before-post-yaml-size (length post-yaml)
                       (+ before-post-yaml-size (length post-yaml)))))

          ;; Write back to file
          (write-region (point-min) (point-max) preset-file nil 'silent))))))
#+end_src

* Provide Feature

#+begin_src elisp
(provide 'jf-gptel-scope-core)
;;; scope-core.el ends here
#+end_src
