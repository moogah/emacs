#+title: GPTEL Scope Manager - Core Infrastructure
#+author: Jeff Farr
#+property: header-args:elisp :tangle scope-core.el :comments both

* Overview

This module provides the core infrastructure for scope-aware tools in gptel sessions. It implements shared validation functions used by all scope-aware tools to check operations against scope plans.

** Architecture

The scope system uses YAML plan documents stored in session directories:
- Location: =~/gptel-sessions/SESSION_ID/scope-plan.yml=
- Format: YAML with filesystem, org-roam, and shell sections
- Default policy: Deny by default

** Key Design Principles

1. *Scope-aware tools check internally*: Each tool validates before execution
2. *Structured errors returned to LLM*: Tools return descriptive errors, not exceptions
3. *LLM mediates user communication*: No automatic prompts, LLM asks user when needed
4. *Read operations always allowed*: Only write operations require scope checking

* Dependencies

#+begin_src elisp
(require 'cl-lib)
#+end_src

* Global State

Tools need access to the current session ID, but =jf/gptel--session-id= is buffer-local. We use a dynamically-scoped global variable that gets set during request execution.

#+begin_src elisp
(defvar jf/gptel-scope--current-session-id nil
  "Dynamically-bound session ID for tool execution.
Set by advice on gptel-request before tools execute.")

(defun jf/gptel-scope--get-session-id ()
  "Get current session ID for tool execution.
Tries multiple sources in order:
1. Dynamic variable (set during tool execution)
2. Buffer-local variable (if in gptel buffer)
3. Returns nil if no session found"
  (or jf/gptel-scope--current-session-id
      (and (boundp 'jf/gptel--session-id) jf/gptel--session-id)))

(defun jf/gptel-scope--set-session-context (orig-fn &rest args)
  "Advice to set session ID from context before tool execution."
  (let* ((context (plist-get args :context))
         (session-id (cond
                      ((null context) nil)
                      ((overlayp context) (overlay-get context 'jf/session-id))
                      ((and (listp context) (keywordp (car context)))
                       (plist-get context :session-id))
                      (t nil)))
         (jf/gptel-scope--current-session-id session-id))
    (apply orig-fn args)))

(advice-add 'gptel-request :around #'jf/gptel-scope--set-session-context)
#+end_src

* Plan Document Functions

** Load Scope Plan

Load and parse the YAML scope plan for a session.

Note: Session directory lookups work differently depending on whether the session is in the in-memory registry or needs to be found on disk.

#+begin_src elisp
(defun jf/gptel-scope--load-plan (session-id)
  "Load scope plan for SESSION-ID from session directory.
Returns parsed plan as plist or nil if not found."
  (condition-case err
      (when-let* ((session (jf/gptel-session-find session-id))
                  (session-dir (plist-get session :directory)))
        (let ((plan-file (expand-file-name "scope-plan.yml" session-dir)))
          (when (file-exists-p plan-file)
            (with-temp-buffer
              (insert-file-contents plan-file)
              (jf/gptel-scope--parse-yaml (buffer-string))))))
    (error
     (message "Error loading scope plan: %s" (error-message-string err))
     nil)))
#+end_src

** Save Scope Plan

Write updated scope plan back to YAML file.

#+begin_src elisp
(defun jf/gptel-scope--save-plan (session-id plan)
  "Save PLAN for SESSION-ID to session directory.
Updates timestamp and writes formatted YAML."
  (when-let* ((session (jf/gptel-session-find session-id))
              (session-dir (plist-get session :directory)))
    (let ((plan-file (expand-file-name "scope-plan.yml" session-dir)))
      ;; Update timestamp
      (plist-put plan :updated (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
      ;; Write YAML
      (with-temp-file plan-file
        (insert (jf/gptel-scope--format-yaml plan)))
      t)))
#+end_src

** Parse YAML to Plist

Simple YAML parser for scope plans. Handles basic YAML structure with indentation.

#+begin_src elisp
(defun jf/gptel-scope--parse-yaml (yaml-string)
  "Parse YAML-STRING into nested plist structure.
Handles basic YAML with indentation for nested sections."
  (let ((lines (split-string yaml-string "\n"))
        (result nil)
        (current-section nil)
        (current-subsection nil))
    (dolist (line lines)
      (when (string-match "^\\([a-z_]+\\):\\s-*\\(.*\\)$" line)
        ;; Top-level key
        (let* ((key (intern (concat ":" (match-string 1 line))))
               (raw-value (match-string 2 line))
               ;; Strip quotes from values
               (value (if (string-match "^\"\\(.*\\)\"$" raw-value)
                         (match-string 1 raw-value)
                       raw-value)))
          (if (or (string-empty-p raw-value) (string= value "[]"))
              (progn
                (setq current-section key)
                (setq result (plist-put result key nil)))
            (setq result (plist-put result key value)))))
      (when (string-match "^  \\([a-z_]+\\):\\s-*\\(.*\\)$" line)
        ;; Second-level key (indented 2 spaces)
        (let* ((key (intern (concat ":" (match-string 1 line))))
               (raw-value (match-string 2 line))
               ;; Strip quotes from values
               (value (if (string-match "^\"\\(.*\\)\"$" raw-value)
                         (match-string 1 raw-value)
                       raw-value)))
          (if (or (string-empty-p raw-value) (string= value "[]"))
              (progn
                (setq current-subsection key)
                (let ((section-data (or (plist-get result current-section) nil)))
                  (setq section-data (plist-put section-data key nil))
                  (setq result (plist-put result current-section section-data))))
            (let ((section-data (or (plist-get result current-section) nil)))
              (setq section-data (plist-put section-data key value))
              (setq result (plist-put result current-section section-data))))))
      (when (string-match "^    - \"?\\([^\"]+\\)\"?$" line)
        ;; List item (indented 4 spaces)
        (let* ((item (match-string 1 line))
               (section-data (plist-get result current-section))
               (subsection-data (or (plist-get section-data current-subsection) nil))
               (updated-list (append subsection-data (list item))))
          (setq section-data (plist-put section-data current-subsection updated-list))
          (setq result (plist-put result current-section section-data)))))
    result))
#+end_src

** Format Plist to YAML

Convert plist back to YAML format for writing.

#+begin_src elisp
(defun jf/gptel-scope--format-yaml (plan)
  "Format PLAN plist as YAML string."
  (with-temp-buffer
    ;; Top-level scalars
    (insert (format "version: \"%s\"\n" (plist-get plan :version)))
    (insert (format "session_id: \"%s\"\n" (plist-get plan :session_id)))
    (insert (format "created: \"%s\"\n" (plist-get plan :created)))
    (insert (format "updated: \"%s\"\n" (plist-get plan :updated)))
    (insert (format "default_policy: %s\n\n" (plist-get plan :default_policy)))

    ;; Filesystem section
    (insert "filesystem:\n")
    (let ((fs-data (plist-get plan :filesystem)))
      (insert "  write:\n")
      (dolist (pattern (plist-get fs-data :write))
        (insert (format "    - \"%s\"\n" pattern)))
      (insert "  deny:\n")
      (dolist (pattern (plist-get fs-data :deny))
        (insert (format "    - \"%s\"\n" pattern))))

    ;; Org-roam section
    (insert "\norg_roam:\n")
    (let ((roam-data (plist-get plan :org_roam)))
      (insert "  write:\n")
      (dolist (pattern (plist-get roam-data :write))
        (insert (format "    - \"%s\"\n" pattern)))
      (insert "  link:\n")
      (dolist (pattern (plist-get roam-data :link))
        (insert (format "    - \"%s\"\n" pattern))))

    ;; Shell section
    (insert "\nshell:\n")
    (let ((shell-data (plist-get plan :shell)))
      (insert "  allow_commands:\n")
      (dolist (cmd (plist-get shell-data :allow_commands))
        (insert (format "    - \"%s\"\n" cmd)))
      (insert "  deny_commands:\n")
      (dolist (cmd (plist-get shell-data :deny_commands))
        (insert (format "    - \"%s\"\n" cmd))))

    (buffer-string)))
#+end_src

* Glob Pattern Matching

** Convert Glob to Regex

Convert glob patterns to regex, supporting =**=, =*=, and =?= wildcards.

#+begin_src elisp
(defun jf/gptel-scope--glob-to-regex (pattern)
  "Convert glob PATTERN to regex string.
Supports:
  ** - Match any characters including /
  *  - Match any characters except /
  ?  - Match single character"
  (let ((regex pattern))
    ;; Escape regex special characters (except * and ?)
    (setq regex (replace-regexp-in-string "[.+^$()\\[\\]{}|\\\\]" "\\\\\\&" regex))
    ;; Convert glob wildcards to regex
    (setq regex (replace-regexp-in-string "\\*\\*" "DOUBLESTAR" regex))
    (setq regex (replace-regexp-in-string "\\*" "[^/]*" regex))
    (setq regex (replace-regexp-in-string "DOUBLESTAR" ".*" regex))
    (setq regex (replace-regexp-in-string "\\?" "." regex))
    ;; Anchor pattern
    (concat "^" regex "$")))
#+end_src

** Test Path Against Pattern

Check if a path matches a glob pattern.

#+begin_src elisp
(defun jf/gptel-scope--matches-pattern (path pattern)
  "Check if PATH matches glob PATTERN.
Expands relative paths to absolute, resolves symlinks."
  (let* ((abs-path (expand-file-name path))
         (real-path (file-truename abs-path))
         (expanded-pattern (expand-file-name pattern))
         (regex (jf/gptel-scope--glob-to-regex expanded-pattern)))
    (or (string-match-p regex real-path)
        (string-match-p regex abs-path))))
#+end_src

* Scope Validation Functions

** Check Filesystem Write Scope

Validate filesystem write operation against scope plan.

#+begin_src elisp
(defun jf/gptel-scope--check-filesystem-write (plan path)
  "Check if PATH is allowed for write operations in PLAN.
Returns plist with :allowed t/nil and relevant patterns."
  (let* ((fs-data (plist-get plan :filesystem))
         (write-patterns (plist-get fs-data :write))
         (deny-patterns (plist-get fs-data :deny))
         (allowed-by-write nil)
         (denied-explicitly nil))

    ;; Check deny patterns first (they override)
    (dolist (pattern deny-patterns)
      (when (jf/gptel-scope--matches-pattern path pattern)
        (setq denied-explicitly t)))

    ;; Check write patterns
    (dolist (pattern write-patterns)
      (when (jf/gptel-scope--matches-pattern path pattern)
        (setq allowed-by-write t)))

    ;; Return result
    (if (and allowed-by-write (not denied-explicitly))
        (list :allowed t)
      (list :allowed nil
            :allowed_patterns write-patterns
            :deny_patterns deny-patterns))))
#+end_src

** Check Org-Roam Write Scope

Validate org-roam write operation against scope plan.

#+begin_src elisp
(defun jf/gptel-scope--check-org-roam-write (plan subdirectory tags)
  "Check if org-roam write with SUBDIRECTORY and TAGS is allowed in PLAN.
Returns plist with :allowed t/nil and relevant patterns."
  (let* ((roam-data (plist-get plan :org_roam))
         (write-patterns (plist-get roam-data :write))
         (allowed nil))

    ;; Check subdirectory patterns (format: "subdirectory:path/**")
    (when subdirectory
      (dolist (pattern write-patterns)
        (when (string-prefix-p "subdirectory:" pattern)
          (let ((subdir-pattern (substring pattern 13)))  ; Strip "subdirectory:" prefix
            (when (string-match-p (jf/gptel-scope--glob-to-regex subdir-pattern) subdirectory)
              (setq allowed t))))))

    ;; Check tag patterns (format: "tag:tagname")
    (when tags
      (dolist (tag tags)
        (dolist (pattern write-patterns)
          (when (string= pattern (concat "tag:" tag))
            (setq allowed t)))))

    ;; Return result
    (if allowed
        (list :allowed t)
      (list :allowed nil
            :allowed_patterns write-patterns))))
#+end_src

** Check Shell Command Scope

Validate shell command against scope plan.

#+begin_src elisp
(defun jf/gptel-scope--check-shell-command (plan command)
  "Check if COMMAND is allowed in PLAN.
Returns plist with :allowed t/nil and relevant patterns."
  (let* ((shell-data (plist-get plan :shell))
         (allow-commands (plist-get shell-data :allow_commands))
         (deny-commands (plist-get shell-data :deny_commands))
         (cmd-name (car (split-string command)))
         (allowed nil)
         (denied nil))

    ;; Check deny patterns (substring matching)
    (dolist (deny-pattern deny-commands)
      (when (string-match-p (regexp-quote deny-pattern) command)
        (setq denied t)))

    ;; Check allow patterns (exact command name)
    (dolist (allow-pattern allow-commands)
      (when (string= cmd-name allow-pattern)
        (setq allowed t)))

    ;; Return result
    (if (and allowed (not denied))
        (list :allowed t)
      (list :allowed nil
            :allowed_commands allow-commands
            :deny_commands deny-commands))))
#+end_src

* Error Formatting

** Format Scope Violation Error

Create standardized error response for scope violations.

#+begin_src elisp
(defun jf/gptel-scope--format-error (resource-type operation resource check-result)
  "Format scope violation error for LLM.
RESOURCE-TYPE: filesystem, org_roam, or shell
OPERATION: write, link, exec, etc.
RESOURCE: The path/node/command that was denied
CHECK-RESULT: Plist from scope check function"
  (let ((allowed-patterns (plist-get check-result :allowed_patterns))
        (deny-patterns (plist-get check-result :deny_patterns))
        (allowed-commands (plist-get check-result :allowed_commands))
        (deny-commands (plist-get check-result :deny_commands)))
    (list :success nil
          :error "scope_violation"
          :resource resource
          :resource_type resource-type
          :operation operation
          :allowed_patterns allowed-patterns
          :deny_patterns deny-patterns
          :allowed_commands allowed-commands
          :deny_commands deny-commands
          :message (format "%s operation to '%s' denied by scope plan. Use request_scope_expansion tool to ask user for approval."
                          (capitalize operation)
                          resource))))
#+end_src

* Provide Feature

#+begin_src elisp
(provide 'jf-gptel-scope-core)
;;; scope-core.el ends here
#+end_src
