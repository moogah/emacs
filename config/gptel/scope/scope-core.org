#+title: GPTEL Scope Manager - Core Infrastructure
#+author: Jeff Farr
#+property: header-args:elisp :tangle scope-core.el :comments both

* Overview

This module provides the core infrastructure for scope-aware tools in gptel sessions. It implements:
- Generic =gptel-make-scoped-tool= macro that eliminates boilerplate
- Tool-specific validators for fine-grained permission control
- YAML plan parser/formatter for v2.0 tool-level permission format

** Architecture (v2.0)

The scope system uses YAML plan documents stored in session directories:
- Location: =~/.gptel/sessions/SESSION_ID/scope-plan.yml=
- Format: v2.0 YAML with tool-level permissions (write_file_in_scope, edit_file_in_scope, etc.)
- Default policy: Deny by default, explicit tool configuration required

Example v2.0 structure:
#+begin_example yaml
version: "2.0"
tools:
  write_file_in_scope:
    allowed: true
    patterns: ["/project/**"]
    deny_patterns: ["**/.git/**"]

  read_file:
    allowed: true
    patterns: ["/**"]
    deny_patterns: ["**/.env"]
#+end_example

** Key Design Principles

1. *Tool-level permissions*: Each tool has independent configuration (write_file vs edit_file)
2. *Generic macro eliminates duplication*: =gptel-make-scoped-tool= handles all boilerplate
3. *Structured errors returned to LLM*: Tools return descriptive errors, not exceptions
4. *LLM mediates user communication*: No automatic prompts, LLM uses request_scope_expansion
5. *Read operations scope-controlled*: But templates grant permissive =/**= patterns by default

* Dependencies

#+begin_src elisp
(require 'cl-lib)
#+end_src

* Tool Wrapper Macro

This section provides the generic wrapper macro that eliminates boilerplate code in scope-aware tools.

** Argument Normalization

Tool functions receive arguments as vectors (from JSON), but we need to work with lists internally.

#+begin_src elisp
(defun jf/gptel-scope--normalize-args (args)
  "Convert ARGS from vector to list if needed.
Tool functions receive vectors from JSON serialization."
  (if (vectorp args)
      (append args nil)
    args))
#+end_src

** Generic Scoped Tool Macro

This macro wraps the common pattern used by all scope-aware tools:
1. Get session ID
2. Load scope plan
3. Check plan exists
4. Validate tool permission
5. Execute tool body if allowed
6. Return formatted error if denied

#+begin_src elisp
(defmacro gptel-make-scoped-tool (name description args category &rest body)
  "Create a scope-aware gptel tool with automatic validation.

NAME: Tool name string (e.g., \"write_file_in_scope\")
DESCRIPTION: Tool description for LLM
ARGS: List of argument specs (same format as gptel-make-tool :args)
CATEGORY: Resource category (\"filesystem\", \"org_roam\", \"shell\")
BODY: Tool implementation - executed only if scope check passes

The macro automatically:
- Retrieves session ID
- Loads scope plan
- Checks tool permission
- Normalizes arguments (vector->list)
- Formats errors on scope violation
- Handles exceptions

BODY is executed with tool arguments available as variables and should
return the success result plist. The first argument in ARGS should be
the primary resource identifier (filepath, node-id, command, etc.)."
  (let* ((arg-names (mapcar (lambda (arg-spec)
                             (intern (plist-get arg-spec :name)))
                           (eval args)))
         (lambda-list arg-names))
    `(gptel-make-tool
      :name ,name
      :description ,description
      :args ,args
      :category ,category
      :function
      (lambda (&rest raw-args)
        (condition-case err
            (let* ((normalized-args (jf/gptel-scope--normalize-args raw-args))
                   ,@(cl-mapcar (lambda (name idx)
                                 `(,name (nth ,idx normalized-args)))
                               arg-names
                               (number-sequence 0 (1- (length arg-names))))
                   (session-id (jf/gptel-scope--get-session-id))
                   (plan (jf/gptel-scope--load-plan session-id)))

              ;; Check plan exists
              (unless plan
                (cl-return-from nil
                  (list :success nil
                        :error "no_scope_plan"
                        :message "No scope plan found for this session. Create one with M-x jf/gptel-scope-init-plan or ask user to create one.")))

              ;; Check tool permission
              (let ((check-result (jf/gptel-scope--check-tool-permission
                                  plan ,name normalized-args)))
                (if (plist-get check-result :allowed)
                    ;; Execute tool body
                    (progn ,@body)

                  ;; Format and return error
                  (jf/gptel-scope--format-tool-error
                   ,name
                   (nth 0 normalized-args)  ; Primary resource (first arg)
                   check-result))))

          ;; Handle unexpected errors
          (error
           (list :success nil
                 :error "tool_exception"
                 :message (format "Tool error: %s" (error-message-string err)))))))))
#+end_src

* Global State

Tools need access to the current session ID, but =jf/gptel--session-id= is buffer-local. We use a dynamically-scoped global variable that gets set during request execution.

#+begin_src elisp
(defvar jf/gptel-scope--current-session-id nil
  "Dynamically-bound session ID for tool execution.
Set by advice on gptel-request before tools execute.")

(defun jf/gptel-scope--get-session-id ()
  "Get current session ID for tool execution.
Tries multiple sources in order:
1. Dynamic variable (set during tool execution)
2. Buffer-local variable (if in gptel buffer)
3. Returns nil if no session found"
  (or jf/gptel-scope--current-session-id
      (and (boundp 'jf/gptel--session-id) jf/gptel--session-id)))

(defun jf/gptel-scope--set-session-context (orig-fn &rest args)
  "Advice to set session ID from context before tool execution."
  (let* ((context (plist-get args :context))
         (session-id (cond
                      ((null context) nil)
                      ((overlayp context) (overlay-get context 'jf/session-id))
                      ((and (listp context) (keywordp (car context)))
                       (plist-get context :session-id))
                      (t nil)))
         (jf/gptel-scope--current-session-id session-id))
    (apply orig-fn args)))

(advice-add 'gptel-request :around #'jf/gptel-scope--set-session-context)
#+end_src

* Plan Document Functions

** Load Scope Plan

Load and parse the YAML scope plan for a session.

Note: Session directory lookups work differently depending on whether the session is in the in-memory registry or needs to be found on disk.

#+begin_src elisp
(defun jf/gptel-scope--load-plan (session-id)
  "Load scope plan for SESSION-ID from session directory.
Returns parsed plan as plist or nil if not found."
  (condition-case err
      (when-let* ((session (jf/gptel-session-find session-id))
                  (session-dir (plist-get session :directory)))
        (let ((plan-file (expand-file-name "scope-plan.yml" session-dir)))
          (when (file-exists-p plan-file)
            (with-temp-buffer
              (insert-file-contents plan-file)
              (jf/gptel-scope--parse-yaml (buffer-string))))))
    (error
     (message "Error loading scope plan: %s" (error-message-string err))
     nil)))
#+end_src

** Save Scope Plan

Write updated scope plan back to YAML file.

#+begin_src elisp
(defun jf/gptel-scope--save-plan (session-id plan)
  "Save PLAN for SESSION-ID to session directory.
Updates timestamp and writes formatted YAML."
  (when-let* ((session (jf/gptel-session-find session-id))
              (session-dir (plist-get session :directory)))
    (let ((plan-file (expand-file-name "scope-plan.yml" session-dir)))
      ;; Update timestamp
      (plist-put plan :updated (format-time-string "%Y-%m-%dT%H:%M:%SZ"))
      ;; Write YAML
      (with-temp-file plan-file
        (insert (jf/gptel-scope--format-yaml plan)))
      t)))
#+end_src

** Parse YAML to Plist

YAML parser for v2.0 scope plans with tool-level permissions.

#+begin_src elisp
(defun jf/gptel-scope--parse-yaml (yaml-string)
  "Parse YAML-STRING into nested plist structure.
Supports v2.0 tool-based format with nested sections up to 4 levels deep."
  (let ((lines (split-string yaml-string "\n"))
        (result nil)
        (current-section nil)       ;; Level 1 (e.g., :tools)
        (current-subsection nil)    ;; Level 2 (e.g., tool name like :write_file_in_scope)
        (current-subsubsection nil));; Level 3 (e.g., :patterns, :deny_patterns)

    (dolist (line lines)
      ;; Top-level key (no indentation)
      (when (string-match "^\\([a-z_]+\\):\\s-*\\(.*\\)$" line)
        (let* ((key (intern (concat ":" (match-string 1 line))))
               (raw-value (match-string 2 line))
               (value (if (string-match "^\"\\(.*\\)\"$" raw-value)
                         (match-string 1 raw-value)
                       raw-value)))
          (setq current-section key)
          (setq current-subsection nil)
          (setq current-subsubsection nil)
          (if (or (string-empty-p raw-value) (string= value "[]"))
              (setq result (plist-put result key nil))
            (setq result (plist-put result key value)))))

      ;; Second-level key (2 spaces) - tool names
      (when (string-match "^  \\([a-z_]+\\):\\s-*\\(.*\\)$" line)
        (let* ((key (intern (concat ":" (match-string 1 line))))
               (raw-value (match-string 2 line))
               (value (if (string-match "^\"\\(.*\\)\"$" raw-value)
                         (match-string 1 raw-value)
                       raw-value))
               (section-data (or (plist-get result current-section) nil)))
          (setq current-subsection key)
          (setq current-subsubsection nil)
          (if (or (string-empty-p raw-value) (string= value "[]"))
              (progn
                (setq section-data (plist-put section-data key nil))
                (setq result (plist-put result current-section section-data)))
            (setq section-data (plist-put section-data key value))
            (setq result (plist-put result current-section section-data)))))

      ;; Third-level key (4 spaces) - tool properties (allowed, patterns, deny_patterns)
      (when (string-match "^    \\([a-z_]+\\):\\s-*\\(.*\\)$" line)
        (let* ((key (intern (concat ":" (match-string 1 line))))
               (raw-value (match-string 2 line))
               (value (cond
                      ((string-match "^\"\\(.*\\)\"$" raw-value)
                       (match-string 1 raw-value))
                      ((string= raw-value "true") t)
                      ((string= raw-value "false") nil)
                      (t raw-value)))
               (section-data (plist-get result current-section))
               (subsection-data (or (plist-get section-data current-subsection) nil)))
          (setq current-subsubsection key)
          (if (or (string-empty-p raw-value) (string= value "[]"))
              (progn
                (setq subsection-data (plist-put subsection-data key nil))
                (setq section-data (plist-put section-data current-subsection subsection-data))
                (setq result (plist-put result current-section section-data)))
            (setq subsection-data (plist-put subsection-data key value))
            (setq section-data (plist-put section-data current-subsection subsection-data))
            (setq result (plist-put result current-section section-data)))))

      ;; List items (6-space indent) - pattern lists
      (when (and current-subsubsection
                (string-match "^      - \"?\\([^\"]+\\)\"?$" line))
        (let* ((item (match-string 1 line))
               (section-data (plist-get result current-section))
               (subsection-data (plist-get section-data current-subsection))
               (subsubsection-data (or (plist-get subsection-data current-subsubsection) nil))
               (updated-list (append subsubsection-data (list item))))
          (setq subsection-data (plist-put subsection-data current-subsubsection updated-list))
          (setq section-data (plist-put section-data current-subsection subsection-data))
          (setq result (plist-put result current-section section-data)))))

    result))
#+end_src

** Format Plist to YAML

Convert plist back to v2.0 YAML format for writing.

#+begin_src elisp
(defun jf/gptel-scope--format-yaml (plan)
  "Format PLAN plist as v2.0 YAML string with tool-level permissions."
  (with-temp-buffer
    ;; Top-level metadata
    (insert "version: \"2.0\"\n")
    (insert (format "session_id: \"%s\"\n" (plist-get plan :session_id)))
    (insert (format "created: \"%s\"\n" (plist-get plan :created)))
    (insert (format "updated: \"%s\"\n" (plist-get plan :updated)))
    (insert (format "default_policy: %s\n\n" (plist-get plan :default_policy)))

    ;; Tools section
    (let ((tools-data (plist-get plan :tools)))
      (insert "tools:\n")
      (when tools-data
        ;; Iterate through tools
        (let ((keys (cl-loop for (k v) on tools-data by #'cddr
                            when (keywordp k) collect k)))
          (dolist (tool-key keys)
            (let* ((tool-name (substring (symbol-name tool-key) 1))
                   (tool-config (plist-get tools-data tool-key)))
              (insert (format "  %s:\n" tool-name))
              (insert (format "    allowed: %s\n"
                            (if (plist-get tool-config :allowed) "true" "false")))

              ;; Patterns list
              (let ((patterns (plist-get tool-config :patterns)))
                (insert "    patterns:\n")
                (if patterns
                    (dolist (pattern patterns)
                      (insert (format "      - \"%s\"\n" pattern)))
                  (insert "      []\n")))

              ;; Deny patterns list
              (let ((deny-patterns (plist-get tool-config :deny_patterns)))
                (insert "    deny_patterns:\n")
                (if deny-patterns
                    (dolist (pattern deny-patterns)
                      (insert (format "      - \"%s\"\n" pattern)))
                  (insert "      []\n")))

              (insert "\n"))))))

    (buffer-string)))
#+end_src

* Tool Permission System (v2.0)

This section implements the v2.0 permission system with tool-level granularity.

** Pattern Matching Helper

Check if a path matches any pattern in a list.

#+begin_src elisp
(defun jf/gptel-scope--matches-any-pattern (path patterns)
  "Check if PATH matches any pattern in PATTERNS list.
Returns t if any pattern matches, nil otherwise."
  (when patterns
    (cl-some (lambda (pattern)
              (jf/gptel-scope--matches-pattern path pattern))
            patterns)))
#+end_src

** Tool Permission Dispatch

Central dispatcher that routes permission checks to tool-specific validators.

#+begin_src elisp
(defun jf/gptel-scope--check-tool-permission (plan tool-name tool-args)
  "Check if TOOL-NAME is allowed in PLAN with TOOL-ARGS.
Routes to appropriate validator based on tool name.
Returns plist with :allowed t/nil and relevant patterns/config."
  (let* ((tools-config (plist-get plan :tools))
         (tool-config (when tools-config
                       (plist-get tools-config
                                 (intern (concat ":" tool-name))))))

    ;; Route to appropriate validator
    (pcase tool-name
      ("read_file"
       (jf/gptel-scope--validate-read-file tool-config tool-args))
      ("write_file_in_scope"
       (jf/gptel-scope--validate-write-file tool-config tool-args))
      ("edit_file_in_scope"
       (jf/gptel-scope--validate-edit-file tool-config tool-args))
      ("create_roam_node_in_scope"
       (jf/gptel-scope--validate-create-node tool-config tool-args))
      ("add_roam_tags_in_scope"
       (jf/gptel-scope--validate-add-tags tool-config tool-args))
      ("link_roam_nodes_in_scope"
       (jf/gptel-scope--validate-link-nodes tool-config tool-args))
      ("run_approved_command"
       (jf/gptel-scope--validate-shell-command tool-config tool-args))
      (_
       ;; Unknown tool - deny by default
       (list :allowed nil
             :error "unknown_tool"
             :message (format "Unknown tool: %s" tool-name))))))
#+end_src

** Tool-Specific Validators

*** Filesystem Tools

Validate read_file, write_file, and edit_file operations.

#+begin_src elisp
(defun jf/gptel-scope--validate-read-file (config args)
  "Validate read_file operation against CONFIG with ARGS.
Args: (filepath) - filepath is first argument."
  (unless config
    (cl-return-from jf/gptel-scope--validate-read-file
      (list :allowed nil
            :error "tool_not_configured"
            :message "read_file not configured in scope plan")))

  (unless (plist-get config :allowed)
    (cl-return-from jf/gptel-scope--validate-read-file
      (list :allowed nil
            :message "read_file explicitly disabled in scope plan")))

  (let* ((filepath (nth 0 args))
         (full-path (expand-file-name filepath))
         (patterns (plist-get config :patterns))
         (deny-patterns (plist-get config :deny_patterns)))

    ;; Check deny patterns first
    (when (and deny-patterns
               (jf/gptel-scope--matches-any-pattern full-path deny-patterns))
      (cl-return-from jf/gptel-scope--validate-read-file
        (list :allowed nil
              :patterns patterns
              :deny_patterns deny-patterns
              :resource full-path)))

    ;; Check allow patterns
    (if (and patterns
             (jf/gptel-scope--matches-any-pattern full-path patterns))
        (list :allowed t)
      (list :allowed nil
            :patterns patterns
            :deny_patterns deny-patterns
            :resource full-path))))

(defun jf/gptel-scope--validate-write-file (config args)
  "Validate write_file operation against CONFIG with ARGS.
Args: (filepath content) - filepath is first argument."
  (unless config
    (cl-return-from jf/gptel-scope--validate-write-file
      (list :allowed nil
            :error "tool_not_configured"
            :message "write_file_in_scope not configured in scope plan")))

  (unless (plist-get config :allowed)
    (cl-return-from jf/gptel-scope--validate-write-file
      (list :allowed nil
            :message "write_file_in_scope explicitly disabled in scope plan")))

  (let* ((filepath (nth 0 args))
         (full-path (expand-file-name filepath))
         (patterns (plist-get config :patterns))
         (deny-patterns (plist-get config :deny_patterns)))

    ;; Check deny patterns first
    (when (and deny-patterns
               (jf/gptel-scope--matches-any-pattern full-path deny-patterns))
      (cl-return-from jf/gptel-scope--validate-write-file
        (list :allowed nil
              :patterns patterns
              :deny_patterns deny-patterns
              :resource full-path)))

    ;; Check allow patterns
    (if (and patterns
             (jf/gptel-scope--matches-any-pattern full-path patterns))
        (list :allowed t)
      (list :allowed nil
            :patterns patterns
            :deny_patterns deny-patterns
            :resource full-path))))

(defun jf/gptel-scope--validate-edit-file (config args)
  "Validate edit_file operation against CONFIG with ARGS.
Args: (filepath old-string new-string) - filepath is first argument."
  (unless config
    (cl-return-from jf/gptel-scope--validate-edit-file
      (list :allowed nil
            :error "tool_not_configured"
            :message "edit_file_in_scope not configured in scope plan")))

  (unless (plist-get config :allowed)
    (cl-return-from jf/gptel-scope--validate-edit-file
      (list :allowed nil
            :message "edit_file_in_scope explicitly disabled in scope plan")))

  (let* ((filepath (nth 0 args))
         (full-path (expand-file-name filepath))
         (patterns (plist-get config :patterns))
         (deny-patterns (plist-get config :deny_patterns)))

    ;; Check deny patterns first
    (when (and deny-patterns
               (jf/gptel-scope--matches-any-pattern full-path deny-patterns))
      (cl-return-from jf/gptel-scope--validate-edit-file
        (list :allowed nil
              :patterns patterns
              :deny_patterns deny-patterns
              :resource full-path)))

    ;; Check allow patterns
    (if (and patterns
             (jf/gptel-scope--matches-any-pattern full-path patterns))
        (list :allowed t)
      (list :allowed nil
            :patterns patterns
            :deny_patterns deny-patterns
            :resource full-path))))
#+end_src

*** Org-Roam Tools

Validate org-roam node operations.

#+begin_src elisp
(defun jf/gptel-scope--validate-create-node (config args)
  "Validate create_roam_node operation against CONFIG with ARGS.
Args: (title subdirectory tags) - subdirectory and tags used for validation."
  (unless config
    (cl-return-from jf/gptel-scope--validate-create-node
      (list :allowed nil
            :error "tool_not_configured"
            :message "create_roam_node_in_scope not configured in scope plan")))

  (unless (plist-get config :allowed)
    (cl-return-from jf/gptel-scope--validate-create-node
      (list :allowed nil
            :message "create_roam_node_in_scope explicitly disabled in scope plan")))

  (let* ((subdirectory (nth 1 args))
         (tags (nth 2 args))
         (patterns (plist-get config :patterns))
         (allowed nil))

    ;; Check subdirectory patterns (format: "subdirectory:path")
    (when (and subdirectory patterns)
      (dolist (pattern patterns)
        (when (string-prefix-p "subdirectory:" pattern)
          (let ((subdir-pattern (substring pattern 13)))
            (when (string-match-p (jf/gptel-scope--glob-to-regex subdir-pattern)
                                subdirectory)
              (setq allowed t))))))

    ;; Check tag patterns (format: "tag:tagname")
    (when (and tags patterns)
      (dolist (tag tags)
        (dolist (pattern patterns)
          (when (string= pattern (concat "tag:" tag))
            (setq allowed t)))))

    (if allowed
        (list :allowed t)
      (list :allowed nil
            :patterns patterns
            :resource (format "subdirectory:%s tags:%s"
                            (or subdirectory "none")
                            (or (mapconcat #'identity tags ",") "none"))))))

(defun jf/gptel-scope--validate-add-tags (config args)
  "Validate add_roam_tags operation against CONFIG with ARGS.
Args: (node-id tags) - tags used for validation."
  (unless config
    (cl-return-from jf/gptel-scope--validate-add-tags
      (list :allowed nil
            :error "tool_not_configured"
            :message "add_roam_tags_in_scope not configured in scope plan")))

  (unless (plist-get config :allowed)
    (cl-return-from jf/gptel-scope--validate-add-tags
      (list :allowed nil
            :message "add_roam_tags_in_scope explicitly disabled in scope plan")))

  (let* ((tags (nth 1 args))
         (patterns (plist-get config :patterns))
         (allowed nil))

    ;; Check tag patterns (format: "tag:tagname")
    (when (and tags patterns)
      (dolist (tag tags)
        (dolist (pattern patterns)
          (when (string= pattern (concat "tag:" tag))
            (setq allowed t)))))

    (if allowed
        (list :allowed t)
      (list :allowed nil
            :patterns patterns
            :resource (format "tags:%s"
                            (mapconcat #'identity tags ","))))))

(defun jf/gptel-scope--validate-link-nodes (config args)
  "Validate link_roam_nodes operation against CONFIG with ARGS.
Args: (source-id target-id) - both node IDs used for validation."
  (unless config
    (cl-return-from jf/gptel-scope--validate-link-nodes
      (list :allowed nil
            :error "tool_not_configured"
            :message "link_roam_nodes_in_scope not configured in scope plan")))

  (unless (plist-get config :allowed)
    (cl-return-from jf/gptel-scope--validate-link-nodes
      (list :allowed nil
            :message "link_roam_nodes_in_scope explicitly disabled in scope plan")))

  ;; For now, if tool is allowed, all linking is allowed
  ;; Could be extended to check node subdirectories/tags
  (list :allowed t))
#+end_src

*** Shell Tools

Validate shell command execution.

#+begin_src elisp
(defun jf/gptel-scope--validate-shell-command (config args)
  "Validate shell command execution against CONFIG with ARGS.
Args: (command) - command string is first argument."
  (unless config
    (cl-return-from jf/gptel-scope--validate-shell-command
      (list :allowed nil
            :error "tool_not_configured"
            :message "run_approved_command not configured in scope plan")))

  (unless (plist-get config :allowed)
    (cl-return-from jf/gptel-scope--validate-shell-command
      (list :allowed nil
            :message "run_approved_command explicitly disabled in scope plan")))

  (let* ((command (nth 0 args))
         (cmd-name (car (split-string command)))
         (patterns (plist-get config :patterns))
         (deny-patterns (plist-get config :deny_patterns))
         (allowed nil)
         (denied nil))

    ;; Check deny patterns (substring matching)
    (when deny-patterns
      (dolist (deny-pattern deny-patterns)
        (when (string-match-p (regexp-quote deny-pattern) command)
          (setq denied t))))

    ;; Check allow patterns (exact command name match)
    (when patterns
      (dolist (pattern patterns)
        (when (string= cmd-name pattern)
          (setq allowed t))))

    (if (and allowed (not denied))
        (list :allowed t)
      (list :allowed nil
            :patterns patterns
            :deny_patterns deny-patterns
            :resource command))))
#+end_src


* Glob Pattern Matching

** Convert Glob to Regex

Convert glob patterns to regex, supporting =**=, =*=, and =?= wildcards.

#+begin_src elisp
(defun jf/gptel-scope--glob-to-regex (pattern)
  "Convert glob PATTERN to regex string.
Supports:
  ** - Match any characters including /
  *  - Match any characters except /
  ?  - Match single character"
  (let ((regex pattern))
    ;; Escape regex special characters (except * and ?)
    (setq regex (replace-regexp-in-string "[.+^$()\\[\\]{}|\\\\]" "\\\\\\&" regex))
    ;; Convert glob wildcards to regex
    (setq regex (replace-regexp-in-string "\\*\\*" "DOUBLESTAR" regex))
    (setq regex (replace-regexp-in-string "\\*" "[^/]*" regex))
    (setq regex (replace-regexp-in-string "DOUBLESTAR" ".*" regex))
    (setq regex (replace-regexp-in-string "\\?" "." regex))
    ;; Anchor pattern
    (concat "^" regex "$")))
#+end_src

** Test Path Against Pattern

Check if a path matches a glob pattern.

#+begin_src elisp
(defun jf/gptel-scope--matches-pattern (path pattern)
  "Check if PATH matches glob PATTERN.
Expands relative paths to absolute, resolves symlinks."
  (let* ((abs-path (expand-file-name path))
         (real-path (file-truename abs-path))
         (expanded-pattern (expand-file-name pattern))
         (regex (jf/gptel-scope--glob-to-regex expanded-pattern)))
    (or (string-match-p regex real-path)
        (string-match-p regex abs-path))))
#+end_src


* Error Formatting

** Format Tool Error

Create standardized error response for tool-level permission violations.

#+begin_src elisp
(defun jf/gptel-scope--format-tool-error (tool-name resource check-result)
  "Format tool permission error for LLM.
TOOL-NAME: Name of the tool that was denied
RESOURCE: The resource that was denied (path, node-id, command, etc.)
CHECK-RESULT: Plist from validator with :allowed, :patterns, :deny_patterns"
  (let ((patterns (plist-get check-result :patterns))
        (deny-patterns (plist-get check-result :deny_patterns))
        (error-type (or (plist-get check-result :error) "scope_violation"))
        (custom-message (plist-get check-result :message)))
    (list :success nil
          :error error-type
          :tool tool-name
          :resource resource
          :allowed_patterns patterns
          :deny_patterns deny-patterns
          :message (or custom-message
                      (format "Tool '%s' denied for resource '%s'. Use request_scope_expansion to ask user for approval."
                             tool-name
                             resource)))))
#+end_src

* Provide Feature

#+begin_src elisp
(provide 'jf-gptel-scope-core)
;;; scope-core.el ends here
#+end_src
