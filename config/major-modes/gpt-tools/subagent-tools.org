#+title: GPTEL Subagent Tools (DEPRECATED)
#+author: Jeff Farr
#+property: header-args:emacs-lisp :tangle no
#+auto_tangle: no

* DEPRECATED - Legacy Implementation

**This file has been superseded by gptel-agent integration.**

This file contains a legacy custom subagent implementation that is preserved
for reference only. The functionality has been replaced by integrating the
gptel-agent package with custom agent definitions.

** Why Deprecated

The gptel-agent package provides superior implementation:
- *Proven invisible execution* - No buffer clutter from subagent execution
- *File-based agent definitions* - Agents defined in markdown/org files with YAML frontmatter
- *Robust FSM and callback handling* - 500+ lines of battle-tested state management
- *Standard "Agent" tool* - Consistent with upstream gptel ecosystem
- *Template system* - Dynamic agent discovery via {{AGENTS}} templates
- *Community alignment* - Uses patterns others can understand and extend

Our custom implementation had significant limitations:
- *Visible buffers* - Created `*gptel-subagent-*` buffers that cluttered the UI
- *Hardcoded presets* - Used `gptel-make-preset` directly in elisp, not file-based
- *Custom tool* - `invoke_subagent` duplicated functionality of gptel-agent's "Agent" tool
- *Complex manual FSM* - Callback logic was error-prone and hard to maintain

** Migration Guide

Use the "Agent" tool with agents defined in `emacs/major-modes/gpt-tools/agents/`:

- *explorer* - Read-only code exploration (filesystem, projectile, ggtags tools)
- *planner* - Planning and requirements gathering (can delegate to explorer)
- *executor* - Autonomous execution with file modifications
- *researcher* - Web research and documentation (from gptel-agent)
- *introspector* - Emacs/elisp introspection (from gptel-agent)

See `emacs/major-modes/gpt-tools/README.org` for complete documentation.

** Agent Definition Example

#+begin_example
---
name: my-agent
description: Brief description of agent purpose
tools:
  - Glob
  - Read
  - my_custom_tool
backend: Claude
model: claude-3-7-sonnet-20250219
temperature: 0.5
---

You are a custom agent...

<agent instructions here>
#+end_example

Run `(gptel-agent-update)` to register the agent.

* Legacy Implementation (Reference Only)

The code below is kept for reference but is no longer loaded.

Tools for subagent delegation within gptel sessions. This enabled primary agents
to delegate specialized tasks to isolated subagents (Explore and Plan types) that
ran with their own tool sets, models, and configurations.

** Architecture

- *FSM Isolation*: Each subagent runs in its own gptel-fsm instance
- *Visible Buffer Execution*: Subagents execute in visible buffers for easy debugging and inspection
- *Tool-Driven Invocation*: Delegation exposed as async tool that parent agents call
- *Profile-Based Configuration*: Uses gptel-make-preset to define reusable profiles
- *Result Streaming*: Subagent responses flow back via callbacks

** Usage Pattern

Primary agent invokes subagent via the =invoke_subagent= tool:

#+begin_example
invoke_subagent(
  agent_profile="explore-agent",
  task_description="Analyze authentication system in /path/to/project",
  context_files=["/path/to/project/auth.el"]
)
#+end_example

* Basic Configuration

#+begin_src emacs-lisp
;;; subagent-tools.el --- GPTEL tools for subagent delegation -*- lexical-binding: t; -*-
;;
;; Author: Jeff Farr
;; Keywords: tools, ai, delegation
;;
;;; Commentary:
;;
;; Provides subagent delegation capability for gptel, enabling primary agents
;; to delegate specialized tasks to isolated subagents with their own tool sets.
;;
;;; Code:

;; No requires needed - gptel is loaded before this module
#+end_src

* Configuration Variables

#+begin_src emacs-lisp
(defvar-local jf/gptel--delegation-depth 0
  "Current depth of subagent delegation.
Used to prevent infinite recursion by tracking how many levels deep
we are in nested subagent calls.")

(defvar jf/gptel-max-delegation-depth 3
  "Maximum allowed subagent delegation depth.
Prevents excessive nesting that could lead to runaway delegation chains.
Set to 3 by default to allow: primary -> plan-agent -> explore-agent.")
#+end_src

* Subagent Profiles

Profiles define reusable subagent configurations including backend, model,
system message, tools, and temperature settings.

** Explore Agent Profile

Read-only investigation agent with filesystem, project navigation, semantic
code tools, and web access.

#+begin_src emacs-lisp
(gptel-make-preset 'explore-agent
  :description "Subagent for read-only code exploration and semantic analysis"
  :backend "Claude"
  :model 'claude-3-7-sonnet-20250219
  :system "You are an exploration agent. Your role is to gather semantic information about code, summarize functionality, implementation details, and architecture. You have read-only access to the codebase.

Focus on:
- Understanding code structure and organization
- Identifying key functions, classes, and modules
- Tracing data flow and dependencies
- Summarizing implementation approaches
- Noting architectural patterns

You can read files, navigate projects with projectile, use ggtags for semantic navigation, and search the web for context."
  :tools '(;; Filesystem tools
           "read_file"
           "list_directory"
           ;; Projectile tools
           "list_known_projects"
           "get_project_info"
           "list_project_files"
           "list_project_directories"
           "search_project_content"
           ;; Ggtags tools
           "check_ggtags_project"
           "find_definition"
           "find_references"
           "find_symbol"
           "grep_project")
  :temperature 0.5)
#+end_src

** Plan Agent Profile

Planning and requirements gathering agent with delegation capability.

#+begin_src emacs-lisp
(gptel-make-preset 'plan-agent
  :description "Subagent for planning and requirements gathering with delegation"
  :backend "Claude"
  :model 'claude-3-7-sonnet-20250219
  :system "You are a planning agent. Your role is to understand user requirements, develop detailed implementation plans, and delegate exploration tasks when needed.

Focus on:
- Gathering requirements through dialog
- Breaking down complex tasks into steps
- Identifying what information is needed
- Delegating exploration to explore-agent when you need code analysis
- Including questions in your result when you need user input

When you need the user to answer questions, include them clearly in your response
formatted for the primary agent to forward to the user.

When you need to understand code structure or gather information about a codebase,
use the invoke_subagent tool to delegate to explore-agent."
  :tools '("invoke_subagent"
           "read_file"
           "list_directory")
  :temperature 0.7)
#+end_src

* Result Formatting

Format subagent results for parent agent consumption with clear delimiters.

#+begin_src emacs-lisp
(defun jf/gptel--format-subagent-result (agent-profile task response)
  "Format subagent final response for parent agent consumption.
AGENT-PROFILE is the profile name used (e.g., 'explore-agent').
TASK is the task description that was delegated.
RESPONSE is the final response from the subagent."
  (format "=== Subagent Result ===
Agent: %s
Task: %s

%s

=== End Subagent Result ==="
          agent-profile task response))
#+end_src

* Core Execution Logic

The execution engine creates isolated subagent contexts and manages their lifecycle.

#+begin_src emacs-lisp
(defun jf/gptel-invoke-subagent (callback agent-profile task-description
                                 &optional context-files)
  "Invoke a subagent with AGENT-PROFILE to handle TASK-DESCRIPTION.
CALLBACK is called with the result when subagent completes.
CONTEXT-FILES is optional list of file paths to include in context.

The subagent runs in a visible buffer with its own tools, backend, model,
and system message as defined by the profile. Results are streamed back
and the buffer remains open for inspection."

  ;; 1. Resolve preset
  (let* ((preset (alist-get (intern agent-profile) gptel--known-presets))
         (buffer-name (format "*gptel-subagent-%s-%s*"
                             agent-profile
                             (format-time-string "%Y%m%d-%H%M%S")))
         (parent-buffer (current-buffer)))

    ;; Validation
    (unless preset
      (funcall callback (format "Error: Unknown agent profile '%s'" agent-profile))
      (cl-return-from jf/gptel-invoke-subagent))

    ;; Depth check
    (when (>= (or jf/gptel--delegation-depth 0)
              jf/gptel-max-delegation-depth)
      (funcall callback
               (format "Error: Maximum delegation depth (%d) reached. Cannot delegate further to avoid runaway chains."
                       jf/gptel-max-delegation-depth))
      (cl-return-from jf/gptel-invoke-subagent))

    ;; 2. Create visible buffer
    (with-current-buffer (get-buffer-create buffer-name)
      ;; Enable gptel-mode to get buffer-local state
      (markdown-mode)
      (gptel-mode 1)

      ;; 3. Apply preset to buffer (sets tools, backend, model, system)
      (gptel--apply-preset preset)

      ;; Validate that preset was applied correctly
      (unless gptel-backend
        (with-current-buffer parent-buffer
          (funcall callback "Error: Backend not set after applying preset"))
        (kill-buffer (current-buffer))
        (cl-return-from jf/gptel-invoke-subagent))

      (unless gptel-model
        (with-current-buffer parent-buffer
          (funcall callback "Error: Model not set after applying preset"))
        (kill-buffer (current-buffer))
        (cl-return-from jf/gptel-invoke-subagent))

      ;; 4. Track delegation depth
      (setq-local jf/gptel--delegation-depth
                  (1+ (with-current-buffer parent-buffer
                        (or jf/gptel--delegation-depth 0))))

      ;; 5. Set up context if provided
      (when context-files
        (setq-local gptel-context
                    (mapcar (lambda (f) (list :source f)) context-files)))

      ;; 5.5. Insert the task into the buffer (gptel expects buffer content)
      (goto-char (point-max))
      (insert "# Task\n\n" task-description "\n\n")

      ;; 6. Build callback wrapper
      (let ((result-accumulator "")
            (had-tool-calls nil))  ; Track if we've seen tool calls
        (letrec ((subagent-callback
                  (lambda (response info)
                    (message "Subagent callback: response type=%s, length=%s, had-tools=%s"
                             (type-of response)
                             (if (stringp response) (length response) "N/A")
                             had-tool-calls)
                    (cond
                     ;; Streaming: accumulate chunks
                     ((stringp response)
                      (setq result-accumulator
                            (concat result-accumulator response)))

                     ;; Success: but check if there are pending tool calls
                     ((eq response t)
                      ;; Check info plist for tool-use - it's set BEFORE this callback
                      (let* ((tool-use (plist-get info :tool-use))
                             (has-pending-tools (and tool-use (> (length tool-use) 0))))
                        (message "Subagent response complete: pending-tools=%s, result length=%d"
                                 has-pending-tools (length result-accumulator))
                        (if (or has-pending-tools had-tool-calls)
                            ;; Tool calls pending or were made, more turns coming
                            (progn
                              (message "Subagent has tool calls, waiting for continuation...")
                              (setq had-tool-calls nil))
                          ;; No tool calls, this is the final response
                          (progn
                            (message "Subagent FULLY completed! Returning to parent.")
                            (with-current-buffer parent-buffer
                              (funcall callback
                                       (jf/gptel--format-subagent-result
                                        agent-profile task-description result-accumulator)))))))

                     ;; Tool calls: let FSM handle and set flag
                     ((and (consp response)
                           (memq (car response) '(tool-call tool-result)))
                      (message "Subagent tool operation detected: %s" (car response))
                      (setq had-tool-calls t)
                      nil)

                     ;; Error or abort
                     (t
                      (with-current-buffer parent-buffer
                        (funcall callback
                                 (format "Subagent error: %s"
                                         (plist-get info :status)))))))))

          ;; 7. Fire the request
          (message "Subagent firing request in buffer %s with backend=%s model=%s"
                   (buffer-name) gptel-backend gptel-model)
          ;; Use buffer as the prompt source, not the string
          ;; This is more reliable for streaming mode
          (gptel-request nil  ; nil means use buffer content
                         :buffer (current-buffer)
                         :position (point-marker)
                         :stream t
                         :callback subagent-callback))))))
#+end_src

* Subagent Invocation Tool

The tool definition that exposes subagent invocation to LLM agents.

#+begin_src emacs-lisp
(gptel-make-tool
 :name "invoke_subagent"
 :function #'jf/gptel-invoke-subagent
 :async t
 :description "Delegate a task to a specialized subagent running in an isolated context with its own tools and configuration.

Use this to break complex tasks into focused subtasks that benefit from specialized tool access or system prompts.

The subagent will execute independently, use its tools as needed, and return a final result summarizing its findings.

Available agents:
- explore-agent: Read-only code investigation with filesystem, projectile, ggtags, and web tools. Use for analyzing code structure, understanding implementations, or gathering information about a codebase.
- plan-agent: Planning and requirements gathering with delegation capability. Use for developing implementation plans or coordinating multiple exploration tasks.

Important: The subagent's full conversation history is NOT returned to you - only its final response. The subagent may use multiple tool calls internally but you'll just see the summary."
 :args (list
        '(:name "agent_profile"
          :type string
          :enum ["explore-agent" "plan-agent"]
          :description "Which subagent profile to use. explore-agent: read-only code investigation. plan-agent: planning with delegation.")
        '(:name "task_description"
          :type string
          :description "Clear, specific task for the subagent. Include context about what you need and what deliverables you expect. Be specific about the scope and any constraints.")
        '(:name "context_files"
          :type array
          :items (:type string)
          :optional t
          :description "Optional list of file paths to include in the subagent's context. These files will be available for the subagent to reference."))
 :category "delegation"
 :confirm t)
#+end_src

* Footer

#+begin_src emacs-lisp
(message "Loaded subagent-tools: presets=%S"
         (mapcar #'car (cl-remove-if-not
                        (lambda (p) (memq (car p) '(explore-agent plan-agent)))
                        gptel--known-presets)))

(provide 'subagent-tools)
;;; subagent-tools.el ends here
#+end_src
