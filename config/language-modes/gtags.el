;; -*- lexical-binding: t; -*-

(defun jf/gtags-check-binary ()
  "Check if global binary is available. Return path or nil."
  (executable-find "global"))

(defun jf/gtags-ensure-binary ()
  "Ensure global binary exists, show helpful error if not."
  (unless (jf/gtags-check-binary)
    (display-warning
     'gtags
     (concat "GNU Global (gtags) not found in PATH.\n\n"
             "Install with: brew install global\n\n"
             "ggtags features will be unavailable until installed.")
     :error)
    nil))

(defgroup jf-gtags nil
  "Customization for JF's gtags configuration."
  :group 'ggtags)

(defcustom jf/gtags-auto-create-on-project-switch t
  "When non-nil, automatically create GTAGS on project switch if missing."
  :type 'boolean
  :group 'jf-gtags)

(defcustom jf/gtags-create-git-hooks t
  "When non-nil, automatically create git post-commit hooks for tag updates."
  :type 'boolean
  :group 'jf-gtags)

(defcustom jf/gtags-enabled-modes
  '(python-mode js-mode typescript-mode go-mode c-mode c++-mode)
  "List of modes where ggtags-mode should be automatically enabled."
  :type '(repeat symbol)
  :group 'jf-gtags)

(defun jf/gtags-project-has-source-files-p (directory)
  "Quick check if project has indexable source files."
  (let ((default-directory directory))
    (or (file-expand-wildcards "*.py")
        (file-expand-wildcards "*.js")
        (file-expand-wildcards "*.ts")
        (file-expand-wildcards "*.go")
        (file-expand-wildcards "*.c")
        (file-expand-wildcards "*.cpp"))))

(defun jf/gtags-create-tags-async (directory)
  "Create GTAGS database asynchronously in DIRECTORY."
  (let ((default-directory directory)
        (process-name "gtags-create")
        (buffer-name "*gtags-create*"))
    (when (get-process process-name)
      (delete-process process-name))
    (let ((proc (start-process
                 process-name buffer-name
                 "gtags" "--gtagslabel=pygments")))
      (set-process-sentinel
       proc
       (lambda (process event)
         (cond
          ((string-match-p "finished" event)
           (message "GTAGS database created for %s" directory))
          ((string-match-p "exited abnormally" event)
           (display-warning
            'gtags
            (format "Failed to create GTAGS: %s\nCheck *gtags-create* buffer" event)
            :error))))))))

(defun jf/gtags-auto-create-if-needed ()
  "Create GTAGS database if project has none. Runs async, non-blocking."
  (when (and (jf/gtags-check-binary)
             (projectile-project-root)
             (not (ggtags-find-project)))
    (let ((project-root (projectile-project-root)))
      (when (jf/gtags-project-has-source-files-p project-root)
        (message "Creating GTAGS database for %s..." project-root)
        (jf/gtags-create-tags-async project-root)))))

(defun create-tags-git-hook ()
  "Create git post-commit hook to update GTAGS. Idempotent."
  (when-let ((project-root (projectile-project-root))
             (git-dir (expand-file-name ".git" project-root)))
    (when (file-directory-p git-dir)
      (let* ((hook-path (expand-file-name "hooks/post-commit" git-dir))
             (hook-dir (file-name-directory hook-path))
             (shebang "#!/bin/sh")
             (command "\n# auto-generated by emacs create-tags-git-hook\nglobal -u\n"))
        ;; Ensure hooks directory exists
        (unless (file-exists-p hook-dir)
          (make-directory hook-dir t))

        (if (file-exists-p hook-path)
            (let ((existing-content (with-temp-buffer
                                      (insert-file-contents hook-path)
                                      (buffer-string))))
              (unless (string-match-p (regexp-quote command) existing-content)
                (append-to-file command nil hook-path)))
          (with-temp-file hook-path
            (insert shebang command)))

        (set-file-modes hook-path #o755)
        (message "Git post-commit hook configured for %s" project-root)))))

(defun jf/gtags-after-project-switch (&rest _args)
  "Setup GTAGS after switching projects."
  (when (jf/gtags-check-binary)
    (when jf/gtags-create-git-hooks
      (create-tags-git-hook))
    (when jf/gtags-auto-create-on-project-switch
      (jf/gtags-auto-create-if-needed))))

(advice-add 'projectile-switch-project-by-name :after #'jf/gtags-after-project-switch)
(advice-add 'projectile-switch-open-project :after #'jf/gtags-after-project-switch)
(advice-add 'projectile-switch-project :after #'jf/gtags-after-project-switch)
(advice-add 'consult-projectile-switch-project :after #'jf/gtags-after-project-switch)

(use-package ggtags
  :straight t
  :custom
  (ggtags-update-on-save t)  ; Auto-update tags on file save
  (ggtags-oversize-limit (* 50 1024 1024))  ; 50MB threshold
  (ggtags-sort-by-nearness nil)

  :config
  ;; Check binary exists
  (jf/gtags-ensure-binary)

  ;; Setup project switching hooks
  (advice-add 'projectile-switch-project-by-name :after #'jf/gtags-after-project-switch)
  (advice-add 'projectile-switch-open-project :after #'jf/gtags-after-project-switch)
  (advice-add 'projectile-switch-project :after #'jf/gtags-after-project-switch)
  (advice-add 'consult-projectile-switch-project :after #'jf/gtags-after-project-switch)

  ;; Enable for programming modes
  (dolist (mode jf/gtags-enabled-modes)
    (add-hook (intern (concat (symbol-name mode) "-hook")) #'ggtags-mode)))

;; Set GTAGSLABEL environment variable for pygments-based parsing
(setenv "GTAGSLABEL" "pygments")

;; Configure how ggtags displays its results
(setq display-buffer-alist
      '(("\\*ggtags-global\\*"
         (display-buffer-reuse-window display-buffer-in-side-window)
         (side . bottom)
         (window-height . 0.3)
         (select-window . t))))

;; (defun my-ggtags-focus-window ()
;;   "Automatically select the ggtags results window."
;;   (let ((ggtags-window (get-buffer-window "*ggtags-global*")))
;;     (when ggtags-window
;;       (select-window ggtags-window))))

;; ;; Hook to focus the ggtags window after a search
;; (add-hook 'ggtags-find-tag-hook 'my-ggtags-focus-window)
